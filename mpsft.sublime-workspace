{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"sqr",
				"sqrt_c_delta_"
			]
		]
	},
	"buffers":
	[
		{
			"file": "README.md",
			"settings":
			{
				"buffer_size": 461,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/binner.h",
			"settings":
			{
				"buffer_size": 352,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 275 files for \"double\"\n\n/home/jchiu/projects/mpsft/src/base.h:\n   11  using Int = int32_t;\n   12  using Long = int64_t;\n   13: using Real = double;\n   14  using Cplex = std::complex<Real>;\n   15  \n\n/home/jchiu/projects/mpsft/src/catch.hpp:\n 1647  std::string toString(unsigned long value);\n 1648  std::string toString(unsigned int value);\n 1649: std::string toString(const double value);\n 1650  std::string toString(const float value);\n 1651  std::string toString(bool value);\n ....\n 2233                                      // runtime but it forces the\n 2234                                      // compiler to give it a look\n 2235: // The double negation silences MSVC's C4800 warning, the static_cast forces\n 2236  // short-circuit evaluation if the type has overloaded &&.\n 2237  \n ....\n 2276                                      // runtime but it forces the\n 2277                                      // compiler to give it a look\n 2278: // The double negation silences MSVC's C4800 warning, the static_cast forces\n 2279  // short-circuit evaluation if the type has overloaded &&.\n 2280  \n ....\n 2468  struct SectionEndInfo {\n 2469    SectionEndInfo(SectionInfo const &_sectionInfo, Counts const &_prevAssertions,\n 2470:                  double _durationInSeconds)\n 2471        : sectionInfo(_sectionInfo), prevAssertions(_prevAssertions),\n 2472          durationInSeconds(_durationInSeconds) {}\n ....\n 2474    SectionInfo sectionInfo;\n 2475    Counts prevAssertions;\n 2476:   double durationInSeconds;\n 2477  };\n 2478  \n ....\n 2501    unsigned int getElapsedMicroseconds() const;\n 2502    unsigned int getElapsedMilliseconds() const;\n 2503:   double getElapsedSeconds() const;\n 2504  \n 2505  private:\n ....\n 2839  class Approx {\n 2840  public:\n 2841:   explicit Approx(double value)\n 2842        : m_epsilon(std::numeric_limits<float>::epsilon() * 100), m_margin(0.0),\n 2843          m_scale(1.0), m_value(value) {}\n ....\n 2852  \n 2853    template <typename T, typename = typename std::enable_if<\n 2854:                             std::is_constructible<double, T>::value>::type>\n 2855    Approx operator()(T value) {\n 2856:     Approx approx(static_cast<double>(value));\n 2857      approx.epsilon(m_epsilon);\n 2858      approx.margin(m_margin);\n ....\n 2862  \n 2863    template <typename T, typename = typename std::enable_if<\n 2864:                             std::is_constructible<double, T>::value>::type>\n 2865:   explicit Approx(T value) : Approx(static_cast<double>(value)) {}\n 2866  \n 2867    template <typename T, typename = typename std::enable_if<\n 2868:                             std::is_constructible<double, T>::value>::type>\n 2869    friend bool operator==(const T &lhs, Approx const &rhs) {\n 2870      // Thanks to Richard Harris for his help refining this formula\n 2871:     auto lhs_v = double(lhs);\n 2872      bool relativeOK =\n 2873          std::fabs(lhs_v - rhs.m_value) <\n ....\n 2881  \n 2882    template <typename T, typename = typename std::enable_if<\n 2883:                             std::is_constructible<double, T>::value>::type>\n 2884    friend bool operator==(Approx const &lhs, const T &rhs) {\n 2885      return operator==(rhs, lhs);\n ....\n 2887  \n 2888    template <typename T, typename = typename std::enable_if<\n 2889:                             std::is_constructible<double, T>::value>::type>\n 2890    friend bool operator!=(T lhs, Approx const &rhs) {\n 2891      return !operator==(lhs, rhs);\n ....\n 2893  \n 2894    template <typename T, typename = typename std::enable_if<\n 2895:                             std::is_constructible<double, T>::value>::type>\n 2896    friend bool operator!=(Approx const &lhs, T rhs) {\n 2897      return !operator==(rhs, lhs);\n ....\n 2899  \n 2900    template <typename T, typename = typename std::enable_if<\n 2901:                             std::is_constructible<double, T>::value>::type>\n 2902    friend bool operator<=(T lhs, Approx const &rhs) {\n 2903:     return double(lhs) < rhs.m_value || lhs == rhs;\n 2904    }\n 2905  \n 2906    template <typename T, typename = typename std::enable_if<\n 2907:                             std::is_constructible<double, T>::value>::type>\n 2908    friend bool operator<=(Approx const &lhs, T rhs) {\n 2909:     return lhs.m_value < double(rhs) || lhs == rhs;\n 2910    }\n 2911  \n 2912    template <typename T, typename = typename std::enable_if<\n 2913:                             std::is_constructible<double, T>::value>::type>\n 2914    friend bool operator>=(T lhs, Approx const &rhs) {\n 2915:     return double(lhs) > rhs.m_value || lhs == rhs;\n 2916    }\n 2917  \n 2918    template <typename T, typename = typename std::enable_if<\n 2919:                             std::is_constructible<double, T>::value>::type>\n 2920    friend bool operator>=(Approx const &lhs, T rhs) {\n 2921:     return lhs.m_value > double(rhs) || lhs == rhs;\n 2922    }\n 2923  \n 2924    template <typename T, typename = typename std::enable_if<\n 2925:                             std::is_constructible<double, T>::value>::type>\n 2926    Approx &epsilon(T newEpsilon) {\n 2927:     m_epsilon = double(newEpsilon);\n 2928      return *this;\n 2929    }\n 2930  \n 2931    template <typename T, typename = typename std::enable_if<\n 2932:                             std::is_constructible<double, T>::value>::type>\n 2933    Approx &margin(T newMargin) {\n 2934:     m_margin = double(newMargin);\n 2935      return *this;\n 2936    }\n 2937  \n 2938    template <typename T, typename = typename std::enable_if<\n 2939:                             std::is_constructible<double, T>::value>::type>\n 2940    Approx &scale(T newScale) {\n 2941:     m_scale = double(newScale);\n 2942      return *this;\n 2943    }\n ....\n 2945  #else\n 2946  \n 2947:   Approx operator()(double value) {\n 2948      Approx approx(value);\n 2949      approx.epsilon(m_epsilon);\n ....\n 2953    }\n 2954  \n 2955:   friend bool operator==(double lhs, Approx const &rhs) {\n 2956      // Thanks to Richard Harris for his help refining this formula\n 2957      bool relativeOK =\n ....\n 2965    }\n 2966  \n 2967:   friend bool operator==(Approx const &lhs, double rhs) {\n 2968      return operator==(rhs, lhs);\n 2969    }\n 2970  \n 2971:   friend bool operator!=(double lhs, Approx const &rhs) {\n 2972      return !operator==(lhs, rhs);\n 2973    }\n 2974  \n 2975:   friend bool operator!=(Approx const &lhs, double rhs) {\n 2976      return !operator==(rhs, lhs);\n 2977    }\n 2978  \n 2979:   friend bool operator<=(double lhs, Approx const &rhs) {\n 2980      return lhs < rhs.m_value || lhs == rhs;\n 2981    }\n 2982  \n 2983:   friend bool operator<=(Approx const &lhs, double rhs) {\n 2984      return lhs.m_value < rhs || lhs == rhs;\n 2985    }\n 2986  \n 2987:   friend bool operator>=(double lhs, Approx const &rhs) {\n 2988      return lhs > rhs.m_value || lhs == rhs;\n 2989    }\n 2990  \n 2991:   friend bool operator>=(Approx const &lhs, double rhs) {\n 2992      return lhs.m_value > rhs || lhs == rhs;\n 2993    }\n 2994  \n 2995:   Approx &epsilon(double newEpsilon) {\n 2996      m_epsilon = newEpsilon;\n 2997      return *this;\n 2998    }\n 2999  \n 3000:   Approx &margin(double newMargin) {\n 3001      m_margin = newMargin;\n 3002      return *this;\n 3003    }\n 3004  \n 3005:   Approx &scale(double newScale) {\n 3006      m_scale = newScale;\n 3007      return *this;\n ....\n 3016  \n 3017  private:\n 3018:   double m_epsilon;\n 3019:   double m_margin;\n 3020:   double m_scale;\n 3021:   double m_value;\n 3022  };\n 3023  }\n ....\n 3272  \n 3273      // These are here to force alignment for the storage\n 3274:     long double dummy1;\n 3275      void (*dummy2)();\n 3276:     long double dummy3;\n 3277  #ifdef CATCH_CONFIG_CPP11_LONG_LONG\n 3278      long long dummy4;\n ....\n 4740    void parseIntoTokens(std::vector<std::string> const &args,\n 4741                         std::vector<Token> &tokens) {\n 4742:     const std::string doubleDash = \"--\";\n 4743:     for (std::size_t i = 1; i < args.size() && args[i] != doubleDash; ++i)\n 4744        parseIntoTokens(args[i], tokens);\n 4745    }\n ....\n 5818  struct SectionStats {\n 5819    SectionStats(SectionInfo const &_sectionInfo, Counts const &_assertions,\n 5820:                double _durationInSeconds, bool _missingAssertions)\n 5821        : sectionInfo(_sectionInfo), assertions(_assertions),\n 5822          durationInSeconds(_durationInSeconds),\n ....\n 5832    SectionInfo sectionInfo;\n 5833    Counts assertions;\n 5834:   double durationInSeconds;\n 5835    bool missingAssertions;\n 5836  };\n ....\n 6947      m_reporter->sectionStarting(testCaseSection);\n 6948      Counts prevAssertions = m_totals.assertions;\n 6949:     double duration = 0;\n 6950      m_shouldReportUnexpected = true;\n 6951      try {\n ....\n 8667    return static_cast<unsigned int>(getElapsedMicroseconds() / 1000);\n 8668  }\n 8669: double Timer::getElapsedSeconds() const {\n 8670    return getElapsedMicroseconds() / 1000000.0;\n 8671  }\n ....\n 9063  }\n 9064  \n 9065: std::string toString(const double value) { return fpToString(value, 10); }\n 9066  std::string toString(const float value) { return fpToString(value, 5) + 'f'; }\n 9067  \n ....\n 9585  // Because formatting using c++ streams is stateful, drop down to C is required\n 9586  // Alternatively we could use stringstream, but its performance is... not good.\n 9587: std::string getFormattedDuration(double duration) {\n 9588    // Max exponent + 1 is required to represent the whole part\n 9589    // + 1 for decimal point\n 9590    // + 3 for the 3 decimal places\n 9591    // + 1 for null terminator\n 9592:   const size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;\n 9593:   char buffer[maxDoubleSize];\n 9594  \n 9595    // Save previous errno, to prevent sprintf from overwriting it\n ....\n 10465    virtual void\n 10466    testGroupEnded(TestGroupStats const &testGroupStats) CATCH_OVERRIDE {\n 10467:     double suiteTime = suiteTimer.getElapsedSeconds();\n 10468      CumulativeReporterBase::testGroupEnded(testGroupStats);\n 10469      writeGroup(*m_testGroups.back(), suiteTime);\n .....\n 10472    virtual void testRunEndedCumulative() CATCH_OVERRIDE { xml.endElement(); }\n 10473  \n 10474:   void writeGroup(TestGroupNode const &groupNode, double suiteTime) {\n 10475      XmlWriter::ScopedElement e = xml.scopedElement(\"testsuite\");\n 10476      TestGroupStats const &stats = groupNode.value;\n\n/home/jchiu/projects/mpsft/src/bazel-src/base.h:\n   11  using Int = int32_t;\n   12  using Long = int64_t;\n   13: using Real = double;\n   14  using Cplex = std::complex<Real>;\n   15  \n\n/home/jchiu/projects/mpsft/src/bazel-src/catch.hpp:\n 1647  std::string toString(unsigned long value);\n 1648  std::string toString(unsigned int value);\n 1649: std::string toString(const double value);\n 1650  std::string toString(const float value);\n 1651  std::string toString(bool value);\n ....\n 2233                                      // runtime but it forces the\n 2234                                      // compiler to give it a look\n 2235: // The double negation silences MSVC's C4800 warning, the static_cast forces\n 2236  // short-circuit evaluation if the type has overloaded &&.\n 2237  \n ....\n 2276                                      // runtime but it forces the\n 2277                                      // compiler to give it a look\n 2278: // The double negation silences MSVC's C4800 warning, the static_cast forces\n 2279  // short-circuit evaluation if the type has overloaded &&.\n 2280  \n ....\n 2468  struct SectionEndInfo {\n 2469    SectionEndInfo(SectionInfo const &_sectionInfo, Counts const &_prevAssertions,\n 2470:                  double _durationInSeconds)\n 2471        : sectionInfo(_sectionInfo), prevAssertions(_prevAssertions),\n 2472          durationInSeconds(_durationInSeconds) {}\n ....\n 2474    SectionInfo sectionInfo;\n 2475    Counts prevAssertions;\n 2476:   double durationInSeconds;\n 2477  };\n 2478  \n ....\n 2501    unsigned int getElapsedMicroseconds() const;\n 2502    unsigned int getElapsedMilliseconds() const;\n 2503:   double getElapsedSeconds() const;\n 2504  \n 2505  private:\n ....\n 2839  class Approx {\n 2840  public:\n 2841:   explicit Approx(double value)\n 2842        : m_epsilon(std::numeric_limits<float>::epsilon() * 100), m_margin(0.0),\n 2843          m_scale(1.0), m_value(value) {}\n ....\n 2852  \n 2853    template <typename T, typename = typename std::enable_if<\n 2854:                             std::is_constructible<double, T>::value>::type>\n 2855    Approx operator()(T value) {\n 2856:     Approx approx(static_cast<double>(value));\n 2857      approx.epsilon(m_epsilon);\n 2858      approx.margin(m_margin);\n ....\n 2862  \n 2863    template <typename T, typename = typename std::enable_if<\n 2864:                             std::is_constructible<double, T>::value>::type>\n 2865:   explicit Approx(T value) : Approx(static_cast<double>(value)) {}\n 2866  \n 2867    template <typename T, typename = typename std::enable_if<\n 2868:                             std::is_constructible<double, T>::value>::type>\n 2869    friend bool operator==(const T &lhs, Approx const &rhs) {\n 2870      // Thanks to Richard Harris for his help refining this formula\n 2871:     auto lhs_v = double(lhs);\n 2872      bool relativeOK =\n 2873          std::fabs(lhs_v - rhs.m_value) <\n ....\n 2881  \n 2882    template <typename T, typename = typename std::enable_if<\n 2883:                             std::is_constructible<double, T>::value>::type>\n 2884    friend bool operator==(Approx const &lhs, const T &rhs) {\n 2885      return operator==(rhs, lhs);\n ....\n 2887  \n 2888    template <typename T, typename = typename std::enable_if<\n 2889:                             std::is_constructible<double, T>::value>::type>\n 2890    friend bool operator!=(T lhs, Approx const &rhs) {\n 2891      return !operator==(lhs, rhs);\n ....\n 2893  \n 2894    template <typename T, typename = typename std::enable_if<\n 2895:                             std::is_constructible<double, T>::value>::type>\n 2896    friend bool operator!=(Approx const &lhs, T rhs) {\n 2897      return !operator==(rhs, lhs);\n ....\n 2899  \n 2900    template <typename T, typename = typename std::enable_if<\n 2901:                             std::is_constructible<double, T>::value>::type>\n 2902    friend bool operator<=(T lhs, Approx const &rhs) {\n 2903:     return double(lhs) < rhs.m_value || lhs == rhs;\n 2904    }\n 2905  \n 2906    template <typename T, typename = typename std::enable_if<\n 2907:                             std::is_constructible<double, T>::value>::type>\n 2908    friend bool operator<=(Approx const &lhs, T rhs) {\n 2909:     return lhs.m_value < double(rhs) || lhs == rhs;\n 2910    }\n 2911  \n 2912    template <typename T, typename = typename std::enable_if<\n 2913:                             std::is_constructible<double, T>::value>::type>\n 2914    friend bool operator>=(T lhs, Approx const &rhs) {\n 2915:     return double(lhs) > rhs.m_value || lhs == rhs;\n 2916    }\n 2917  \n 2918    template <typename T, typename = typename std::enable_if<\n 2919:                             std::is_constructible<double, T>::value>::type>\n 2920    friend bool operator>=(Approx const &lhs, T rhs) {\n 2921:     return lhs.m_value > double(rhs) || lhs == rhs;\n 2922    }\n 2923  \n 2924    template <typename T, typename = typename std::enable_if<\n 2925:                             std::is_constructible<double, T>::value>::type>\n 2926    Approx &epsilon(T newEpsilon) {\n 2927:     m_epsilon = double(newEpsilon);\n 2928      return *this;\n 2929    }\n 2930  \n 2931    template <typename T, typename = typename std::enable_if<\n 2932:                             std::is_constructible<double, T>::value>::type>\n 2933    Approx &margin(T newMargin) {\n 2934:     m_margin = double(newMargin);\n 2935      return *this;\n 2936    }\n 2937  \n 2938    template <typename T, typename = typename std::enable_if<\n 2939:                             std::is_constructible<double, T>::value>::type>\n 2940    Approx &scale(T newScale) {\n 2941:     m_scale = double(newScale);\n 2942      return *this;\n 2943    }\n ....\n 2945  #else\n 2946  \n 2947:   Approx operator()(double value) {\n 2948      Approx approx(value);\n 2949      approx.epsilon(m_epsilon);\n ....\n 2953    }\n 2954  \n 2955:   friend bool operator==(double lhs, Approx const &rhs) {\n 2956      // Thanks to Richard Harris for his help refining this formula\n 2957      bool relativeOK =\n ....\n 2965    }\n 2966  \n 2967:   friend bool operator==(Approx const &lhs, double rhs) {\n 2968      return operator==(rhs, lhs);\n 2969    }\n 2970  \n 2971:   friend bool operator!=(double lhs, Approx const &rhs) {\n 2972      return !operator==(lhs, rhs);\n 2973    }\n 2974  \n 2975:   friend bool operator!=(Approx const &lhs, double rhs) {\n 2976      return !operator==(rhs, lhs);\n 2977    }\n 2978  \n 2979:   friend bool operator<=(double lhs, Approx const &rhs) {\n 2980      return lhs < rhs.m_value || lhs == rhs;\n 2981    }\n 2982  \n 2983:   friend bool operator<=(Approx const &lhs, double rhs) {\n 2984      return lhs.m_value < rhs || lhs == rhs;\n 2985    }\n 2986  \n 2987:   friend bool operator>=(double lhs, Approx const &rhs) {\n 2988      return lhs > rhs.m_value || lhs == rhs;\n 2989    }\n 2990  \n 2991:   friend bool operator>=(Approx const &lhs, double rhs) {\n 2992      return lhs.m_value > rhs || lhs == rhs;\n 2993    }\n 2994  \n 2995:   Approx &epsilon(double newEpsilon) {\n 2996      m_epsilon = newEpsilon;\n 2997      return *this;\n 2998    }\n 2999  \n 3000:   Approx &margin(double newMargin) {\n 3001      m_margin = newMargin;\n 3002      return *this;\n 3003    }\n 3004  \n 3005:   Approx &scale(double newScale) {\n 3006      m_scale = newScale;\n 3007      return *this;\n ....\n 3016  \n 3017  private:\n 3018:   double m_epsilon;\n 3019:   double m_margin;\n 3020:   double m_scale;\n 3021:   double m_value;\n 3022  };\n 3023  }\n ....\n 3272  \n 3273      // These are here to force alignment for the storage\n 3274:     long double dummy1;\n 3275      void (*dummy2)();\n 3276:     long double dummy3;\n 3277  #ifdef CATCH_CONFIG_CPP11_LONG_LONG\n 3278      long long dummy4;\n ....\n 4740    void parseIntoTokens(std::vector<std::string> const &args,\n 4741                         std::vector<Token> &tokens) {\n 4742:     const std::string doubleDash = \"--\";\n 4743:     for (std::size_t i = 1; i < args.size() && args[i] != doubleDash; ++i)\n 4744        parseIntoTokens(args[i], tokens);\n 4745    }\n ....\n 5818  struct SectionStats {\n 5819    SectionStats(SectionInfo const &_sectionInfo, Counts const &_assertions,\n 5820:                double _durationInSeconds, bool _missingAssertions)\n 5821        : sectionInfo(_sectionInfo), assertions(_assertions),\n 5822          durationInSeconds(_durationInSeconds),\n ....\n 5832    SectionInfo sectionInfo;\n 5833    Counts assertions;\n 5834:   double durationInSeconds;\n 5835    bool missingAssertions;\n 5836  };\n ....\n 6947      m_reporter->sectionStarting(testCaseSection);\n 6948      Counts prevAssertions = m_totals.assertions;\n 6949:     double duration = 0;\n 6950      m_shouldReportUnexpected = true;\n 6951      try {\n ....\n 8667    return static_cast<unsigned int>(getElapsedMicroseconds() / 1000);\n 8668  }\n 8669: double Timer::getElapsedSeconds() const {\n 8670    return getElapsedMicroseconds() / 1000000.0;\n 8671  }\n ....\n 9063  }\n 9064  \n 9065: std::string toString(const double value) { return fpToString(value, 10); }\n 9066  std::string toString(const float value) { return fpToString(value, 5) + 'f'; }\n 9067  \n ....\n 9585  // Because formatting using c++ streams is stateful, drop down to C is required\n 9586  // Alternatively we could use stringstream, but its performance is... not good.\n 9587: std::string getFormattedDuration(double duration) {\n 9588    // Max exponent + 1 is required to represent the whole part\n 9589    // + 1 for decimal point\n 9590    // + 3 for the 3 decimal places\n 9591    // + 1 for null terminator\n 9592:   const size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;\n 9593:   char buffer[maxDoubleSize];\n 9594  \n 9595    // Save previous errno, to prevent sprintf from overwriting it\n ....\n 10465    virtual void\n 10466    testGroupEnded(TestGroupStats const &testGroupStats) CATCH_OVERRIDE {\n 10467:     double suiteTime = suiteTimer.getElapsedSeconds();\n 10468      CumulativeReporterBase::testGroupEnded(testGroupStats);\n 10469      writeGroup(*m_testGroups.back(), suiteTime);\n .....\n 10472    virtual void testRunEndedCumulative() CATCH_OVERRIDE { xml.endElement(); }\n 10473  \n 10474:   void writeGroup(TestGroupNode const &groupNode, double suiteTime) {\n 10475      XmlWriter::ScopedElement e = xml.scopedElement(\"testsuite\");\n 10476      TestGroupStats const &stats = groupNode.value;\n\n/home/jchiu/projects/mpsft/src/bazel-src/_bin/client:\n    <binary>\n\n/home/jchiu/projects/mpsft/src/bazel-src/external/bazel_tools/tools/build_defs/docker/BUILD:\n   27      \"generated_tarball\",\n   28      \"with_env\",\n   29:     \"with_double_env\",\n   30      \"with_label\",\n   31:     \"with_double_label\",\n   32      \"with_user\",\n   33      \"workdir_with_tar_base\",\n\n/home/jchiu/projects/mpsft/src/bazel-src/external/bazel_tools/tools/build_defs/docker/build_test.sh:\n  384  }\n  385  \n  386: function test_with_double_env() {\n  387:   check_layers \"with_double_env\" \\\n  388      \"125e7cfb9d4a6d803a57b88bcdb05d9a6a47ac0d6312a8b4cff52a2685c5c858\" \\\n  389      \"42a1bd0f449f61a23b8a7776875ffb6707b34ee99c87d6428a7394f5e55e8624\" \\\n  ...\n  391  \n  392    # Check both the aggregation and the expansion of embedded variables.\n  393:   check_env \"with_double_env\" \\\n  394      \"576a9fd9c690be04dc7aacbb9dbd1f14816e32dbbcc510f4d42325bbff7163dd\" \\\n  395      '[\"bar=blah blah blah\", \"baz=/asdf blah blah blah\", \"foo=/asdf\"]'\n  ...\n  406  }\n  407  \n  408: function test_with_double_label() {\n  409:   check_layers \"with_double_label\" \\\n  410      \"125e7cfb9d4a6d803a57b88bcdb05d9a6a47ac0d6312a8b4cff52a2685c5c858\" \\\n  411      \"eba6abda3d259ab6ed5f4d48b76df72a5193fad894d4ae78fbf0a363d8f9e8fd\" \\\n  412      \"bfe88fbb5e24fc5bff138f7a1923d53a2ee1bbc8e54b6f5d9c371d5f48b6b023\" \\\n  413  \n  414:   check_label \"with_double_label\" \\\n  415      \"bfe88fbb5e24fc5bff138f7a1923d53a2ee1bbc8e54b6f5d9c371d5f48b6b023\" \\\n  416      '[\"com.example.bar={\\\"name\\\": \\\"blah\\\"}\", \"com.example.baz=qux\", \"com.example.foo={\\\"name\\\": \\\"blah\\\"}\", \"com.example.qux={\\\"name\\\": \\\"blah-blah\\\"}\"]'\n  ...\n  514  \n  515    check_manifest_property \"RepoTags\" \"bundle_test\" \\\n  516:     \"[\\\"bazel/${TEST_DATA_TARGET_BASE}:with_double_env\\\", \\\"gcr.io/google-containers/pause:2.0\\\"]\"\n  517  }\n  518  \n\n/home/jchiu/projects/mpsft/src/bazel-src/external/bazel_tools/tools/build_defs/docker/build_test_oci.sh:\n  380  }\n  381  \n  382: function test_with_double_env() {\n  383:   check_layers \"with_double_env\" \\\n  384      \"125e7cfb9d4a6d803a57b88bcdb05d9a6a47ac0d6312a8b4cff52a2685c5c858\" \\\n  385      \"42a1bd0f449f61a23b8a7776875ffb6707b34ee99c87d6428a7394f5e55e8624\" \\\n  ...\n  387  \n  388    # Check both the aggregation and the expansion of embedded variables.\n  389:   check_env \"with_double_env\" \\\n  390      \"273d2a6cfc25001baf9d3f7c68770ec79a1671b8249d153e7611a4f80165ecda\" \\\n  391      '[\"bar=blah blah blah\", \"baz=/asdf blah blah blah\", \"foo=/asdf\"]'\n  ...\n  402  }\n  403  \n  404: function test_with_double_label() {\n  405:   check_layers \"with_double_label\" \\\n  406      \"125e7cfb9d4a6d803a57b88bcdb05d9a6a47ac0d6312a8b4cff52a2685c5c858\" \\\n  407      \"eba6abda3d259ab6ed5f4d48b76df72a5193fad894d4ae78fbf0a363d8f9e8fd\" \\\n  408      \"bfe88fbb5e24fc5bff138f7a1923d53a2ee1bbc8e54b6f5d9c371d5f48b6b023\"\n  409  \n  410:   check_label \"with_double_label\" \\\n  411      \"8cfc89c83adf947cd2c18c11579559f1f48cf375a20364ec79eb14d6580dbf75\" \\\n  412      '[\"com.example.bar={\\\"name\\\": \\\"blah\\\"}\", \"com.example.baz=qux\", \"com.example.foo={\\\"name\\\": \\\"blah\\\"}\", \"com.example.qux={\\\"name\\\": \\\"blah-blah\\\"}\"]'\n\n/home/jchiu/projects/mpsft/src/bazel-src/external/bazel_tools/tools/build_defs/docker/testdata/BUILD:\n  188  \n  189  docker_build(\n  190:     name = \"with_double_env\",\n  191      base = \":with_env\",\n  192      env = {\n  ...\n  206  \n  207  docker_build(\n  208:     name = \"with_double_label\",\n  209      base = \":with_label\",\n  210      labels = {\n  ...\n  334  \n  335  docker_build(\n  336:     name = \"notop_with_double_env\",\n  337      base = \":notop_with_env\",\n  338      env = {\n  ...\n  352  \n  353  docker_build(\n  354:     name = \"notop_with_double_label\",\n  355      base = \":notop_with_label\",\n  356      labels = {\n  ...\n  384          \"docker.io/ubuntu:latest\": \":base_with_entrypoint\",\n  385          \"us.gcr.io/google-appengine/base:fresh\": \":link_with_files_base\",\n  386:         \"gcr.io/google-containers/pause:2.0\": \":with_double_env\",\n  387      },\n  388  )\n\n/home/jchiu/projects/mpsft/src/bazel-src/external/bazel_tools/tools/jdk/ijar/ijar:\n    <binary>\n\n/home/jchiu/projects/mpsft/src/catch.h:\n 1561  std::string toString( unsigned long value );\n 1562  std::string toString( unsigned int value );\n 1563: std::string toString( const double value );\n 1564  std::string toString( const float value );\n 1565  std::string toString( bool value );\n ....\n 2171          INTERNAL_CATCH_REACT( __catchResult ) \\\n 2172      } while( Catch::isTrue( false && static_cast<bool>( !!(expr) ) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look\n 2173: // The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.\n 2174  \n 2175  #define INTERNAL_CHECK_THAT_NO_TRY( macroName, matcher, resultDisposition, arg ) \\\n ....\n 2207          INTERNAL_CATCH_REACT( __catchResult ) \\\n 2208      } while( Catch::isTrue( false && static_cast<bool>( !!(expr) ) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look\n 2209:     // The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.\n 2210  \n 2211  ///////////////////////////////////////////////////////////////////////////////\n ....\n 2397  \n 2398      struct SectionEndInfo {\n 2399:         SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds )\n 2400          : sectionInfo( _sectionInfo ), prevAssertions( _prevAssertions ), durationInSeconds( _durationInSeconds )\n 2401          {}\n ....\n 2403          SectionInfo sectionInfo;\n 2404          Counts prevAssertions;\n 2405:         double durationInSeconds;\n 2406      };\n 2407  \n ....\n 2430          unsigned int getElapsedMicroseconds() const;\n 2431          unsigned int getElapsedMilliseconds() const;\n 2432:         double getElapsedSeconds() const;\n 2433  \n 2434      private:\n ....\n 2770      class Approx {\n 2771      public:\n 2772:         explicit Approx ( double value )\n 2773          :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),\n 2774              m_margin( 0.0 ),\n ....\n 2790  #if defined(CATCH_CONFIG_CPP11_TYPE_TRAITS)\n 2791  \n 2792:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2793          Approx operator()( T value ) {\n 2794:             Approx approx( static_cast<double>(value) );\n 2795              approx.epsilon( m_epsilon );\n 2796              approx.margin( m_margin );\n ....\n 2799          }\n 2800  \n 2801:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2802:         explicit Approx( T value ): Approx(static_cast<double>(value))\n 2803          {}\n 2804  \n 2805:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2806          friend bool operator == ( const T& lhs, Approx const& rhs ) {\n 2807              // Thanks to Richard Harris for his help refining this formula\n 2808:             auto lhs_v = double(lhs);\n 2809              bool relativeOK = std::fabs(lhs_v - rhs.m_value) < rhs.m_epsilon * (rhs.m_scale + (std::max)(std::fabs(lhs_v), std::fabs(rhs.m_value)));\n 2810              if (relativeOK) {\n ....\n 2814          }\n 2815  \n 2816:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2817          friend bool operator == ( Approx const& lhs, const T& rhs ) {\n 2818              return operator==( rhs, lhs );\n 2819          }\n 2820  \n 2821:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2822          friend bool operator != ( T lhs, Approx const& rhs ) {\n 2823              return !operator==( lhs, rhs );\n 2824          }\n 2825  \n 2826:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2827          friend bool operator != ( Approx const& lhs, T rhs ) {\n 2828              return !operator==( rhs, lhs );\n 2829          }\n 2830  \n 2831:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2832          friend bool operator <= ( T lhs, Approx const& rhs ) {\n 2833:             return double(lhs) < rhs.m_value || lhs == rhs;\n 2834          }\n 2835  \n 2836:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2837          friend bool operator <= ( Approx const& lhs, T rhs ) {\n 2838:             return lhs.m_value < double(rhs) || lhs == rhs;\n 2839          }\n 2840  \n 2841:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2842          friend bool operator >= ( T lhs, Approx const& rhs ) {\n 2843:             return double(lhs) > rhs.m_value || lhs == rhs;\n 2844          }\n 2845  \n 2846:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2847          friend bool operator >= ( Approx const& lhs, T rhs ) {\n 2848:             return lhs.m_value > double(rhs) || lhs == rhs;\n 2849          }\n 2850  \n 2851:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2852          Approx& epsilon( T newEpsilon ) {\n 2853:             m_epsilon = double(newEpsilon);\n 2854              return *this;\n 2855          }\n 2856  \n 2857:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2858          Approx& margin( T newMargin ) {\n 2859:             m_margin = double(newMargin);\n 2860              return *this;\n 2861          }\n 2862  \n 2863:         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n 2864          Approx& scale( T newScale ) {\n 2865:             m_scale = double(newScale);\n 2866              return *this;\n 2867          }\n ....\n 2869  #else\n 2870  \n 2871:         Approx operator()( double value ) {\n 2872              Approx approx( value );\n 2873              approx.epsilon( m_epsilon );\n ....\n 2877          }\n 2878  \n 2879:         friend bool operator == ( double lhs, Approx const& rhs ) {\n 2880              // Thanks to Richard Harris for his help refining this formula\n 2881              bool relativeOK = std::fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( std::fabs(lhs), std::fabs(rhs.m_value) ) );\n ....\n 2886          }\n 2887  \n 2888:         friend bool operator == ( Approx const& lhs, double rhs ) {\n 2889              return operator==( rhs, lhs );\n 2890          }\n 2891  \n 2892:         friend bool operator != ( double lhs, Approx const& rhs ) {\n 2893              return !operator==( lhs, rhs );\n 2894          }\n 2895  \n 2896:         friend bool operator != ( Approx const& lhs, double rhs ) {\n 2897              return !operator==( rhs, lhs );\n 2898          }\n 2899  \n 2900:         friend bool operator <= ( double lhs, Approx const& rhs ) {\n 2901              return lhs < rhs.m_value || lhs == rhs;\n 2902          }\n 2903  \n 2904:         friend bool operator <= ( Approx const& lhs, double rhs ) {\n 2905              return lhs.m_value < rhs || lhs == rhs;\n 2906          }\n 2907  \n 2908:         friend bool operator >= ( double lhs, Approx const& rhs ) {\n 2909              return lhs > rhs.m_value || lhs == rhs;\n 2910          }\n 2911  \n 2912:         friend bool operator >= ( Approx const& lhs, double rhs ) {\n 2913              return lhs.m_value > rhs || lhs == rhs;\n 2914          }\n 2915  \n 2916:         Approx& epsilon( double newEpsilon ) {\n 2917              m_epsilon = newEpsilon;\n 2918              return *this;\n 2919          }\n 2920  \n 2921:         Approx& margin( double newMargin ) {\n 2922              m_margin = newMargin;\n 2923              return *this;\n 2924          }\n 2925  \n 2926:         Approx& scale( double newScale ) {\n 2927              m_scale = newScale;\n 2928              return *this;\n ....\n 2937  \n 2938      private:\n 2939:         double m_epsilon;\n 2940:         double m_margin;\n 2941:         double m_scale;\n 2942:         double m_value;\n 2943      };\n 2944  }\n ....\n 3186  \n 3187              // These are here to force alignment for the storage\n 3188:             long double dummy1;\n 3189              void (*dummy2)();\n 3190:             long double dummy3;\n 3191  #ifdef CATCH_CONFIG_CPP11_LONG_LONG\n 3192              long long dummy4;\n ....\n 4604  \n 4605          void parseIntoTokens( std::vector<std::string> const& args, std::vector<Token>& tokens ) {\n 4606:             const std::string doubleDash = \"--\";\n 4607:             for( std::size_t i = 1; i < args.size() && args[i] != doubleDash; ++i )\n 4608                  parseIntoTokens( args[i], tokens);\n 4609          }\n ....\n 5647          SectionStats(   SectionInfo const& _sectionInfo,\n 5648                          Counts const& _assertions,\n 5649:                         double _durationInSeconds,\n 5650                          bool _missingAssertions )\n 5651          :   sectionInfo( _sectionInfo ),\n ....\n 5664          SectionInfo sectionInfo;\n 5665          Counts assertions;\n 5666:         double durationInSeconds;\n 5667          bool missingAssertions;\n 5668      };\n ....\n 6800              m_reporter->sectionStarting( testCaseSection );\n 6801              Counts prevAssertions = m_totals.assertions;\n 6802:             double duration = 0;\n 6803              m_shouldReportUnexpected = true;\n 6804              try {\n ....\n 8557          return static_cast<unsigned int>(getElapsedMicroseconds()/1000);\n 8558      }\n 8559:     double Timer::getElapsedSeconds() const {\n 8560          return getElapsedMicroseconds()/1000000.0;\n 8561      }\n ....\n 8962  }\n 8963  \n 8964: std::string toString( const double value ) {\n 8965      return fpToString( value, 10 );\n 8966  }\n ....\n 9483          // Because formatting using c++ streams is stateful, drop down to C is required\n 9484          // Alternatively we could use stringstream, but its performance is... not good.\n 9485:         std::string getFormattedDuration( double duration ) {\n 9486              // Max exponent + 1 is required to represent the whole part\n 9487              // + 1 for decimal point\n 9488              // + 3 for the 3 decimal places\n 9489              // + 1 for null terminator\n 9490:             const size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;\n 9491:             char buffer[maxDoubleSize];\n 9492  \n 9493              // Save previous errno, to prevent sprintf from overwriting it\n ....\n 10362  \n 10363          virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {\n 10364:             double suiteTime = suiteTimer.getElapsedSeconds();\n 10365              CumulativeReporterBase::testGroupEnded( testGroupStats );\n 10366              writeGroup( *m_testGroups.back(), suiteTime );\n .....\n 10371          }\n 10372  \n 10373:         void writeGroup( TestGroupNode const& groupNode, double suiteTime ) {\n 10374              XmlWriter::ScopedElement e = xml.scopedElement( \"testsuite\" );\n 10375              TestGroupStats const& stats = groupNode.value;\n\n262 matches across 11 files\n",
			"settings":
			{
				"buffer_size": 36032,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "src/base.h",
			"settings":
			{
				"buffer_size": 323,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/base.cc",
			"settings":
			{
				"buffer_size": 185,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/perm.h",
			"settings":
			{
				"buffer_size": 723,
				"line_ending": "Unix",
				"name": "p"
			}
		},
		{
			"file": "src/perm.cc",
			"settings":
			{
				"buffer_size": 657,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/perm_test.cc",
			"settings":
			{
				"buffer_size": 433,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/*\n *  Catch v1.9.6\n *  Generated: 2017-06-27 12:19:54.557875\n *  ----------------------------------------------------------\n *  This file has been merged from multiple headers. Please don't edit it directly\n *  Copyright (c) 2012 Two Blue Cubes Ltd. All rights reserved.\n *\n *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n */\n#ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED\n#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED\n\n#define TWOBLUECUBES_CATCH_HPP_INCLUDED\n\n#ifdef __clang__\n#    pragma clang system_header\n#elif defined __GNUC__\n#    pragma GCC system_header\n#endif\n\n// #included from: internal/catch_suppress_warnings.h\n\n#ifdef __clang__\n#   ifdef __ICC // icpc defines the __clang__ macro\n#       pragma warning(push)\n#       pragma warning(disable: 161 1682)\n#   else // __ICC\n#       pragma clang diagnostic ignored \"-Wglobal-constructors\"\n#       pragma clang diagnostic ignored \"-Wvariadic-macros\"\n#       pragma clang diagnostic ignored \"-Wc99-extensions\"\n#       pragma clang diagnostic ignored \"-Wunused-variable\"\n#       pragma clang diagnostic push\n#       pragma clang diagnostic ignored \"-Wpadded\"\n#       pragma clang diagnostic ignored \"-Wc++98-compat\"\n#       pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n#       pragma clang diagnostic ignored \"-Wswitch-enum\"\n#       pragma clang diagnostic ignored \"-Wcovered-switch-default\"\n#    endif\n#elif defined __GNUC__\n#    pragma GCC diagnostic ignored \"-Wvariadic-macros\"\n#    pragma GCC diagnostic ignored \"-Wunused-variable\"\n#    pragma GCC diagnostic ignored \"-Wparentheses\"\n\n#    pragma GCC diagnostic push\n#    pragma GCC diagnostic ignored \"-Wpadded\"\n#endif\n#if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)\n#  define CATCH_IMPL\n#endif\n\n#ifdef CATCH_IMPL\n#  ifndef CLARA_CONFIG_MAIN\n#    define CLARA_CONFIG_MAIN_NOT_DEFINED\n#    define CLARA_CONFIG_MAIN\n#  endif\n#endif\n\n// #included from: internal/catch_notimplemented_exception.h\n#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED\n\n// #included from: catch_common.h\n#define TWOBLUECUBES_CATCH_COMMON_H_INCLUDED\n\n// #included from: catch_compiler_capabilities.h\n#define TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED\n\n// Detect a number of compiler features - mostly C++11/14 conformance - by compiler\n// The following features are defined:\n//\n// CATCH_CONFIG_CPP11_NULLPTR : is nullptr supported?\n// CATCH_CONFIG_CPP11_NOEXCEPT : is noexcept supported?\n// CATCH_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods\n// CATCH_CONFIG_CPP11_IS_ENUM : std::is_enum is supported?\n// CATCH_CONFIG_CPP11_TUPLE : std::tuple is supported\n// CATCH_CONFIG_CPP11_LONG_LONG : is long long supported?\n// CATCH_CONFIG_CPP11_OVERRIDE : is override supported?\n// CATCH_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)\n// CATCH_CONFIG_CPP11_SHUFFLE : is std::shuffle supported?\n// CATCH_CONFIG_CPP11_TYPE_TRAITS : are type_traits and enable_if supported?\n\n// CATCH_CONFIG_CPP11_OR_GREATER : Is C++11 supported?\n\n// CATCH_CONFIG_VARIADIC_MACROS : are variadic macros supported?\n// CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?\n// CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?\n// CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?\n// ****************\n// Note to maintainers: if new toggles are added please document them\n// in configuration.md, too\n// ****************\n\n// In general each macro has a _NO_<feature name> form\n// (e.g. CATCH_CONFIG_CPP11_NO_NULLPTR) which disables the feature.\n// Many features, at point of detection, define an _INTERNAL_ macro, so they\n// can be combined, en-mass, with the _NO_ forms later.\n\n// All the C++11 features can be disabled with CATCH_CONFIG_NO_CPP11\n\n#ifdef __cplusplus\n\n#  if __cplusplus >= 201103L\n#    define CATCH_CPP11_OR_GREATER\n#  endif\n\n#  if __cplusplus >= 201402L\n#    define CATCH_CPP14_OR_GREATER\n#  endif\n\n#endif\n\n#ifdef __clang__\n\n#  if __has_feature(cxx_nullptr)\n#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR\n#  endif\n\n#  if __has_feature(cxx_noexcept)\n#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT\n#  endif\n\n#   if defined(CATCH_CPP11_OR_GREATER)\n#       define CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \\\n            _Pragma( \"clang diagnostic push\" ) \\\n            _Pragma( \"clang diagnostic ignored \\\"-Wexit-time-destructors\\\"\" )\n#       define CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS \\\n            _Pragma( \"clang diagnostic pop\" )\n\n#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\\n            _Pragma( \"clang diagnostic push\" ) \\\n            _Pragma( \"clang diagnostic ignored \\\"-Wparentheses\\\"\" )\n#       define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \\\n            _Pragma( \"clang diagnostic pop\" )\n#   endif\n\n#endif // __clang__\n\n////////////////////////////////////////////////////////////////////////////////\n// We know some environments not to support full POSIX signals\n#if defined(__CYGWIN__) || defined(__QNX__)\n\n#   if !defined(CATCH_CONFIG_POSIX_SIGNALS)\n#       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS\n#   endif\n\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n// Cygwin\n#ifdef __CYGWIN__\n\n// Required for some versions of Cygwin to declare gettimeofday\n// see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin\n#   define _BSD_SOURCE\n\n#endif // __CYGWIN__\n\n////////////////////////////////////////////////////////////////////////////////\n// Borland\n#ifdef __BORLANDC__\n\n#endif // __BORLANDC__\n\n////////////////////////////////////////////////////////////////////////////////\n// EDG\n#ifdef __EDG_VERSION__\n\n#endif // __EDG_VERSION__\n\n////////////////////////////////////////////////////////////////////////////////\n// Digital Mars\n#ifdef __DMC__\n\n#endif // __DMC__\n\n////////////////////////////////////////////////////////////////////////////////\n// GCC\n#ifdef __GNUC__\n\n#   if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)\n#       define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR\n#   endif\n\n// - otherwise more recent versions define __cplusplus >= 201103L\n// and will get picked up below\n\n#endif // __GNUC__\n\n////////////////////////////////////////////////////////////////////////////////\n// Visual C++\n#ifdef _MSC_VER\n\n#define CATCH_INTERNAL_CONFIG_WINDOWS_SEH\n\n#if (_MSC_VER >= 1600)\n#   define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR\n#   define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR\n#endif\n\n#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))\n#define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT\n#define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS\n#define CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE\n#define CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS\n#endif\n\n#endif // _MSC_VER\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Use variadic macros if the compiler supports them\n#if ( defined _MSC_VER && _MSC_VER > 1400 && !defined __EDGE__) || \\\n    ( defined __WAVE__ && __WAVE_HAS_VARIADICS ) || \\\n    ( defined __GNUC__ && __GNUC__ >= 3 ) || \\\n    ( !defined __cplusplus && __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L )\n\n#define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS\n\n#endif\n\n// Use __COUNTER__ if the compiler supports it\n#if ( defined _MSC_VER && _MSC_VER >= 1300 ) || \\\n    ( defined __GNUC__  && ( __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3 )) ) || \\\n    ( defined __clang__ && __clang_major__ >= 3 )\n\n#define CATCH_INTERNAL_CONFIG_COUNTER\n\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\n// C++ language feature support\n\n// catch all support for C++11\n#if defined(CATCH_CPP11_OR_GREATER)\n\n#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR)\n#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR\n#  endif\n\n#  ifndef CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT\n#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT\n#  endif\n\n#  ifndef CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS\n#    define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS\n#  endif\n\n#  ifndef CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM\n#    define CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM\n#  endif\n\n#  ifndef CATCH_INTERNAL_CONFIG_CPP11_TUPLE\n#    define CATCH_INTERNAL_CONFIG_CPP11_TUPLE\n#  endif\n\n#  ifndef CATCH_INTERNAL_CONFIG_VARIADIC_MACROS\n#    define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS\n#  endif\n\n#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG)\n#    define CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG\n#  endif\n\n#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE)\n#    define CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE\n#  endif\n#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)\n#    define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR\n#  endif\n# if !defined(CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE)\n#   define CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE\n#  endif\n# if !defined(CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS)\n#  define CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS\n# endif\n\n#endif // __cplusplus >= 201103L\n\n// Now set the actual defines based on the above + anything the user has configured\n#if defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NO_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_NO_CPP11)\n#   define CATCH_CONFIG_CPP11_NULLPTR\n#endif\n#if defined(CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_NO_CPP11)\n#   define CATCH_CONFIG_CPP11_NOEXCEPT\n#endif\n#if defined(CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_NO_CPP11)\n#   define CATCH_CONFIG_CPP11_GENERATED_METHODS\n#endif\n#if defined(CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_NO_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_NO_CPP11)\n#   define CATCH_CONFIG_CPP11_IS_ENUM\n#endif\n#if defined(CATCH_INTERNAL_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_CPP11_NO_TUPLE) && !defined(CATCH_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_NO_CPP11)\n#   define CATCH_CONFIG_CPP11_TUPLE\n#endif\n#if defined(CATCH_INTERNAL_CONFIG_VARIADIC_MACROS) && !defined(CATCH_CONFIG_NO_VARIADIC_MACROS) && !defined(CATCH_CONFIG_VARIADIC_MACROS)\n#   define CATCH_CONFIG_VARIADIC_MACROS\n#endif\n#if defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_NO_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_NO_CPP11)\n#   define CATCH_CONFIG_CPP11_LONG_LONG\n#endif\n#if defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_NO_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_NO_CPP11)\n#   define CATCH_CONFIG_CPP11_OVERRIDE\n#endif\n#if defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_NO_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_NO_CPP11)\n#   define CATCH_CONFIG_CPP11_UNIQUE_PTR\n#endif\n// Use of __COUNTER__ is suppressed if __JETBRAINS_IDE__ is #defined (meaning we're being parsed by a JetBrains IDE for\n// analytics) because, at time of writing, __COUNTER__ is not properly handled by it.\n// This does not affect compilation\n#if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER) && !defined(__JETBRAINS_IDE__)\n#   define CATCH_CONFIG_COUNTER\n#endif\n#if defined(CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE) && !defined(CATCH_CONFIG_CPP11_NO_SHUFFLE) && !defined(CATCH_CONFIG_CPP11_SHUFFLE) && !defined(CATCH_CONFIG_NO_CPP11)\n#   define CATCH_CONFIG_CPP11_SHUFFLE\n#endif\n# if defined(CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS) && !defined(CATCH_CONFIG_CPP11_NO_TYPE_TRAITS) && !defined(CATCH_CONFIG_CPP11_TYPE_TRAITS) && !defined(CATCH_CONFIG_NO_CPP11)\n#  define CATCH_CONFIG_CPP11_TYPE_TRAITS\n# endif\n#if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH)\n#   define CATCH_CONFIG_WINDOWS_SEH\n#endif\n// This is set by default, because we assume that unix compilers are posix-signal-compatible by default.\n#if !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)\n#   define CATCH_CONFIG_POSIX_SIGNALS\n#endif\n\n#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)\n#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS\n#   define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS\n#endif\n#if !defined(CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS)\n#   define CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS\n#   define CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS\n#endif\n\n// noexcept support:\n#if defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_NOEXCEPT)\n#  define CATCH_NOEXCEPT noexcept\n#  define CATCH_NOEXCEPT_IS(x) noexcept(x)\n#else\n#  define CATCH_NOEXCEPT throw()\n#  define CATCH_NOEXCEPT_IS(x)\n#endif\n\n// nullptr support\n#ifdef CATCH_CONFIG_CPP11_NULLPTR\n#   define CATCH_NULL nullptr\n#else\n#   define CATCH_NULL NULL\n#endif\n\n// override support\n#ifdef CATCH_CONFIG_CPP11_OVERRIDE\n#   define CATCH_OVERRIDE override\n#else\n#   define CATCH_OVERRIDE\n#endif\n\n// unique_ptr support\n#ifdef CATCH_CONFIG_CPP11_UNIQUE_PTR\n#   define CATCH_AUTO_PTR( T ) std::unique_ptr<T>\n#else\n#   define CATCH_AUTO_PTR( T ) std::auto_ptr<T>\n#endif\n\n#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line\n#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )\n#ifdef CATCH_CONFIG_COUNTER\n#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )\n#else\n#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )\n#endif\n\n#define INTERNAL_CATCH_STRINGIFY2( expr ) #expr\n#define INTERNAL_CATCH_STRINGIFY( expr ) INTERNAL_CATCH_STRINGIFY2( expr )\n\n#include <sstream>\n#include <algorithm>\n\nnamespace Catch {\n\n    struct IConfig;\n\n    struct CaseSensitive { enum Choice {\n        Yes,\n        No\n    }; };\n\n    class NonCopyable {\n#ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS\n        NonCopyable( NonCopyable const& )              = delete;\n        NonCopyable( NonCopyable && )                  = delete;\n        NonCopyable& operator = ( NonCopyable const& ) = delete;\n        NonCopyable& operator = ( NonCopyable && )     = delete;\n#else\n        NonCopyable( NonCopyable const& info );\n        NonCopyable& operator = ( NonCopyable const& );\n#endif\n\n    protected:\n        NonCopyable() {}\n        virtual ~NonCopyable();\n    };\n\n    class SafeBool {\n    public:\n        typedef void (SafeBool::*type)() const;\n\n        static type makeSafe( bool value ) {\n            return value ? &SafeBool::trueValue : 0;\n        }\n    private:\n        void trueValue() const {}\n    };\n\n    template<typename ContainerT>\n    inline void deleteAll( ContainerT& container ) {\n        typename ContainerT::const_iterator it = container.begin();\n        typename ContainerT::const_iterator itEnd = container.end();\n        for(; it != itEnd; ++it )\n            delete *it;\n    }\n    template<typename AssociativeContainerT>\n    inline void deleteAllValues( AssociativeContainerT& container ) {\n        typename AssociativeContainerT::const_iterator it = container.begin();\n        typename AssociativeContainerT::const_iterator itEnd = container.end();\n        for(; it != itEnd; ++it )\n            delete it->second;\n    }\n\n    bool startsWith( std::string const& s, std::string const& prefix );\n    bool startsWith( std::string const& s, char prefix );\n    bool endsWith( std::string const& s, std::string const& suffix );\n    bool endsWith( std::string const& s, char suffix );\n    bool contains( std::string const& s, std::string const& infix );\n    void toLowerInPlace( std::string& s );\n    std::string toLower( std::string const& s );\n    std::string trim( std::string const& str );\n    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );\n\n    struct pluralise {\n        pluralise( std::size_t count, std::string const& label );\n\n        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );\n\n        std::size_t m_count;\n        std::string m_label;\n    };\n\n    struct SourceLineInfo {\n\n        SourceLineInfo();\n        SourceLineInfo( char const* _file, std::size_t _line );\n#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS\n        SourceLineInfo(SourceLineInfo const& other)          = default;\n        SourceLineInfo( SourceLineInfo && )                  = default;\n        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;\n        SourceLineInfo& operator = ( SourceLineInfo && )     = default;\n#  endif\n        bool empty() const;\n        bool operator == ( SourceLineInfo const& other ) const;\n        bool operator < ( SourceLineInfo const& other ) const;\n\n        char const* file;\n        std::size_t line;\n    };\n\n    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );\n\n    // This is just here to avoid compiler warnings with macro constants and boolean literals\n    inline bool isTrue( bool value ){ return value; }\n    inline bool alwaysTrue() { return true; }\n    inline bool alwaysFalse() { return false; }\n\n    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo );\n\n    void seedRng( IConfig const& config );\n    unsigned int rngSeed();\n\n    // Use this in variadic streaming macros to allow\n    //    >> +StreamEndStop\n    // as well as\n    //    >> stuff +StreamEndStop\n    struct StreamEndStop {\n        std::string operator+() {\n            return std::string();\n        }\n    };\n    template<typename T>\n    T const& operator + ( T const& value, StreamEndStop ) {\n        return value;\n    }\n}\n\n#define CATCH_INTERNAL_LINEINFO ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )\n#define CATCH_INTERNAL_ERROR( msg ) ::Catch::throwLogicError( msg, CATCH_INTERNAL_LINEINFO );\n\nnamespace Catch {\n\n    class NotImplementedException : public std::exception\n    {\n    public:\n        NotImplementedException( SourceLineInfo const& lineInfo );\n        NotImplementedException( NotImplementedException const& ) {}\n\n        virtual ~NotImplementedException() CATCH_NOEXCEPT {}\n\n        virtual const char* what() const CATCH_NOEXCEPT;\n\n    private:\n        std::string m_what;\n        SourceLineInfo m_lineInfo;\n    };\n\n} // end namespace Catch\n\n///////////////////////////////////////////////////////////////////////////////\n#define CATCH_NOT_IMPLEMENTED throw Catch::NotImplementedException( CATCH_INTERNAL_LINEINFO )\n\n// #included from: internal/catch_context.h\n#define TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED\n\n// #included from: catch_interfaces_generators.h\n#define TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED\n\n#include <string>\n\nnamespace Catch {\n\n    struct IGeneratorInfo {\n        virtual ~IGeneratorInfo();\n        virtual bool moveNext() = 0;\n        virtual std::size_t getCurrentIndex() const = 0;\n    };\n\n    struct IGeneratorsForTest {\n        virtual ~IGeneratorsForTest();\n\n        virtual IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) = 0;\n        virtual bool moveNext() = 0;\n    };\n\n    IGeneratorsForTest* createGeneratorsForTest();\n\n} // end namespace Catch\n\n// #included from: catch_ptr.hpp\n#define TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\nnamespace Catch {\n\n    // An intrusive reference counting smart pointer.\n    // T must implement addRef() and release() methods\n    // typically implementing the IShared interface\n    template<typename T>\n    class Ptr {\n    public:\n        Ptr() : m_p( CATCH_NULL ){}\n        Ptr( T* p ) : m_p( p ){\n            if( m_p )\n                m_p->addRef();\n        }\n        Ptr( Ptr const& other ) : m_p( other.m_p ){\n            if( m_p )\n                m_p->addRef();\n        }\n        ~Ptr(){\n            if( m_p )\n                m_p->release();\n        }\n        void reset() {\n            if( m_p )\n                m_p->release();\n            m_p = CATCH_NULL;\n        }\n        Ptr& operator = ( T* p ){\n            Ptr temp( p );\n            swap( temp );\n            return *this;\n        }\n        Ptr& operator = ( Ptr const& other ){\n            Ptr temp( other );\n            swap( temp );\n            return *this;\n        }\n        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }\n        T* get() const{ return m_p; }\n        T& operator*() const { return *m_p; }\n        T* operator->() const { return m_p; }\n        bool operator !() const { return m_p == CATCH_NULL; }\n        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != CATCH_NULL ); }\n\n    private:\n        T* m_p;\n    };\n\n    struct IShared : NonCopyable {\n        virtual ~IShared();\n        virtual void addRef() const = 0;\n        virtual void release() const = 0;\n    };\n\n    template<typename T = IShared>\n    struct SharedImpl : T {\n\n        SharedImpl() : m_rc( 0 ){}\n\n        virtual void addRef() const {\n            ++m_rc;\n        }\n        virtual void release() const {\n            if( --m_rc == 0 )\n                delete this;\n        }\n\n        mutable unsigned int m_rc;\n    };\n\n} // end namespace Catch\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\nnamespace Catch {\n\n    class TestCase;\n    class Stream;\n    struct IResultCapture;\n    struct IRunner;\n    struct IGeneratorsForTest;\n    struct IConfig;\n\n    struct IContext\n    {\n        virtual ~IContext();\n\n        virtual IResultCapture* getResultCapture() = 0;\n        virtual IRunner* getRunner() = 0;\n        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) = 0;\n        virtual bool advanceGeneratorsForCurrentTest() = 0;\n        virtual Ptr<IConfig const> getConfig() const = 0;\n    };\n\n    struct IMutableContext : IContext\n    {\n        virtual ~IMutableContext();\n        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;\n        virtual void setRunner( IRunner* runner ) = 0;\n        virtual void setConfig( Ptr<IConfig const> const& config ) = 0;\n    };\n\n    IContext& getCurrentContext();\n    IMutableContext& getCurrentMutableContext();\n    void cleanUpContext();\n    Stream createStream( std::string const& streamName );\n\n}\n\n// #included from: internal/catch_test_registry.hpp\n#define TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\n\n// #included from: catch_interfaces_testcase.h\n#define TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED\n\n#include <vector>\n\nnamespace Catch {\n\n    class TestSpec;\n\n    struct ITestCase : IShared {\n        virtual void invoke () const = 0;\n    protected:\n        virtual ~ITestCase();\n    };\n\n    class TestCase;\n    struct IConfig;\n\n    struct ITestCaseRegistry {\n        virtual ~ITestCaseRegistry();\n        virtual std::vector<TestCase> const& getAllTests() const = 0;\n        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;\n    };\n\n    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );\n    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );\n    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );\n\n}\n\nnamespace Catch {\n\ntemplate<typename C>\nclass MethodTestCase : public SharedImpl<ITestCase> {\n\npublic:\n    MethodTestCase( void (C::*method)() ) : m_method( method ) {}\n\n    virtual void invoke() const {\n        C obj;\n        (obj.*m_method)();\n    }\n\nprivate:\n    virtual ~MethodTestCase() {}\n\n    void (C::*m_method)();\n};\n\ntypedef void(*TestFunction)();\n\nstruct NameAndDesc {\n    NameAndDesc( const char* _name = \"\", const char* _description= \"\" )\n    : name( _name ), description( _description )\n    {}\n\n    const char* name;\n    const char* description;\n};\n\nvoid registerTestCase\n    (   ITestCase* testCase,\n        char const* className,\n        NameAndDesc const& nameAndDesc,\n        SourceLineInfo const& lineInfo );\n\nstruct AutoReg {\n\n    AutoReg\n        (   TestFunction function,\n            SourceLineInfo const& lineInfo,\n            NameAndDesc const& nameAndDesc );\n\n    template<typename C>\n    AutoReg\n        (   void (C::*method)(),\n            char const* className,\n            NameAndDesc const& nameAndDesc,\n            SourceLineInfo const& lineInfo ) {\n\n        registerTestCase\n            (   new MethodTestCase<C>( method ),\n                className,\n                nameAndDesc,\n                lineInfo );\n    }\n\n    ~AutoReg();\n\nprivate:\n    AutoReg( AutoReg const& );\n    void operator= ( AutoReg const& );\n};\n\nvoid registerTestCaseFunction\n    (   TestFunction function,\n        SourceLineInfo const& lineInfo,\n        NameAndDesc const& nameAndDesc );\n\n} // end namespace Catch\n\n#ifdef CATCH_CONFIG_VARIADIC_MACROS\n    ///////////////////////////////////////////////////////////////////////////////\n    #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \\\n        static void TestName(); \\\n        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \\\n        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &TestName, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) ); } \\\n        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS \\\n        static void TestName()\n    #define INTERNAL_CATCH_TESTCASE( ... ) \\\n        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )\n\n    ///////////////////////////////////////////////////////////////////////////////\n    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \\\n        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \\\n        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, \"&\" #QualifiedMethod, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); } \\\n        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS\n\n    ///////////////////////////////////////////////////////////////////////////////\n    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\\\n        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \\\n        namespace{ \\\n            struct TestName : ClassName{ \\\n                void test(); \\\n            }; \\\n            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &TestName::test, #ClassName, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); \\\n        } \\\n        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS \\\n        void TestName::test()\n    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \\\n        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )\n\n    ///////////////////////////////////////////////////////////////////////////////\n    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \\\n        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \\\n        Catch::AutoReg( Function, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) ); \\\n        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS\n\n#else\n    ///////////////////////////////////////////////////////////////////////////////\n    #define INTERNAL_CATCH_TESTCASE2( TestName, Name, Desc ) \\\n        static void TestName(); \\\n        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \\\n        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &TestName, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) ); }\\\n        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS \\\n        static void TestName()\n    #define INTERNAL_CATCH_TESTCASE( Name, Desc ) \\\n        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), Name, Desc )\n\n    ///////////////////////////////////////////////////////////////////////////////\n    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, Name, Desc ) \\\n        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \\\n        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, \"&\" #QualifiedMethod, Catch::NameAndDesc( Name, Desc ), CATCH_INTERNAL_LINEINFO ); } \\\n        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS\n\n    ///////////////////////////////////////////////////////////////////////////////\n    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestCaseName, ClassName, TestName, Desc )\\\n        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \\\n        namespace{ \\\n            struct TestCaseName : ClassName{ \\\n                void test(); \\\n            }; \\\n            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &TestCaseName::test, #ClassName, Catch::NameAndDesc( TestName, Desc ), CATCH_INTERNAL_LINEINFO ); \\\n        } \\\n        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS \\\n        void TestCaseName::test()\n    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, TestName, Desc )\\\n        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, TestName, Desc )\n\n    ///////////////////////////////////////////////////////////////////////////////\n    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, Name, Desc ) \\\n        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \\\n        Catch::AutoReg( Function, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) ); \\\n        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS\n\n#endif\n\n// #included from: internal/catch_capture.hpp\n#define TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED\n\n// #included from: catch_result_builder.h\n#define TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED\n\n// #included from: catch_result_type.h\n#define TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED\n\nnamespace Catch {\n\n    // ResultWas::OfType enum\n    struct ResultWas { enum OfType {\n        Unknown = -1,\n        Ok = 0,\n        Info = 1,\n        Warning = 2,\n\n        FailureBit = 0x10,\n\n        ExpressionFailed = FailureBit | 1,\n        ExplicitFailure = FailureBit | 2,\n\n        Exception = 0x100 | FailureBit,\n\n        ThrewException = Exception | 1,\n        DidntThrowException = Exception | 2,\n\n        FatalErrorCondition = 0x200 | FailureBit\n\n    }; };\n\n    inline bool isOk( ResultWas::OfType resultType ) {\n        return ( resultType & ResultWas::FailureBit ) == 0;\n    }\n    inline bool isJustInfo( int flags ) {\n        return flags == ResultWas::Info;\n    }\n\n    // ResultDisposition::Flags enum\n    struct ResultDisposition { enum Flags {\n        Normal = 0x01,\n\n        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues\n        FalseTest = 0x04,           // Prefix expression with !\n        SuppressFail = 0x08         // Failures are reported but do not fail the test\n    }; };\n\n    inline ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {\n        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );\n    }\n\n    inline bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }\n    inline bool isFalseTest( int flags )                { return ( flags & ResultDisposition::FalseTest ) != 0; }\n    inline bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }\n\n} // end namespace Catch\n\n// #included from: catch_assertionresult.h\n#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED\n\n#include <string>\n\nnamespace Catch {\n\n    struct STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison;\n\n    struct DecomposedExpression\n    {\n        virtual ~DecomposedExpression() {}\n        virtual bool isBinaryExpression() const {\n            return false;\n        }\n        virtual void reconstructExpression( std::string& dest ) const = 0;\n\n        // Only simple binary comparisons can be decomposed.\n        // If more complex check is required then wrap sub-expressions in parentheses.\n        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator + ( T const& );\n        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator - ( T const& );\n        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator * ( T const& );\n        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator / ( T const& );\n        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator % ( T const& );\n        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( T const& );\n        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( T const& );\n\n    private:\n        DecomposedExpression& operator = (DecomposedExpression const&);\n    };\n\n    struct AssertionInfo\n    {\n        AssertionInfo() {}\n        AssertionInfo(  char const * _macroName,\n                        SourceLineInfo const& _lineInfo,\n                        char const * _capturedExpression,\n                        ResultDisposition::Flags _resultDisposition,\n                        char const * _secondArg = \"\");\n\n        char const * macroName;\n        SourceLineInfo lineInfo;\n        char const * capturedExpression;\n        ResultDisposition::Flags resultDisposition;\n        char const * secondArg;\n    };\n\n    struct AssertionResultData\n    {\n        AssertionResultData() : decomposedExpression( CATCH_NULL )\n                              , resultType( ResultWas::Unknown )\n                              , negated( false )\n                              , parenthesized( false ) {}\n\n        void negate( bool parenthesize ) {\n            negated = !negated;\n            parenthesized = parenthesize;\n            if( resultType == ResultWas::Ok )\n                resultType = ResultWas::ExpressionFailed;\n            else if( resultType == ResultWas::ExpressionFailed )\n                resultType = ResultWas::Ok;\n        }\n\n        std::string const& reconstructExpression() const {\n            if( decomposedExpression != CATCH_NULL ) {\n                decomposedExpression->reconstructExpression( reconstructedExpression );\n                if( parenthesized ) {\n                    reconstructedExpression.insert( 0, 1, '(' );\n                    reconstructedExpression.append( 1, ')' );\n                }\n                if( negated ) {\n                    reconstructedExpression.insert( 0, 1, '!' );\n                }\n                decomposedExpression = CATCH_NULL;\n            }\n            return reconstructedExpression;\n        }\n\n        mutable DecomposedExpression const* decomposedExpression;\n        mutable std::string reconstructedExpression;\n        std::string message;\n        ResultWas::OfType resultType;\n        bool negated;\n        bool parenthesized;\n    };\n\n    class AssertionResult {\n    public:\n        AssertionResult();\n        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );\n        ~AssertionResult();\n#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS\n         AssertionResult( AssertionResult const& )              = default;\n         AssertionResult( AssertionResult && )                  = default;\n         AssertionResult& operator = ( AssertionResult const& ) = default;\n         AssertionResult& operator = ( AssertionResult && )     = default;\n#  endif\n\n        bool isOk() const;\n        bool succeeded() const;\n        ResultWas::OfType getResultType() const;\n        bool hasExpression() const;\n        bool hasMessage() const;\n        std::string getExpression() const;\n        std::string getExpressionInMacro() const;\n        bool hasExpandedExpression() const;\n        std::string getExpandedExpression() const;\n        std::string getMessage() const;\n        SourceLineInfo getSourceInfo() const;\n        std::string getTestMacroName() const;\n        void discardDecomposedExpression() const;\n        void expandDecomposedExpression() const;\n\n    protected:\n        AssertionInfo m_info;\n        AssertionResultData m_resultData;\n    };\n\n} // end namespace Catch\n\n// #included from: catch_matchers.hpp\n#define TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED\n\nnamespace Catch {\nnamespace Matchers {\n    namespace Impl {\n\n        template<typename ArgT> struct MatchAllOf;\n        template<typename ArgT> struct MatchAnyOf;\n        template<typename ArgT> struct MatchNotOf;\n\n        class MatcherUntypedBase {\n        public:\n            std::string toString() const {\n                if( m_cachedToString.empty() )\n                    m_cachedToString = describe();\n                return m_cachedToString;\n            }\n\n        protected:\n            virtual ~MatcherUntypedBase();\n            virtual std::string describe() const = 0;\n            mutable std::string m_cachedToString;\n        private:\n            MatcherUntypedBase& operator = ( MatcherUntypedBase const& );\n        };\n\n        template<typename ObjectT>\n        struct MatcherMethod {\n            virtual bool match( ObjectT const& arg ) const = 0;\n        };\n        template<typename PtrT>\n        struct MatcherMethod<PtrT*> {\n            virtual bool match( PtrT* arg ) const = 0;\n        };\n\n        template<typename ObjectT, typename ComparatorT = ObjectT>\n        struct MatcherBase : MatcherUntypedBase, MatcherMethod<ObjectT> {\n\n            MatchAllOf<ComparatorT> operator && ( MatcherBase const& other ) const;\n            MatchAnyOf<ComparatorT> operator || ( MatcherBase const& other ) const;\n            MatchNotOf<ComparatorT> operator ! () const;\n        };\n\n        template<typename ArgT>\n        struct MatchAllOf : MatcherBase<ArgT> {\n            virtual bool match( ArgT const& arg ) const CATCH_OVERRIDE {\n                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {\n                    if (!m_matchers[i]->match(arg))\n                        return false;\n                }\n                return true;\n            }\n            virtual std::string describe() const CATCH_OVERRIDE {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {\n                    if( i != 0 )\n                        description += \" and \";\n                    description += m_matchers[i]->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n\n            MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n\n            std::vector<MatcherBase<ArgT> const*> m_matchers;\n        };\n        template<typename ArgT>\n        struct MatchAnyOf : MatcherBase<ArgT> {\n\n            virtual bool match( ArgT const& arg ) const CATCH_OVERRIDE {\n                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {\n                    if (m_matchers[i]->match(arg))\n                        return true;\n                }\n                return false;\n            }\n            virtual std::string describe() const CATCH_OVERRIDE {\n                std::string description;\n                description.reserve( 4 + m_matchers.size()*32 );\n                description += \"( \";\n                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {\n                    if( i != 0 )\n                        description += \" or \";\n                    description += m_matchers[i]->toString();\n                }\n                description += \" )\";\n                return description;\n            }\n\n            MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> const& other ) {\n                m_matchers.push_back( &other );\n                return *this;\n            }\n\n            std::vector<MatcherBase<ArgT> const*> m_matchers;\n        };\n\n        template<typename ArgT>\n        struct MatchNotOf : MatcherBase<ArgT> {\n\n            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}\n\n            virtual bool match( ArgT const& arg ) const CATCH_OVERRIDE {\n                return !m_underlyingMatcher.match( arg );\n            }\n\n            virtual std::string describe() const CATCH_OVERRIDE {\n                return \"not \" + m_underlyingMatcher.toString();\n            }\n            MatcherBase<ArgT> const& m_underlyingMatcher;\n        };\n\n        template<typename ObjectT, typename ComparatorT>\n        MatchAllOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator && ( MatcherBase const& other ) const {\n            return MatchAllOf<ComparatorT>() && *this && other;\n        }\n        template<typename ObjectT, typename ComparatorT>\n        MatchAnyOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator || ( MatcherBase const& other ) const {\n            return MatchAnyOf<ComparatorT>() || *this || other;\n        }\n        template<typename ObjectT, typename ComparatorT>\n        MatchNotOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator ! () const {\n            return MatchNotOf<ComparatorT>( *this );\n        }\n\n    } // namespace Impl\n\n    // The following functions create the actual matcher objects.\n    // This allows the types to be inferred\n    // - deprecated: prefer ||, && and !\n    template<typename T>\n    inline Impl::MatchNotOf<T> Not( Impl::MatcherBase<T> const& underlyingMatcher ) {\n        return Impl::MatchNotOf<T>( underlyingMatcher );\n    }\n    template<typename T>\n    inline Impl::MatchAllOf<T> AllOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2 ) {\n        return Impl::MatchAllOf<T>() && m1 && m2;\n    }\n    template<typename T>\n    inline Impl::MatchAllOf<T> AllOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2, Impl::MatcherBase<T> const& m3 ) {\n        return Impl::MatchAllOf<T>() && m1 && m2 && m3;\n    }\n    template<typename T>\n    inline Impl::MatchAnyOf<T> AnyOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2 ) {\n        return Impl::MatchAnyOf<T>() || m1 || m2;\n    }\n    template<typename T>\n    inline Impl::MatchAnyOf<T> AnyOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2, Impl::MatcherBase<T> const& m3 ) {\n        return Impl::MatchAnyOf<T>() || m1 || m2 || m3;\n    }\n\n} // namespace Matchers\n\nusing namespace Matchers;\nusing Matchers::Impl::MatcherBase;\n\n} // namespace Catch\n\nnamespace Catch {\n\n    struct TestFailureException{};\n\n    template<typename T> class ExpressionLhs;\n\n    struct CopyableStream {\n        CopyableStream() {}\n        CopyableStream( CopyableStream const& other ) {\n            oss << other.oss.str();\n        }\n        CopyableStream& operator=( CopyableStream const& other ) {\n            oss.str(std::string());\n            oss << other.oss.str();\n            return *this;\n        }\n        std::ostringstream oss;\n    };\n\n    class ResultBuilder : public DecomposedExpression {\n    public:\n        ResultBuilder(  char const* macroName,\n                        SourceLineInfo const& lineInfo,\n                        char const* capturedExpression,\n                        ResultDisposition::Flags resultDisposition,\n                        char const* secondArg = \"\" );\n        ~ResultBuilder();\n\n        template<typename T>\n        ExpressionLhs<T const&> operator <= ( T const& operand );\n        ExpressionLhs<bool> operator <= ( bool value );\n\n        template<typename T>\n        ResultBuilder& operator << ( T const& value ) {\n            m_stream().oss << value;\n            return *this;\n        }\n\n        ResultBuilder& setResultType( ResultWas::OfType result );\n        ResultBuilder& setResultType( bool result );\n\n        void endExpression( DecomposedExpression const& expr );\n\n        virtual void reconstructExpression( std::string& dest ) const CATCH_OVERRIDE;\n\n        AssertionResult build() const;\n        AssertionResult build( DecomposedExpression const& expr ) const;\n\n        void useActiveException( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal );\n        void captureResult( ResultWas::OfType resultType );\n        void captureExpression();\n        void captureExpectedException( std::string const& expectedMessage );\n        void captureExpectedException( Matchers::Impl::MatcherBase<std::string> const& matcher );\n        void handleResult( AssertionResult const& result );\n        void react();\n        bool shouldDebugBreak() const;\n        bool allowThrows() const;\n\n        template<typename ArgT, typename MatcherT>\n        void captureMatch( ArgT const& arg, MatcherT const& matcher, char const* matcherString );\n\n        void setExceptionGuard();\n        void unsetExceptionGuard();\n\n    private:\n        AssertionInfo m_assertionInfo;\n        AssertionResultData m_data;\n\n        static CopyableStream &m_stream()\n        {\n            static CopyableStream s;\n            return s;\n        }\n\n        bool m_shouldDebugBreak;\n        bool m_shouldThrow;\n        bool m_guardException;\n    };\n\n} // namespace Catch\n\n// Include after due to circular dependency:\n// #included from: catch_expression_lhs.hpp\n#define TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED\n\n// #included from: catch_evaluate.hpp\n#define TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable:4389) // '==' : signed/unsigned mismatch\n#pragma warning(disable:4312) // Converting int to T* using reinterpret_cast (issue on x64 platform)\n#endif\n\n#include <cstddef>\n\nnamespace Catch {\nnamespace Internal {\n\n    enum Operator {\n        IsEqualTo,\n        IsNotEqualTo,\n        IsLessThan,\n        IsGreaterThan,\n        IsLessThanOrEqualTo,\n        IsGreaterThanOrEqualTo\n    };\n\n    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return \"*error*\"; } };\n    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return \"==\"; } };\n    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return \"!=\"; } };\n    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return \"<\"; } };\n    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return \">\"; } };\n    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return \"<=\"; } };\n    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return \">=\"; } };\n\n    template<typename T>\n    inline T& opCast(T const& t) { return const_cast<T&>(t); }\n\n// nullptr_t support based on pull request #154 from Konstantin Baumann\n#ifdef CATCH_CONFIG_CPP11_NULLPTR\n    inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }\n#endif // CATCH_CONFIG_CPP11_NULLPTR\n\n    // So the compare overloads can be operator agnostic we convey the operator as a template\n    // enum, which is used to specialise an Evaluator for doing the comparison.\n    template<typename T1, typename T2, Operator Op>\n    class Evaluator{};\n\n    template<typename T1, typename T2>\n    struct Evaluator<T1, T2, IsEqualTo> {\n        static bool evaluate( T1 const& lhs, T2 const& rhs) {\n            return bool( opCast( lhs ) ==  opCast( rhs ) );\n        }\n    };\n    template<typename T1, typename T2>\n    struct Evaluator<T1, T2, IsNotEqualTo> {\n        static bool evaluate( T1 const& lhs, T2 const& rhs ) {\n            return bool( opCast( lhs ) != opCast( rhs ) );\n        }\n    };\n    template<typename T1, typename T2>\n    struct Evaluator<T1, T2, IsLessThan> {\n        static bool evaluate( T1 const& lhs, T2 const& rhs ) {\n            return bool( opCast( lhs ) < opCast( rhs ) );\n        }\n    };\n    template<typename T1, typename T2>\n    struct Evaluator<T1, T2, IsGreaterThan> {\n        static bool evaluate( T1 const& lhs, T2 const& rhs ) {\n            return bool( opCast( lhs ) > opCast( rhs ) );\n        }\n    };\n    template<typename T1, typename T2>\n    struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {\n        static bool evaluate( T1 const& lhs, T2 const& rhs ) {\n            return bool( opCast( lhs ) >= opCast( rhs ) );\n        }\n    };\n    template<typename T1, typename T2>\n    struct Evaluator<T1, T2, IsLessThanOrEqualTo> {\n        static bool evaluate( T1 const& lhs, T2 const& rhs ) {\n            return bool( opCast( lhs ) <= opCast( rhs ) );\n        }\n    };\n\n    template<Operator Op, typename T1, typename T2>\n    bool applyEvaluator( T1 const& lhs, T2 const& rhs ) {\n        return Evaluator<T1, T2, Op>::evaluate( lhs, rhs );\n    }\n\n    // This level of indirection allows us to specialise for integer types\n    // to avoid signed/ unsigned warnings\n\n    // \"base\" overload\n    template<Operator Op, typename T1, typename T2>\n    bool compare( T1 const& lhs, T2 const& rhs ) {\n        return Evaluator<T1, T2, Op>::evaluate( lhs, rhs );\n    }\n\n    // unsigned X to int\n    template<Operator Op> bool compare( unsigned int lhs, int rhs ) {\n        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );\n    }\n    template<Operator Op> bool compare( unsigned long lhs, int rhs ) {\n        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );\n    }\n    template<Operator Op> bool compare( unsigned char lhs, int rhs ) {\n        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );\n    }\n\n    // unsigned X to long\n    template<Operator Op> bool compare( unsigned int lhs, long rhs ) {\n        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );\n    }\n    template<Operator Op> bool compare( unsigned long lhs, long rhs ) {\n        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );\n    }\n    template<Operator Op> bool compare( unsigned char lhs, long rhs ) {\n        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );\n    }\n\n    // int to unsigned X\n    template<Operator Op> bool compare( int lhs, unsigned int rhs ) {\n        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );\n    }\n    template<Operator Op> bool compare( int lhs, unsigned long rhs ) {\n        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );\n    }\n    template<Operator Op> bool compare( int lhs, unsigned char rhs ) {\n        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );\n    }\n\n    // long to unsigned X\n    template<Operator Op> bool compare( long lhs, unsigned int rhs ) {\n        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );\n    }\n    template<Operator Op> bool compare( long lhs, unsigned long rhs ) {\n        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );\n    }\n    template<Operator Op> bool compare( long lhs, unsigned char rhs ) {\n        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );\n    }\n\n    // pointer to long (when comparing against NULL)\n    template<Operator Op, typename T> bool compare( long lhs, T* rhs ) {\n        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );\n    }\n    template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {\n        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );\n    }\n\n    // pointer to int (when comparing against NULL)\n    template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {\n        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );\n    }\n    template<Operator Op, typename T> bool compare( T* lhs, int rhs ) {\n        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );\n    }\n\n#ifdef CATCH_CONFIG_CPP11_LONG_LONG\n    // long long to unsigned X\n    template<Operator Op> bool compare( long long lhs, unsigned int rhs ) {\n        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );\n    }\n    template<Operator Op> bool compare( long long lhs, unsigned long rhs ) {\n        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );\n    }\n    template<Operator Op> bool compare( long long lhs, unsigned long long rhs ) {\n        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );\n    }\n    template<Operator Op> bool compare( long long lhs, unsigned char rhs ) {\n        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );\n    }\n\n    // unsigned long long to X\n    template<Operator Op> bool compare( unsigned long long lhs, int rhs ) {\n        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );\n    }\n    template<Operator Op> bool compare( unsigned long long lhs, long rhs ) {\n        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );\n    }\n    template<Operator Op> bool compare( unsigned long long lhs, long long rhs ) {\n        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );\n    }\n    template<Operator Op> bool compare( unsigned long long lhs, char rhs ) {\n        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );\n    }\n\n    // pointer to long long (when comparing against NULL)\n    template<Operator Op, typename T> bool compare( long long lhs, T* rhs ) {\n        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );\n    }\n    template<Operator Op, typename T> bool compare( T* lhs, long long rhs ) {\n        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );\n    }\n#endif // CATCH_CONFIG_CPP11_LONG_LONG\n\n#ifdef CATCH_CONFIG_CPP11_NULLPTR\n    // pointer to nullptr_t (when comparing against nullptr)\n    template<Operator Op, typename T> bool compare( std::nullptr_t, T* rhs ) {\n        return Evaluator<T*, T*, Op>::evaluate( nullptr, rhs );\n    }\n    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t ) {\n        return Evaluator<T*, T*, Op>::evaluate( lhs, nullptr );\n    }\n#endif // CATCH_CONFIG_CPP11_NULLPTR\n\n} // end of namespace Internal\n} // end of namespace Catch\n\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\n// #included from: catch_tostring.h\n#define TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED\n\n#include <sstream>\n#include <iomanip>\n#include <limits>\n#include <vector>\n#include <cstddef>\n\n#ifdef __OBJC__\n// #included from: catch_objc_arc.hpp\n#define TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED\n\n#import <Foundation/Foundation.h>\n\n#ifdef __has_feature\n#define CATCH_ARC_ENABLED __has_feature(objc_arc)\n#else\n#define CATCH_ARC_ENABLED 0\n#endif\n\nvoid arcSafeRelease( NSObject* obj );\nid performOptionalSelector( id obj, SEL sel );\n\n#if !CATCH_ARC_ENABLED\ninline void arcSafeRelease( NSObject* obj ) {\n    [obj release];\n}\ninline id performOptionalSelector( id obj, SEL sel ) {\n    if( [obj respondsToSelector: sel] )\n        return [obj performSelector: sel];\n    return nil;\n}\n#define CATCH_UNSAFE_UNRETAINED\n#define CATCH_ARC_STRONG\n#else\ninline void arcSafeRelease( NSObject* ){}\ninline id performOptionalSelector( id obj, SEL sel ) {\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n#endif\n    if( [obj respondsToSelector: sel] )\n        return [obj performSelector: sel];\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n    return nil;\n}\n#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained\n#define CATCH_ARC_STRONG __strong\n#endif\n\n#endif\n\n#ifdef CATCH_CONFIG_CPP11_TUPLE\n#include <tuple>\n#endif\n\n#ifdef CATCH_CONFIG_CPP11_IS_ENUM\n#include <type_traits>\n#endif\n\nnamespace Catch {\n\n// Why we're here.\ntemplate<typename T>\nstd::string toString( T const& value );\n\n// Built in overloads\n\nstd::string toString( std::string const& value );\nstd::string toString( std::wstring const& value );\nstd::string toString( const char* const value );\nstd::string toString( char* const value );\nstd::string toString( const wchar_t* const value );\nstd::string toString( wchar_t* const value );\nstd::string toString( int value );\nstd::string toString( unsigned long value );\nstd::string toString( unsigned int value );\nstd::string toString( const double value );\nstd::string toString( const float value );\nstd::string toString( bool value );\nstd::string toString( char value );\nstd::string toString( signed char value );\nstd::string toString( unsigned char value );\n\n#ifdef CATCH_CONFIG_CPP11_LONG_LONG\nstd::string toString( long long value );\nstd::string toString( unsigned long long value );\n#endif\n\n#ifdef CATCH_CONFIG_CPP11_NULLPTR\nstd::string toString( std::nullptr_t );\n#endif\n\n#ifdef __OBJC__\n    std::string toString( NSString const * const& nsstring );\n    std::string toString( NSString * CATCH_ARC_STRONG & nsstring );\n    std::string toString( NSObject* const& nsObject );\n#endif\n\nnamespace Detail {\n\n    extern const std::string unprintableString;\n\n #if !defined(CATCH_CONFIG_CPP11_STREAM_INSERTABLE_CHECK)\n    struct BorgType {\n        template<typename T> BorgType( T const& );\n    };\n\n    struct TrueType { char sizer[1]; };\n    struct FalseType { char sizer[2]; };\n\n    TrueType& testStreamable( std::ostream& );\n    FalseType testStreamable( FalseType );\n\n    FalseType operator<<( std::ostream const&, BorgType const& );\n\n    template<typename T>\n    struct IsStreamInsertable {\n        static std::ostream &s;\n        static T  const&t;\n        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };\n    };\n#else\n    template<typename T>\n    class IsStreamInsertable {\n        template<typename SS, typename TT>\n        static auto test(int)\n        -> decltype( std::declval<SS&>() << std::declval<TT>(), std::true_type() );\n\n        template<typename, typename>\n        static auto test(...) -> std::false_type;\n\n    public:\n        static const bool value = decltype(test<std::ostream,const T&>(0))::value;\n    };\n#endif\n\n#if defined(CATCH_CONFIG_CPP11_IS_ENUM)\n    template<typename T,\n             bool IsEnum = std::is_enum<T>::value\n             >\n    struct EnumStringMaker\n    {\n        static std::string convert( T const& ) { return unprintableString; }\n    };\n\n    template<typename T>\n    struct EnumStringMaker<T,true>\n    {\n        static std::string convert( T const& v )\n        {\n            return ::Catch::toString(\n                static_cast<typename std::underlying_type<T>::type>(v)\n                );\n        }\n    };\n#endif\n    template<bool C>\n    struct StringMakerBase {\n#if defined(CATCH_CONFIG_CPP11_IS_ENUM)\n        template<typename T>\n        static std::string convert( T const& v )\n        {\n            return EnumStringMaker<T>::convert( v );\n        }\n#else\n        template<typename T>\n        static std::string convert( T const& ) { return unprintableString; }\n#endif\n    };\n\n    template<>\n    struct StringMakerBase<true> {\n        template<typename T>\n        static std::string convert( T const& _value ) {\n            std::ostringstream oss;\n            oss << _value;\n            return oss.str();\n        }\n    };\n\n    std::string rawMemoryToString( const void *object, std::size_t size );\n\n    template<typename T>\n    inline std::string rawMemoryToString( const T& object ) {\n      return rawMemoryToString( &object, sizeof(object) );\n    }\n\n} // end namespace Detail\n\ntemplate<typename T>\nstruct StringMaker :\n    Detail::StringMakerBase<Detail::IsStreamInsertable<T>::value> {};\n\ntemplate<typename T>\nstruct StringMaker<T*> {\n    template<typename U>\n    static std::string convert( U* p ) {\n        if( !p )\n            return \"NULL\";\n        else\n            return Detail::rawMemoryToString( p );\n    }\n};\n\ntemplate<typename R, typename C>\nstruct StringMaker<R C::*> {\n    static std::string convert( R C::* p ) {\n        if( !p )\n            return \"NULL\";\n        else\n            return Detail::rawMemoryToString( p );\n    }\n};\n\nnamespace Detail {\n    template<typename InputIterator>\n    std::string rangeToString( InputIterator first, InputIterator last );\n}\n\n//template<typename T, typename Allocator>\n//struct StringMaker<std::vector<T, Allocator> > {\n//    static std::string convert( std::vector<T,Allocator> const& v ) {\n//        return Detail::rangeToString( v.begin(), v.end() );\n//    }\n//};\n\ntemplate<typename T, typename Allocator>\nstd::string toString( std::vector<T,Allocator> const& v ) {\n    return Detail::rangeToString( v.begin(), v.end() );\n}\n\n#ifdef CATCH_CONFIG_CPP11_TUPLE\n\n// toString for tuples\nnamespace TupleDetail {\n  template<\n      typename Tuple,\n      std::size_t N = 0,\n      bool = (N < std::tuple_size<Tuple>::value)\n      >\n  struct ElementPrinter {\n      static void print( const Tuple& tuple, std::ostream& os )\n      {\n          os << ( N ? \", \" : \" \" )\n             << Catch::toString(std::get<N>(tuple));\n          ElementPrinter<Tuple,N+1>::print(tuple,os);\n      }\n  };\n\n  template<\n      typename Tuple,\n      std::size_t N\n      >\n  struct ElementPrinter<Tuple,N,false> {\n      static void print( const Tuple&, std::ostream& ) {}\n  };\n\n}\n\ntemplate<typename ...Types>\nstruct StringMaker<std::tuple<Types...>> {\n\n    static std::string convert( const std::tuple<Types...>& tuple )\n    {\n        std::ostringstream os;\n        os << '{';\n        TupleDetail::ElementPrinter<std::tuple<Types...>>::print( tuple, os );\n        os << \" }\";\n        return os.str();\n    }\n};\n#endif // CATCH_CONFIG_CPP11_TUPLE\n\nnamespace Detail {\n    template<typename T>\n    std::string makeString( T const& value ) {\n        return StringMaker<T>::convert( value );\n    }\n} // end namespace Detail\n\n/// \\brief converts any type to a string\n///\n/// The default template forwards on to ostringstream - except when an\n/// ostringstream overload does not exist - in which case it attempts to detect\n/// that and writes {?}.\n/// Overload (not specialise) this template for custom typs that you don't want\n/// to provide an ostream overload for.\ntemplate<typename T>\nstd::string toString( T const& value ) {\n    return StringMaker<T>::convert( value );\n}\n\n    namespace Detail {\n    template<typename InputIterator>\n    std::string rangeToString( InputIterator first, InputIterator last ) {\n        std::ostringstream oss;\n        oss << \"{ \";\n        if( first != last ) {\n            oss << Catch::toString( *first );\n            for( ++first ; first != last ; ++first )\n                oss << \", \" << Catch::toString( *first );\n        }\n        oss << \" }\";\n        return oss.str();\n    }\n}\n\n} // end namespace Catch\n\nnamespace Catch {\n\ntemplate<typename LhsT, Internal::Operator Op, typename RhsT>\nclass BinaryExpression;\n\ntemplate<typename ArgT, typename MatcherT>\nclass MatchExpression;\n\n// Wraps the LHS of an expression and overloads comparison operators\n// for also capturing those and RHS (if any)\ntemplate<typename T>\nclass ExpressionLhs : public DecomposedExpression {\npublic:\n    ExpressionLhs( ResultBuilder& rb, T lhs ) : m_rb( rb ), m_lhs( lhs ), m_truthy(false) {}\n\n    ExpressionLhs& operator = ( const ExpressionLhs& );\n\n    template<typename RhsT>\n    BinaryExpression<T, Internal::IsEqualTo, RhsT const&>\n    operator == ( RhsT const& rhs ) {\n        return captureExpression<Internal::IsEqualTo>( rhs );\n    }\n\n    template<typename RhsT>\n    BinaryExpression<T, Internal::IsNotEqualTo, RhsT const&>\n    operator != ( RhsT const& rhs ) {\n        return captureExpression<Internal::IsNotEqualTo>( rhs );\n    }\n\n    template<typename RhsT>\n    BinaryExpression<T, Internal::IsLessThan, RhsT const&>\n    operator < ( RhsT const& rhs ) {\n        return captureExpression<Internal::IsLessThan>( rhs );\n    }\n\n    template<typename RhsT>\n    BinaryExpression<T, Internal::IsGreaterThan, RhsT const&>\n    operator > ( RhsT const& rhs ) {\n        return captureExpression<Internal::IsGreaterThan>( rhs );\n    }\n\n    template<typename RhsT>\n    BinaryExpression<T, Internal::IsLessThanOrEqualTo, RhsT const&>\n    operator <= ( RhsT const& rhs ) {\n        return captureExpression<Internal::IsLessThanOrEqualTo>( rhs );\n    }\n\n    template<typename RhsT>\n    BinaryExpression<T, Internal::IsGreaterThanOrEqualTo, RhsT const&>\n    operator >= ( RhsT const& rhs ) {\n        return captureExpression<Internal::IsGreaterThanOrEqualTo>( rhs );\n    }\n\n    BinaryExpression<T, Internal::IsEqualTo, bool> operator == ( bool rhs ) {\n        return captureExpression<Internal::IsEqualTo>( rhs );\n    }\n\n    BinaryExpression<T, Internal::IsNotEqualTo, bool> operator != ( bool rhs ) {\n        return captureExpression<Internal::IsNotEqualTo>( rhs );\n    }\n\n    void endExpression() {\n        m_truthy = m_lhs ? true : false;\n        m_rb\n            .setResultType( m_truthy )\n            .endExpression( *this );\n    }\n\n    virtual void reconstructExpression( std::string& dest ) const CATCH_OVERRIDE {\n        dest = Catch::toString( m_lhs );\n    }\n\nprivate:\n    template<Internal::Operator Op, typename RhsT>\n    BinaryExpression<T, Op, RhsT&> captureExpression( RhsT& rhs ) const {\n        return BinaryExpression<T, Op, RhsT&>( m_rb, m_lhs, rhs );\n    }\n\n    template<Internal::Operator Op>\n    BinaryExpression<T, Op, bool> captureExpression( bool rhs ) const {\n        return BinaryExpression<T, Op, bool>( m_rb, m_lhs, rhs );\n    }\n\nprivate:\n    ResultBuilder& m_rb;\n    T m_lhs;\n    bool m_truthy;\n};\n\ntemplate<typename LhsT, Internal::Operator Op, typename RhsT>\nclass BinaryExpression : public DecomposedExpression {\npublic:\n    BinaryExpression( ResultBuilder& rb, LhsT lhs, RhsT rhs )\n        : m_rb( rb ), m_lhs( lhs ), m_rhs( rhs ) {}\n\n    BinaryExpression& operator = ( BinaryExpression& );\n\n    void endExpression() const {\n        m_rb\n            .setResultType( Internal::compare<Op>( m_lhs, m_rhs ) )\n            .endExpression( *this );\n    }\n\n    virtual bool isBinaryExpression() const CATCH_OVERRIDE {\n        return true;\n    }\n\n    virtual void reconstructExpression( std::string& dest ) const CATCH_OVERRIDE {\n        std::string lhs = Catch::toString( m_lhs );\n        std::string rhs = Catch::toString( m_rhs );\n        char delim = lhs.size() + rhs.size() < 40 &&\n                     lhs.find('\\n') == std::string::npos &&\n                     rhs.find('\\n') == std::string::npos ? ' ' : '\\n';\n        dest.reserve( 7 + lhs.size() + rhs.size() );\n                   // 2 for spaces around operator\n                   // 2 for operator\n                   // 2 for parentheses (conditionally added later)\n                   // 1 for negation (conditionally added later)\n        dest = lhs;\n        dest += delim;\n        dest += Internal::OperatorTraits<Op>::getName();\n        dest += delim;\n        dest += rhs;\n    }\n\nprivate:\n    ResultBuilder& m_rb;\n    LhsT m_lhs;\n    RhsT m_rhs;\n};\n\ntemplate<typename ArgT, typename MatcherT>\nclass MatchExpression : public DecomposedExpression {\npublic:\n    MatchExpression( ArgT arg, MatcherT matcher, char const* matcherString )\n        : m_arg( arg ), m_matcher( matcher ), m_matcherString( matcherString ) {}\n\n    virtual bool isBinaryExpression() const CATCH_OVERRIDE {\n        return true;\n    }\n\n    virtual void reconstructExpression( std::string& dest ) const CATCH_OVERRIDE {\n        std::string matcherAsString = m_matcher.toString();\n        dest = Catch::toString( m_arg );\n        dest += ' ';\n        if( matcherAsString == Detail::unprintableString )\n            dest += m_matcherString;\n        else\n            dest += matcherAsString;\n    }\n\nprivate:\n    ArgT m_arg;\n    MatcherT m_matcher;\n    char const* m_matcherString;\n};\n\n} // end namespace Catch\n\n\nnamespace Catch {\n\n    template<typename T>\n    inline ExpressionLhs<T const&> ResultBuilder::operator <= ( T const& operand ) {\n        return ExpressionLhs<T const&>( *this, operand );\n    }\n\n    inline ExpressionLhs<bool> ResultBuilder::operator <= ( bool value ) {\n        return ExpressionLhs<bool>( *this, value );\n    }\n\n    template<typename ArgT, typename MatcherT>\n    inline void ResultBuilder::captureMatch( ArgT const& arg, MatcherT const& matcher,\n                                             char const* matcherString ) {\n        MatchExpression<ArgT const&, MatcherT const&> expr( arg, matcher, matcherString );\n        setResultType( matcher.match( arg ) );\n        endExpression( expr );\n    }\n\n} // namespace Catch\n\n// #included from: catch_message.h\n#define TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED\n\n#include <string>\n\nnamespace Catch {\n\n    struct MessageInfo {\n        MessageInfo(    std::string const& _macroName,\n                        SourceLineInfo const& _lineInfo,\n                        ResultWas::OfType _type );\n\n        std::string macroName;\n        SourceLineInfo lineInfo;\n        ResultWas::OfType type;\n        std::string message;\n        unsigned int sequence;\n\n        bool operator == ( MessageInfo const& other ) const {\n            return sequence == other.sequence;\n        }\n        bool operator < ( MessageInfo const& other ) const {\n            return sequence < other.sequence;\n        }\n    private:\n        static unsigned int globalCount;\n    };\n\n    struct MessageBuilder {\n        MessageBuilder( std::string const& macroName,\n                        SourceLineInfo const& lineInfo,\n                        ResultWas::OfType type )\n        : m_info( macroName, lineInfo, type )\n        {}\n\n        template<typename T>\n        MessageBuilder& operator << ( T const& value ) {\n            m_stream << value;\n            return *this;\n        }\n\n        MessageInfo m_info;\n        std::ostringstream m_stream;\n    };\n\n    class ScopedMessage {\n    public:\n        ScopedMessage( MessageBuilder const& builder );\n        ScopedMessage( ScopedMessage const& other );\n        ~ScopedMessage();\n\n        MessageInfo m_info;\n    };\n\n} // end namespace Catch\n\n// #included from: catch_interfaces_capture.h\n#define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED\n\n#include <string>\n\nnamespace Catch {\n\n    class TestCase;\n    class AssertionResult;\n    struct AssertionInfo;\n    struct SectionInfo;\n    struct SectionEndInfo;\n    struct MessageInfo;\n    class ScopedMessageBuilder;\n    struct Counts;\n\n    struct IResultCapture {\n\n        virtual ~IResultCapture();\n\n        virtual void assertionEnded( AssertionResult const& result ) = 0;\n        virtual bool sectionStarted(    SectionInfo const& sectionInfo,\n                                        Counts& assertions ) = 0;\n        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;\n        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;\n        virtual void pushScopedMessage( MessageInfo const& message ) = 0;\n        virtual void popScopedMessage( MessageInfo const& message ) = 0;\n\n        virtual std::string getCurrentTestName() const = 0;\n        virtual const AssertionResult* getLastResult() const = 0;\n\n        virtual void exceptionEarlyReported() = 0;\n\n        virtual void handleFatalErrorCondition( std::string const& message ) = 0;\n    };\n\n    IResultCapture& getResultCapture();\n}\n\n// #included from: catch_debugger.h\n#define TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED\n\n// #included from: catch_platform.h\n#define TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED\n\n#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)\n#  define CATCH_PLATFORM_MAC\n#elif  defined(__IPHONE_OS_VERSION_MIN_REQUIRED)\n#  define CATCH_PLATFORM_IPHONE\n#elif defined(linux) || defined(__linux) || defined(__linux__)\n#  define CATCH_PLATFORM_LINUX\n#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)\n#  define CATCH_PLATFORM_WINDOWS\n#  if !defined(NOMINMAX) && !defined(CATCH_CONFIG_NO_NOMINMAX)\n#    define CATCH_DEFINES_NOMINMAX\n#  endif\n#  if !defined(WIN32_LEAN_AND_MEAN) && !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)\n#    define CATCH_DEFINES_WIN32_LEAN_AND_MEAN\n#  endif\n#endif\n\n#include <string>\n\nnamespace Catch{\n\n    bool isDebuggerActive();\n    void writeToDebugConsole( std::string const& text );\n}\n\n#ifdef CATCH_PLATFORM_MAC\n\n    // The following code snippet based on:\n    // http://cocoawithlove.com/2008/03/break-into-debugger.html\n    #if defined(__ppc64__) || defined(__ppc__)\n        #define CATCH_TRAP() \\\n                __asm__(\"li r0, 20\\nsc\\nnop\\nli r0, 37\\nli r4, 2\\nsc\\nnop\\n\" \\\n                : : : \"memory\",\"r0\",\"r3\",\"r4\" )\n    #else\n        #define CATCH_TRAP() __asm__(\"int $3\\n\" : : )\n    #endif\n\n#elif defined(CATCH_PLATFORM_LINUX)\n    // If we can use inline assembler, do it because this allows us to break\n    // directly at the location of the failing check instead of breaking inside\n    // raise() called from it, i.e. one stack frame below.\n    #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))\n        #define CATCH_TRAP() asm volatile (\"int $3\")\n    #else // Fall back to the generic way.\n        #include <signal.h>\n\n        #define CATCH_TRAP() raise(SIGTRAP)\n    #endif\n#elif defined(_MSC_VER)\n    #define CATCH_TRAP() __debugbreak()\n#elif defined(__MINGW32__)\n    extern \"C\" __declspec(dllimport) void __stdcall DebugBreak();\n    #define CATCH_TRAP() DebugBreak()\n#endif\n\n#ifdef CATCH_TRAP\n    #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { CATCH_TRAP(); }\n#else\n    #define CATCH_BREAK_INTO_DEBUGGER() Catch::alwaysTrue();\n#endif\n\n// #included from: catch_interfaces_runner.h\n#define TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED\n\nnamespace Catch {\n    class TestCase;\n\n    struct IRunner {\n        virtual ~IRunner();\n        virtual bool aborting() const = 0;\n    };\n}\n\n#if defined(CATCH_CONFIG_FAST_COMPILE)\n///////////////////////////////////////////////////////////////////////////////\n// We can speedup compilation significantly by breaking into debugger lower in\n// the callstack, because then we don't have to expand CATCH_BREAK_INTO_DEBUGGER\n// macro in each assertion\n#define INTERNAL_CATCH_REACT( resultBuilder ) \\\n    resultBuilder.react();\n\n///////////////////////////////////////////////////////////////////////////////\n// Another way to speed-up compilation is to omit local try-catch for REQUIRE*\n// macros.\n// This can potentially cause false negative, if the test code catches\n// the exception before it propagates back up to the runner.\n#define INTERNAL_CATCH_TEST_NO_TRY( macroName, resultDisposition, expr ) \\\n    do { \\\n        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \\\n        __catchResult.setExceptionGuard(); \\\n        CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\\n        ( __catchResult <= expr ).endExpression(); \\\n        CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \\\n        __catchResult.unsetExceptionGuard(); \\\n        INTERNAL_CATCH_REACT( __catchResult ) \\\n    } while( Catch::isTrue( false && static_cast<bool>( !!(expr) ) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look\n// The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.\n\n#define INTERNAL_CHECK_THAT_NO_TRY( macroName, matcher, resultDisposition, arg ) \\\n    do { \\\n        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #arg \", \" #matcher, resultDisposition ); \\\n        __catchResult.setExceptionGuard(); \\\n        __catchResult.captureMatch( arg, matcher, #matcher ); \\\n        __catchResult.unsetExceptionGuard(); \\\n        INTERNAL_CATCH_REACT( __catchResult ) \\\n    } while( Catch::alwaysFalse() )\n\n#else\n///////////////////////////////////////////////////////////////////////////////\n// In the event of a failure works out if the debugger needs to be invoked\n// and/or an exception thrown and takes appropriate action.\n// This needs to be done as a macro so the debugger will stop in the user\n// source code rather than in Catch library code\n#define INTERNAL_CATCH_REACT( resultBuilder ) \\\n    if( resultBuilder.shouldDebugBreak() ) CATCH_BREAK_INTO_DEBUGGER(); \\\n    resultBuilder.react();\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n#define INTERNAL_CATCH_TEST( macroName, resultDisposition, expr ) \\\n    do { \\\n        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \\\n        try { \\\n            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\\n            ( __catchResult <= expr ).endExpression(); \\\n            CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \\\n        } \\\n        catch( ... ) { \\\n            __catchResult.useActiveException( resultDisposition ); \\\n        } \\\n        INTERNAL_CATCH_REACT( __catchResult ) \\\n    } while( Catch::isTrue( false && static_cast<bool>( !!(expr) ) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look\n    // The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.\n\n///////////////////////////////////////////////////////////////////////////////\n#define INTERNAL_CATCH_IF( macroName, resultDisposition, expr ) \\\n    INTERNAL_CATCH_TEST( macroName, resultDisposition, expr ); \\\n    if( Catch::getResultCapture().getLastResult()->succeeded() )\n\n///////////////////////////////////////////////////////////////////////////////\n#define INTERNAL_CATCH_ELSE( macroName, resultDisposition, expr ) \\\n    INTERNAL_CATCH_TEST( macroName, resultDisposition, expr ); \\\n    if( !Catch::getResultCapture().getLastResult()->succeeded() )\n\n///////////////////////////////////////////////////////////////////////////////\n#define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, expr ) \\\n    do { \\\n        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \\\n        try { \\\n            static_cast<void>(expr); \\\n            __catchResult.captureResult( Catch::ResultWas::Ok ); \\\n        } \\\n        catch( ... ) { \\\n            __catchResult.useActiveException( resultDisposition ); \\\n        } \\\n        INTERNAL_CATCH_REACT( __catchResult ) \\\n    } while( Catch::alwaysFalse() )\n\n///////////////////////////////////////////////////////////////////////////////\n#define INTERNAL_CATCH_THROWS( macroName, resultDisposition, matcher, expr ) \\\n    do { \\\n        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition, #matcher ); \\\n        if( __catchResult.allowThrows() ) \\\n            try { \\\n                static_cast<void>(expr); \\\n                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \\\n            } \\\n            catch( ... ) { \\\n                __catchResult.captureExpectedException( matcher ); \\\n            } \\\n        else \\\n            __catchResult.captureResult( Catch::ResultWas::Ok ); \\\n        INTERNAL_CATCH_REACT( __catchResult ) \\\n    } while( Catch::alwaysFalse() )\n\n///////////////////////////////////////////////////////////////////////////////\n#define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \\\n    do { \\\n        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr \", \" #exceptionType, resultDisposition ); \\\n        if( __catchResult.allowThrows() ) \\\n            try { \\\n                static_cast<void>(expr); \\\n                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \\\n            } \\\n            catch( exceptionType ) { \\\n                __catchResult.captureResult( Catch::ResultWas::Ok ); \\\n            } \\\n            catch( ... ) { \\\n                __catchResult.useActiveException( resultDisposition ); \\\n            } \\\n        else \\\n            __catchResult.captureResult( Catch::ResultWas::Ok ); \\\n        INTERNAL_CATCH_REACT( __catchResult ) \\\n    } while( Catch::alwaysFalse() )\n\n///////////////////////////////////////////////////////////////////////////////\n#ifdef CATCH_CONFIG_VARIADIC_MACROS\n    #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \\\n        do { \\\n            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, \"\", resultDisposition ); \\\n            __catchResult << __VA_ARGS__ + ::Catch::StreamEndStop(); \\\n            __catchResult.captureResult( messageType ); \\\n            INTERNAL_CATCH_REACT( __catchResult ) \\\n        } while( Catch::alwaysFalse() )\n#else\n    #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, log ) \\\n        do { \\\n            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, \"\", resultDisposition ); \\\n            __catchResult << log + ::Catch::StreamEndStop(); \\\n            __catchResult.captureResult( messageType ); \\\n            INTERNAL_CATCH_REACT( __catchResult ) \\\n        } while( Catch::alwaysFalse() )\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n#define INTERNAL_CATCH_INFO( macroName, log ) \\\n    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage ) = Catch::MessageBuilder( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log;\n\n///////////////////////////////////////////////////////////////////////////////\n#define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \\\n    do { \\\n        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #arg \", \" #matcher, resultDisposition ); \\\n        try { \\\n            __catchResult.captureMatch( arg, matcher, #matcher ); \\\n        } catch( ... ) { \\\n            __catchResult.useActiveException( resultDisposition | Catch::ResultDisposition::ContinueOnFailure ); \\\n        } \\\n        INTERNAL_CATCH_REACT( __catchResult ) \\\n    } while( Catch::alwaysFalse() )\n\n// #included from: internal/catch_section.h\n#define TWOBLUECUBES_CATCH_SECTION_H_INCLUDED\n\n// #included from: catch_section_info.h\n#define TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED\n\n// #included from: catch_totals.hpp\n#define TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED\n\n#include <cstddef>\n\nnamespace Catch {\n\n    struct Counts {\n        Counts() : passed( 0 ), failed( 0 ), failedButOk( 0 ) {}\n\n        Counts operator - ( Counts const& other ) const {\n            Counts diff;\n            diff.passed = passed - other.passed;\n            diff.failed = failed - other.failed;\n            diff.failedButOk = failedButOk - other.failedButOk;\n            return diff;\n        }\n        Counts& operator += ( Counts const& other ) {\n            passed += other.passed;\n            failed += other.failed;\n            failedButOk += other.failedButOk;\n            return *this;\n        }\n\n        std::size_t total() const {\n            return passed + failed + failedButOk;\n        }\n        bool allPassed() const {\n            return failed == 0 && failedButOk == 0;\n        }\n        bool allOk() const {\n            return failed == 0;\n        }\n\n        std::size_t passed;\n        std::size_t failed;\n        std::size_t failedButOk;\n    };\n\n    struct Totals {\n\n        Totals operator - ( Totals const& other ) const {\n            Totals diff;\n            diff.assertions = assertions - other.assertions;\n            diff.testCases = testCases - other.testCases;\n            return diff;\n        }\n\n        Totals delta( Totals const& prevTotals ) const {\n            Totals diff = *this - prevTotals;\n            if( diff.assertions.failed > 0 )\n                ++diff.testCases.failed;\n            else if( diff.assertions.failedButOk > 0 )\n                ++diff.testCases.failedButOk;\n            else\n                ++diff.testCases.passed;\n            return diff;\n        }\n\n        Totals& operator += ( Totals const& other ) {\n            assertions += other.assertions;\n            testCases += other.testCases;\n            return *this;\n        }\n\n        Counts assertions;\n        Counts testCases;\n    };\n}\n\n#include <string>\n\nnamespace Catch {\n\n    struct SectionInfo {\n        SectionInfo\n            (   SourceLineInfo const& _lineInfo,\n                std::string const& _name,\n                std::string const& _description = std::string() );\n\n        std::string name;\n        std::string description;\n        SourceLineInfo lineInfo;\n    };\n\n    struct SectionEndInfo {\n        SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds )\n        : sectionInfo( _sectionInfo ), prevAssertions( _prevAssertions ), durationInSeconds( _durationInSeconds )\n        {}\n\n        SectionInfo sectionInfo;\n        Counts prevAssertions;\n        double durationInSeconds;\n    };\n\n} // end namespace Catch\n\n// #included from: catch_timer.h\n#define TWOBLUECUBES_CATCH_TIMER_H_INCLUDED\n\n#ifdef _MSC_VER\n\nnamespace Catch {\n    typedef unsigned long long UInt64;\n}\n#else\n#include <stdint.h>\nnamespace Catch {\n    typedef uint64_t UInt64;\n}\n#endif\n\nnamespace Catch {\n    class Timer {\n    public:\n        Timer() : m_ticks( 0 ) {}\n        void start();\n        unsigned int getElapsedMicroseconds() const;\n        unsigned int getElapsedMilliseconds() const;\n        double getElapsedSeconds() const;\n\n    private:\n        UInt64 m_ticks;\n    };\n\n} // namespace Catch\n\n#include <string>\n\nnamespace Catch {\n\n    class Section : NonCopyable {\n    public:\n        Section( SectionInfo const& info );\n        ~Section();\n\n        // This indicates whether the section should be executed or not\n        operator bool() const;\n\n    private:\n        SectionInfo m_info;\n\n        std::string m_name;\n        Counts m_assertions;\n        bool m_sectionIncluded;\n        Timer m_timer;\n    };\n\n} // end namespace Catch\n\n#ifdef CATCH_CONFIG_VARIADIC_MACROS\n    #define INTERNAL_CATCH_SECTION( ... ) \\\n        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) )\n#else\n    #define INTERNAL_CATCH_SECTION( name, desc ) \\\n        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, name, desc ) )\n#endif\n\n// #included from: internal/catch_generators.hpp\n#define TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED\n\n#include <vector>\n#include <string>\n#include <stdlib.h>\n\nnamespace Catch {\n\ntemplate<typename T>\nstruct IGenerator {\n    virtual ~IGenerator() {}\n    virtual T getValue( std::size_t index ) const = 0;\n    virtual std::size_t size () const = 0;\n};\n\ntemplate<typename T>\nclass BetweenGenerator : public IGenerator<T> {\npublic:\n    BetweenGenerator( T from, T to ) : m_from( from ), m_to( to ){}\n\n    virtual T getValue( std::size_t index ) const {\n        return m_from+static_cast<int>( index );\n    }\n\n    virtual std::size_t size() const {\n        return static_cast<std::size_t>( 1+m_to-m_from );\n    }\n\nprivate:\n\n    T m_from;\n    T m_to;\n};\n\ntemplate<typename T>\nclass ValuesGenerator : public IGenerator<T> {\npublic:\n    ValuesGenerator(){}\n\n    void add( T value ) {\n        m_values.push_back( value );\n    }\n\n    virtual T getValue( std::size_t index ) const {\n        return m_values[index];\n    }\n\n    virtual std::size_t size() const {\n        return m_values.size();\n    }\n\nprivate:\n    std::vector<T> m_values;\n};\n\ntemplate<typename T>\nclass CompositeGenerator {\npublic:\n    CompositeGenerator() : m_totalSize( 0 ) {}\n\n    // *** Move semantics, similar to auto_ptr ***\n    CompositeGenerator( CompositeGenerator& other )\n    :   m_fileInfo( other.m_fileInfo ),\n        m_totalSize( 0 )\n    {\n        move( other );\n    }\n\n    CompositeGenerator& setFileInfo( const char* fileInfo ) {\n        m_fileInfo = fileInfo;\n        return *this;\n    }\n\n    ~CompositeGenerator() {\n        deleteAll( m_composed );\n    }\n\n    operator T () const {\n        size_t overallIndex = getCurrentContext().getGeneratorIndex( m_fileInfo, m_totalSize );\n\n        typename std::vector<const IGenerator<T>*>::const_iterator it = m_composed.begin();\n        typename std::vector<const IGenerator<T>*>::const_iterator itEnd = m_composed.end();\n        for( size_t index = 0; it != itEnd; ++it )\n        {\n            const IGenerator<T>* generator = *it;\n            if( overallIndex >= index && overallIndex < index + generator->size() )\n            {\n                return generator->getValue( overallIndex-index );\n            }\n            index += generator->size();\n        }\n        CATCH_INTERNAL_ERROR( \"Indexed past end of generated range\" );\n        return T(); // Suppress spurious \"not all control paths return a value\" warning in Visual Studio - if you know how to fix this please do so\n    }\n\n    void add( const IGenerator<T>* generator ) {\n        m_totalSize += generator->size();\n        m_composed.push_back( generator );\n    }\n\n    CompositeGenerator& then( CompositeGenerator& other ) {\n        move( other );\n        return *this;\n    }\n\n    CompositeGenerator& then( T value ) {\n        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();\n        valuesGen->add( value );\n        add( valuesGen );\n        return *this;\n    }\n\nprivate:\n\n    void move( CompositeGenerator& other ) {\n        m_composed.insert( m_composed.end(), other.m_composed.begin(), other.m_composed.end() );\n        m_totalSize += other.m_totalSize;\n        other.m_composed.clear();\n    }\n\n    std::vector<const IGenerator<T>*> m_composed;\n    std::string m_fileInfo;\n    size_t m_totalSize;\n};\n\nnamespace Generators\n{\n    template<typename T>\n    CompositeGenerator<T> between( T from, T to ) {\n        CompositeGenerator<T> generators;\n        generators.add( new BetweenGenerator<T>( from, to ) );\n        return generators;\n    }\n\n    template<typename T>\n    CompositeGenerator<T> values( T val1, T val2 ) {\n        CompositeGenerator<T> generators;\n        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();\n        valuesGen->add( val1 );\n        valuesGen->add( val2 );\n        generators.add( valuesGen );\n        return generators;\n    }\n\n    template<typename T>\n    CompositeGenerator<T> values( T val1, T val2, T val3 ){\n        CompositeGenerator<T> generators;\n        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();\n        valuesGen->add( val1 );\n        valuesGen->add( val2 );\n        valuesGen->add( val3 );\n        generators.add( valuesGen );\n        return generators;\n    }\n\n    template<typename T>\n    CompositeGenerator<T> values( T val1, T val2, T val3, T val4 ) {\n        CompositeGenerator<T> generators;\n        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();\n        valuesGen->add( val1 );\n        valuesGen->add( val2 );\n        valuesGen->add( val3 );\n        valuesGen->add( val4 );\n        generators.add( valuesGen );\n        return generators;\n    }\n\n} // end namespace Generators\n\nusing namespace Generators;\n\n} // end namespace Catch\n\n#define INTERNAL_CATCH_LINESTR2( line ) #line\n#define INTERNAL_CATCH_LINESTR( line ) INTERNAL_CATCH_LINESTR2( line )\n\n#define INTERNAL_CATCH_GENERATE( expr ) expr.setFileInfo( __FILE__ \"(\" INTERNAL_CATCH_LINESTR( __LINE__ ) \")\" )\n\n// #included from: internal/catch_interfaces_exception.h\n#define TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED\n\n#include <string>\n#include <vector>\n\n// #included from: catch_interfaces_registry_hub.h\n#define TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED\n\n#include <string>\n\nnamespace Catch {\n\n    class TestCase;\n    struct ITestCaseRegistry;\n    struct IExceptionTranslatorRegistry;\n    struct IExceptionTranslator;\n    struct IReporterRegistry;\n    struct IReporterFactory;\n    struct ITagAliasRegistry;\n\n    struct IRegistryHub {\n        virtual ~IRegistryHub();\n\n        virtual IReporterRegistry const& getReporterRegistry() const = 0;\n        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;\n        virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;\n\n        virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;\n    };\n\n    struct IMutableRegistryHub {\n        virtual ~IMutableRegistryHub();\n        virtual void registerReporter( std::string const& name, Ptr<IReporterFactory> const& factory ) = 0;\n        virtual void registerListener( Ptr<IReporterFactory> const& factory ) = 0;\n        virtual void registerTest( TestCase const& testInfo ) = 0;\n        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;\n        virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;\n    };\n\n    IRegistryHub& getRegistryHub();\n    IMutableRegistryHub& getMutableRegistryHub();\n    void cleanUp();\n    std::string translateActiveException();\n\n}\n\nnamespace Catch {\n\n    typedef std::string(*exceptionTranslateFunction)();\n\n    struct IExceptionTranslator;\n    typedef std::vector<const IExceptionTranslator*> ExceptionTranslators;\n\n    struct IExceptionTranslator {\n        virtual ~IExceptionTranslator();\n        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;\n    };\n\n    struct IExceptionTranslatorRegistry {\n        virtual ~IExceptionTranslatorRegistry();\n\n        virtual std::string translateActiveException() const = 0;\n    };\n\n    class ExceptionTranslatorRegistrar {\n        template<typename T>\n        class ExceptionTranslator : public IExceptionTranslator {\n        public:\n\n            ExceptionTranslator( std::string(*translateFunction)( T& ) )\n            : m_translateFunction( translateFunction )\n            {}\n\n            virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const CATCH_OVERRIDE {\n                try {\n                    if( it == itEnd )\n                        throw;\n                    else\n                        return (*it)->translate( it+1, itEnd );\n                }\n                catch( T& ex ) {\n                    return m_translateFunction( ex );\n                }\n            }\n\n        protected:\n            std::string(*m_translateFunction)( T& );\n        };\n\n    public:\n        template<typename T>\n        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {\n            getMutableRegistryHub().registerTranslator\n                ( new ExceptionTranslator<T>( translateFunction ) );\n        }\n    };\n}\n\n///////////////////////////////////////////////////////////////////////////////\n#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \\\n    static std::string translatorName( signature ); \\\n    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); }\\\n    static std::string translatorName( signature )\n\n#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )\n\n// #included from: internal/catch_approx.hpp\n#define TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED\n\n#include <cmath>\n#include <limits>\n\n#if defined(CATCH_CONFIG_CPP11_TYPE_TRAITS)\n#include <type_traits>\n#endif\n\nnamespace Catch {\nnamespace Detail {\n\n    class Approx {\n    public:\n        explicit Approx ( double value )\n        :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),\n            m_margin( 0.0 ),\n            m_scale( 1.0 ),\n            m_value( value )\n        {}\n\n        Approx( Approx const& other )\n        :   m_epsilon( other.m_epsilon ),\n            m_margin( other.m_margin ),\n            m_scale( other.m_scale ),\n            m_value( other.m_value )\n        {}\n\n        static Approx custom() {\n            return Approx( 0 );\n        }\n\n#if defined(CATCH_CONFIG_CPP11_TYPE_TRAITS)\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx operator()( T value ) {\n            Approx approx( static_cast<double>(value) );\n            approx.epsilon( m_epsilon );\n            approx.margin( m_margin );\n            approx.scale( m_scale );\n            return approx;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        explicit Approx( T value ): Approx(static_cast<double>(value))\n        {}\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator == ( const T& lhs, Approx const& rhs ) {\n            // Thanks to Richard Harris for his help refining this formula\n            auto lhs_v = double(lhs);\n            bool relativeOK = std::fabs(lhs_v - rhs.m_value) < rhs.m_epsilon * (rhs.m_scale + (std::max)(std::fabs(lhs_v), std::fabs(rhs.m_value)));\n            if (relativeOK) {\n                return true;\n            }\n            return std::fabs(lhs_v - rhs.m_value) < rhs.m_margin;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator == ( Approx const& lhs, const T& rhs ) {\n            return operator==( rhs, lhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator != ( T lhs, Approx const& rhs ) {\n            return !operator==( lhs, rhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator != ( Approx const& lhs, T rhs ) {\n            return !operator==( rhs, lhs );\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator <= ( T lhs, Approx const& rhs ) {\n            return double(lhs) < rhs.m_value || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator <= ( Approx const& lhs, T rhs ) {\n            return lhs.m_value < double(rhs) || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator >= ( T lhs, Approx const& rhs ) {\n            return double(lhs) > rhs.m_value || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        friend bool operator >= ( Approx const& lhs, T rhs ) {\n            return lhs.m_value > double(rhs) || lhs == rhs;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& epsilon( T newEpsilon ) {\n            m_epsilon = double(newEpsilon);\n            return *this;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& margin( T newMargin ) {\n            m_margin = double(newMargin);\n            return *this;\n        }\n\n        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n        Approx& scale( T newScale ) {\n            m_scale = double(newScale);\n            return *this;\n        }\n\n#else\n\n        Approx operator()( double value ) {\n            Approx approx( value );\n            approx.epsilon( m_epsilon );\n            approx.margin( m_margin );\n            approx.scale( m_scale );\n            return approx;\n        }\n\n        friend bool operator == ( double lhs, Approx const& rhs ) {\n            // Thanks to Richard Harris for his help refining this formula\n            bool relativeOK = std::fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( std::fabs(lhs), std::fabs(rhs.m_value) ) );\n            if (relativeOK) {\n                return true;\n            }\n            return std::fabs(lhs - rhs.m_value) < rhs.m_margin;\n        }\n\n        friend bool operator == ( Approx const& lhs, double rhs ) {\n            return operator==( rhs, lhs );\n        }\n\n        friend bool operator != ( double lhs, Approx const& rhs ) {\n            return !operator==( lhs, rhs );\n        }\n\n        friend bool operator != ( Approx const& lhs, double rhs ) {\n            return !operator==( rhs, lhs );\n        }\n\n        friend bool operator <= ( double lhs, Approx const& rhs ) {\n            return lhs < rhs.m_value || lhs == rhs;\n        }\n\n        friend bool operator <= ( Approx const& lhs, double rhs ) {\n            return lhs.m_value < rhs || lhs == rhs;\n        }\n\n        friend bool operator >= ( double lhs, Approx const& rhs ) {\n            return lhs > rhs.m_value || lhs == rhs;\n        }\n\n        friend bool operator >= ( Approx const& lhs, double rhs ) {\n            return lhs.m_value > rhs || lhs == rhs;\n        }\n\n        Approx& epsilon( double newEpsilon ) {\n            m_epsilon = newEpsilon;\n            return *this;\n        }\n\n        Approx& margin( double newMargin ) {\n            m_margin = newMargin;\n            return *this;\n        }\n\n        Approx& scale( double newScale ) {\n            m_scale = newScale;\n            return *this;\n        }\n#endif\n\n        std::string toString() const {\n            std::ostringstream oss;\n            oss << \"Approx( \" << Catch::toString( m_value ) << \" )\";\n            return oss.str();\n        }\n\n    private:\n        double m_epsilon;\n        double m_margin;\n        double m_scale;\n        double m_value;\n    };\n}\n\ntemplate<>\ninline std::string toString<Detail::Approx>( Detail::Approx const& value ) {\n    return value.toString();\n}\n\n} // end namespace Catch\n\n// #included from: internal/catch_matchers_string.h\n#define TWOBLUECUBES_CATCH_MATCHERS_STRING_H_INCLUDED\n\nnamespace Catch {\nnamespace Matchers {\n\n    namespace StdString {\n\n        struct CasedString\n        {\n            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );\n            std::string adjustString( std::string const& str ) const;\n            std::string caseSensitivitySuffix() const;\n\n            CaseSensitive::Choice m_caseSensitivity;\n            std::string m_str;\n        };\n\n        struct StringMatcherBase : MatcherBase<std::string> {\n            StringMatcherBase( std::string const& operation, CasedString const& comparator );\n            virtual std::string describe() const CATCH_OVERRIDE;\n\n            CasedString m_comparator;\n            std::string m_operation;\n        };\n\n        struct EqualsMatcher : StringMatcherBase {\n            EqualsMatcher( CasedString const& comparator );\n            virtual bool match( std::string const& source ) const CATCH_OVERRIDE;\n        };\n        struct ContainsMatcher : StringMatcherBase {\n            ContainsMatcher( CasedString const& comparator );\n            virtual bool match( std::string const& source ) const CATCH_OVERRIDE;\n        };\n        struct StartsWithMatcher : StringMatcherBase {\n            StartsWithMatcher( CasedString const& comparator );\n            virtual bool match( std::string const& source ) const CATCH_OVERRIDE;\n        };\n        struct EndsWithMatcher : StringMatcherBase {\n            EndsWithMatcher( CasedString const& comparator );\n            virtual bool match( std::string const& source ) const CATCH_OVERRIDE;\n        };\n\n    } // namespace StdString\n\n    // The following functions create the actual matcher objects.\n    // This allows the types to be inferred\n\n    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\n\n} // namespace Matchers\n} // namespace Catch\n\n// #included from: internal/catch_matchers_vector.h\n#define TWOBLUECUBES_CATCH_MATCHERS_VECTOR_H_INCLUDED\n\nnamespace Catch {\nnamespace Matchers {\n\n    namespace Vector {\n\n        template<typename T>\n        struct ContainsElementMatcher : MatcherBase<std::vector<T>, T> {\n\n            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}\n\n            bool match(std::vector<T> const &v) const CATCH_OVERRIDE {\n                return std::find(v.begin(), v.end(), m_comparator) != v.end();\n            }\n\n            virtual std::string describe() const CATCH_OVERRIDE {\n                return \"Contains: \" + Catch::toString( m_comparator );\n            }\n\n            T const& m_comparator;\n        };\n\n        template<typename T>\n        struct ContainsMatcher : MatcherBase<std::vector<T>, std::vector<T> > {\n\n            ContainsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n\n            bool match(std::vector<T> const &v) const CATCH_OVERRIDE {\n                // !TBD: see note in EqualsMatcher\n                if (m_comparator.size() > v.size())\n                    return false;\n                for (size_t i = 0; i < m_comparator.size(); ++i)\n                    if (std::find(v.begin(), v.end(), m_comparator[i]) == v.end())\n                        return false;\n                return true;\n            }\n            virtual std::string describe() const CATCH_OVERRIDE {\n                return \"Contains: \" + Catch::toString( m_comparator );\n            }\n\n            std::vector<T> const& m_comparator;\n        };\n\n        template<typename T>\n        struct EqualsMatcher : MatcherBase<std::vector<T>, std::vector<T> > {\n\n            EqualsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}\n\n            bool match(std::vector<T> const &v) const CATCH_OVERRIDE {\n                // !TBD: This currently works if all elements can be compared using !=\n                // - a more general approach would be via a compare template that defaults\n                // to using !=. but could be specialised for, e.g. std::vector<T> etc\n                // - then just call that directly\n                if (m_comparator.size() != v.size())\n                    return false;\n                for (size_t i = 0; i < v.size(); ++i)\n                    if (m_comparator[i] != v[i])\n                        return false;\n                return true;\n            }\n            virtual std::string describe() const CATCH_OVERRIDE {\n                return \"Equals: \" + Catch::toString( m_comparator );\n            }\n            std::vector<T> const& m_comparator;\n        };\n\n    } // namespace Vector\n\n    // The following functions create the actual matcher objects.\n    // This allows the types to be inferred\n\n    template<typename T>\n    Vector::ContainsMatcher<T> Contains( std::vector<T> const& comparator ) {\n        return Vector::ContainsMatcher<T>( comparator );\n    }\n\n    template<typename T>\n    Vector::ContainsElementMatcher<T> VectorContains( T const& comparator ) {\n        return Vector::ContainsElementMatcher<T>( comparator );\n    }\n\n    template<typename T>\n    Vector::EqualsMatcher<T> Equals( std::vector<T> const& comparator ) {\n        return Vector::EqualsMatcher<T>( comparator );\n    }\n\n} // namespace Matchers\n} // namespace Catch\n\n// #included from: internal/catch_interfaces_tag_alias_registry.h\n#define TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED\n\n// #included from: catch_tag_alias.h\n#define TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED\n\n#include <string>\n\nnamespace Catch {\n\n    struct TagAlias {\n        TagAlias( std::string const& _tag, SourceLineInfo _lineInfo ) : tag( _tag ), lineInfo( _lineInfo ) {}\n\n        std::string tag;\n        SourceLineInfo lineInfo;\n    };\n\n    struct RegistrarForTagAliases {\n        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );\n    };\n\n} // end namespace Catch\n\n#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); }\n// #included from: catch_option.hpp\n#define TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED\n\nnamespace Catch {\n\n    // An optional type\n    template<typename T>\n    class Option {\n    public:\n        Option() : nullableValue( CATCH_NULL ) {}\n        Option( T const& _value )\n        : nullableValue( new( storage ) T( _value ) )\n        {}\n        Option( Option const& _other )\n        : nullableValue( _other ? new( storage ) T( *_other ) : CATCH_NULL )\n        {}\n\n        ~Option() {\n            reset();\n        }\n\n        Option& operator= ( Option const& _other ) {\n            if( &_other != this ) {\n                reset();\n                if( _other )\n                    nullableValue = new( storage ) T( *_other );\n            }\n            return *this;\n        }\n        Option& operator = ( T const& _value ) {\n            reset();\n            nullableValue = new( storage ) T( _value );\n            return *this;\n        }\n\n        void reset() {\n            if( nullableValue )\n                nullableValue->~T();\n            nullableValue = CATCH_NULL;\n        }\n\n        T& operator*() { return *nullableValue; }\n        T const& operator*() const { return *nullableValue; }\n        T* operator->() { return nullableValue; }\n        const T* operator->() const { return nullableValue; }\n\n        T valueOr( T const& defaultValue ) const {\n            return nullableValue ? *nullableValue : defaultValue;\n        }\n\n        bool some() const { return nullableValue != CATCH_NULL; }\n        bool none() const { return nullableValue == CATCH_NULL; }\n\n        bool operator !() const { return nullableValue == CATCH_NULL; }\n        operator SafeBool::type() const {\n            return SafeBool::makeSafe( some() );\n        }\n\n    private:\n        T *nullableValue;\n        union {\n            char storage[sizeof(T)];\n\n            // These are here to force alignment for the storage\n            long double dummy1;\n            void (*dummy2)();\n            long double dummy3;\n#ifdef CATCH_CONFIG_CPP11_LONG_LONG\n            long long dummy4;\n#endif\n        };\n    };\n\n} // end namespace Catch\n\nnamespace Catch {\n\n    struct ITagAliasRegistry {\n        virtual ~ITagAliasRegistry();\n        virtual Option<TagAlias> find( std::string const& alias ) const = 0;\n        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;\n\n        static ITagAliasRegistry const& get();\n    };\n\n} // end namespace Catch\n\n// These files are included here so the single_include script doesn't put them\n// in the conditionally compiled sections\n// #included from: internal/catch_test_case_info.h\n#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED\n\n#include <string>\n#include <set>\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\nnamespace Catch {\n\n    struct ITestCase;\n\n    struct TestCaseInfo {\n        enum SpecialProperties{\n            None = 0,\n            IsHidden = 1 << 1,\n            ShouldFail = 1 << 2,\n            MayFail = 1 << 3,\n            Throws = 1 << 4,\n            NonPortable = 1 << 5\n        };\n\n        TestCaseInfo(   std::string const& _name,\n                        std::string const& _className,\n                        std::string const& _description,\n                        std::set<std::string> const& _tags,\n                        SourceLineInfo const& _lineInfo );\n\n        TestCaseInfo( TestCaseInfo const& other );\n\n        friend void setTags( TestCaseInfo& testCaseInfo, std::set<std::string> const& tags );\n\n        bool isHidden() const;\n        bool throws() const;\n        bool okToFail() const;\n        bool expectedToFail() const;\n\n        std::string name;\n        std::string className;\n        std::string description;\n        std::set<std::string> tags;\n        std::set<std::string> lcaseTags;\n        std::string tagsAsString;\n        SourceLineInfo lineInfo;\n        SpecialProperties properties;\n    };\n\n    class TestCase : public TestCaseInfo {\n    public:\n\n        TestCase( ITestCase* testCase, TestCaseInfo const& info );\n        TestCase( TestCase const& other );\n\n        TestCase withName( std::string const& _newName ) const;\n\n        void invoke() const;\n\n        TestCaseInfo const& getTestCaseInfo() const;\n\n        void swap( TestCase& other );\n        bool operator == ( TestCase const& other ) const;\n        bool operator < ( TestCase const& other ) const;\n        TestCase& operator = ( TestCase const& other );\n\n    private:\n        Ptr<ITestCase> test;\n    };\n\n    TestCase makeTestCase(  ITestCase* testCase,\n                            std::string const& className,\n                            std::string const& name,\n                            std::string const& description,\n                            SourceLineInfo const& lineInfo );\n}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n\n#ifdef __OBJC__\n// #included from: internal/catch_objc.hpp\n#define TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED\n\n#import <objc/runtime.h>\n\n#include <string>\n\n// NB. Any general catch headers included here must be included\n// in catch.hpp first to make sure they are included by the single\n// header for non obj-usage\n\n///////////////////////////////////////////////////////////////////////////////\n// This protocol is really only here for (self) documenting purposes, since\n// all its methods are optional.\n@protocol OcFixture\n\n@optional\n\n-(void) setUp;\n-(void) tearDown;\n\n@end\n\nnamespace Catch {\n\n    class OcMethod : public SharedImpl<ITestCase> {\n\n    public:\n        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}\n\n        virtual void invoke() const {\n            id obj = [[m_cls alloc] init];\n\n            performOptionalSelector( obj, @selector(setUp)  );\n            performOptionalSelector( obj, m_sel );\n            performOptionalSelector( obj, @selector(tearDown)  );\n\n            arcSafeRelease( obj );\n        }\n    private:\n        virtual ~OcMethod() {}\n\n        Class m_cls;\n        SEL m_sel;\n    };\n\n    namespace Detail{\n\n        inline std::string getAnnotation(   Class cls,\n                                            std::string const& annotationName,\n                                            std::string const& testCaseName ) {\n            NSString* selStr = [[NSString alloc] initWithFormat:@\"Catch_%s_%s\", annotationName.c_str(), testCaseName.c_str()];\n            SEL sel = NSSelectorFromString( selStr );\n            arcSafeRelease( selStr );\n            id value = performOptionalSelector( cls, sel );\n            if( value )\n                return [(NSString*)value UTF8String];\n            return \"\";\n        }\n    }\n\n    inline size_t registerTestMethods() {\n        size_t noTestMethods = 0;\n        int noClasses = objc_getClassList( CATCH_NULL, 0 );\n\n        Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);\n        objc_getClassList( classes, noClasses );\n\n        for( int c = 0; c < noClasses; c++ ) {\n            Class cls = classes[c];\n            {\n                u_int count;\n                Method* methods = class_copyMethodList( cls, &count );\n                for( u_int m = 0; m < count ; m++ ) {\n                    SEL selector = method_getName(methods[m]);\n                    std::string methodName = sel_getName(selector);\n                    if( startsWith( methodName, \"Catch_TestCase_\" ) ) {\n                        std::string testCaseName = methodName.substr( 15 );\n                        std::string name = Detail::getAnnotation( cls, \"Name\", testCaseName );\n                        std::string desc = Detail::getAnnotation( cls, \"Description\", testCaseName );\n                        const char* className = class_getName( cls );\n\n                        getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, name.c_str(), desc.c_str(), SourceLineInfo() ) );\n                        noTestMethods++;\n                    }\n                }\n                free(methods);\n            }\n        }\n        return noTestMethods;\n    }\n\n    namespace Matchers {\n        namespace Impl {\n        namespace NSStringMatchers {\n\n            struct StringHolder : MatcherBase<NSString*>{\n                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}\n                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}\n                StringHolder() {\n                    arcSafeRelease( m_substr );\n                }\n\n                virtual bool match( NSString* arg ) const CATCH_OVERRIDE {\n                    return false;\n                }\n\n                NSString* m_substr;\n            };\n\n            struct Equals : StringHolder {\n                Equals( NSString* substr ) : StringHolder( substr ){}\n\n                virtual bool match( NSString* str ) const CATCH_OVERRIDE {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str isEqualToString:m_substr];\n                }\n\n                virtual std::string describe() const CATCH_OVERRIDE {\n                    return \"equals string: \" + Catch::toString( m_substr );\n                }\n            };\n\n            struct Contains : StringHolder {\n                Contains( NSString* substr ) : StringHolder( substr ){}\n\n                virtual bool match( NSString* str ) const {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location != NSNotFound;\n                }\n\n                virtual std::string describe() const CATCH_OVERRIDE {\n                    return \"contains string: \" + Catch::toString( m_substr );\n                }\n            };\n\n            struct StartsWith : StringHolder {\n                StartsWith( NSString* substr ) : StringHolder( substr ){}\n\n                virtual bool match( NSString* str ) const {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == 0;\n                }\n\n                virtual std::string describe() const CATCH_OVERRIDE {\n                    return \"starts with: \" + Catch::toString( m_substr );\n                }\n            };\n            struct EndsWith : StringHolder {\n                EndsWith( NSString* substr ) : StringHolder( substr ){}\n\n                virtual bool match( NSString* str ) const {\n                    return  (str != nil || m_substr == nil ) &&\n                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];\n                }\n\n                virtual std::string describe() const CATCH_OVERRIDE {\n                    return \"ends with: \" + Catch::toString( m_substr );\n                }\n            };\n\n        } // namespace NSStringMatchers\n        } // namespace Impl\n\n        inline Impl::NSStringMatchers::Equals\n            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }\n\n        inline Impl::NSStringMatchers::Contains\n            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }\n\n        inline Impl::NSStringMatchers::StartsWith\n            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }\n\n        inline Impl::NSStringMatchers::EndsWith\n            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }\n\n    } // namespace Matchers\n\n    using namespace Matchers;\n\n} // namespace Catch\n\n///////////////////////////////////////////////////////////////////////////////\n#define OC_TEST_CASE( name, desc )\\\n+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Name_test ) \\\n{\\\nreturn @ name; \\\n}\\\n+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Description_test ) \\\n{ \\\nreturn @ desc; \\\n} \\\n-(void) INTERNAL_CATCH_UNIQUE_NAME( Catch_TestCase_test )\n\n#endif\n\n#ifdef CATCH_IMPL\n\n// !TBD: Move the leak detector code into a separate header\n#ifdef CATCH_CONFIG_WINDOWS_CRTDBG\n#include <crtdbg.h>\nclass LeakDetector {\npublic:\n    LeakDetector() {\n        int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);\n        flag |= _CRTDBG_LEAK_CHECK_DF;\n        flag |= _CRTDBG_ALLOC_MEM_DF;\n        _CrtSetDbgFlag(flag);\n        _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);\n        _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n        // Change this to leaking allocation's number to break there\n        _CrtSetBreakAlloc(-1);\n    }\n};\n#else\nclass LeakDetector {};\n#endif\n\nLeakDetector leakDetector;\n\n// #included from: internal/catch_impl.hpp\n#define TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED\n\n// Collect all the implementation files together here\n// These are the equivalent of what would usually be cpp files\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wweak-vtables\"\n#endif\n\n// #included from: ../catch_session.hpp\n#define TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED\n\n// #included from: internal/catch_commandline.hpp\n#define TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED\n\n// #included from: catch_config.hpp\n#define TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED\n\n// #included from: catch_test_spec_parser.hpp\n#define TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\n// #included from: catch_test_spec.hpp\n#define TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\n// #included from: catch_wildcard_pattern.hpp\n#define TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED\n\n#include <stdexcept>\n\nnamespace Catch\n{\n    class WildcardPattern {\n        enum WildcardPosition {\n            NoWildcard = 0,\n            WildcardAtStart = 1,\n            WildcardAtEnd = 2,\n            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd\n        };\n\n    public:\n\n        WildcardPattern( std::string const& pattern, CaseSensitive::Choice caseSensitivity )\n        :   m_caseSensitivity( caseSensitivity ),\n            m_wildcard( NoWildcard ),\n            m_pattern( adjustCase( pattern ) )\n        {\n            if( startsWith( m_pattern, '*' ) ) {\n                m_pattern = m_pattern.substr( 1 );\n                m_wildcard = WildcardAtStart;\n            }\n            if( endsWith( m_pattern, '*' ) ) {\n                m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );\n                m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );\n            }\n        }\n        virtual ~WildcardPattern();\n        virtual bool matches( std::string const& str ) const {\n            switch( m_wildcard ) {\n                case NoWildcard:\n                    return m_pattern == adjustCase( str );\n                case WildcardAtStart:\n                    return endsWith( adjustCase( str ), m_pattern );\n                case WildcardAtEnd:\n                    return startsWith( adjustCase( str ), m_pattern );\n                case WildcardAtBothEnds:\n                    return contains( adjustCase( str ), m_pattern );\n            }\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunreachable-code\"\n#endif\n            throw std::logic_error( \"Unknown enum\" );\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n        }\n    private:\n        std::string adjustCase( std::string const& str ) const {\n            return m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str;\n        }\n        CaseSensitive::Choice m_caseSensitivity;\n        WildcardPosition m_wildcard;\n        std::string m_pattern;\n    };\n}\n\n#include <string>\n#include <vector>\n\nnamespace Catch {\n\n    class TestSpec {\n        struct Pattern : SharedImpl<> {\n            virtual ~Pattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const = 0;\n        };\n        class NamePattern : public Pattern {\n        public:\n            NamePattern( std::string const& name )\n            : m_wildcardPattern( toLower( name ), CaseSensitive::No )\n            {}\n            virtual ~NamePattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const {\n                return m_wildcardPattern.matches( toLower( testCase.name ) );\n            }\n        private:\n            WildcardPattern m_wildcardPattern;\n        };\n\n        class TagPattern : public Pattern {\n        public:\n            TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}\n            virtual ~TagPattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const {\n                return testCase.lcaseTags.find( m_tag ) != testCase.lcaseTags.end();\n            }\n        private:\n            std::string m_tag;\n        };\n\n        class ExcludedPattern : public Pattern {\n        public:\n            ExcludedPattern( Ptr<Pattern> const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}\n            virtual ~ExcludedPattern();\n            virtual bool matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }\n        private:\n            Ptr<Pattern> m_underlyingPattern;\n        };\n\n        struct Filter {\n            std::vector<Ptr<Pattern> > m_patterns;\n\n            bool matches( TestCaseInfo const& testCase ) const {\n                // All patterns in a filter must match for the filter to be a match\n                for( std::vector<Ptr<Pattern> >::const_iterator it = m_patterns.begin(), itEnd = m_patterns.end(); it != itEnd; ++it ) {\n                    if( !(*it)->matches( testCase ) )\n                        return false;\n                }\n                return true;\n            }\n        };\n\n    public:\n        bool hasFilters() const {\n            return !m_filters.empty();\n        }\n        bool matches( TestCaseInfo const& testCase ) const {\n            // A TestSpec matches if any filter matches\n            for( std::vector<Filter>::const_iterator it = m_filters.begin(), itEnd = m_filters.end(); it != itEnd; ++it )\n                if( it->matches( testCase ) )\n                    return true;\n            return false;\n        }\n\n    private:\n        std::vector<Filter> m_filters;\n\n        friend class TestSpecParser;\n    };\n}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\nnamespace Catch {\n\n    class TestSpecParser {\n        enum Mode{ None, Name, QuotedName, Tag, EscapedName };\n        Mode m_mode;\n        bool m_exclusion;\n        std::size_t m_start, m_pos;\n        std::string m_arg;\n        std::vector<std::size_t> m_escapeChars;\n        TestSpec::Filter m_currentFilter;\n        TestSpec m_testSpec;\n        ITagAliasRegistry const* m_tagAliases;\n\n    public:\n        TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}\n\n        TestSpecParser& parse( std::string const& arg ) {\n            m_mode = None;\n            m_exclusion = false;\n            m_start = std::string::npos;\n            m_arg = m_tagAliases->expandAliases( arg );\n            m_escapeChars.clear();\n            for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\n                visitChar( m_arg[m_pos] );\n            if( m_mode == Name )\n                addPattern<TestSpec::NamePattern>();\n            return *this;\n        }\n        TestSpec testSpec() {\n            addFilter();\n            return m_testSpec;\n        }\n    private:\n        void visitChar( char c ) {\n            if( m_mode == None ) {\n                switch( c ) {\n                case ' ': return;\n                case '~': m_exclusion = true; return;\n                case '[': return startNewMode( Tag, ++m_pos );\n                case '\"': return startNewMode( QuotedName, ++m_pos );\n                case '\\\\': return escape();\n                default: startNewMode( Name, m_pos ); break;\n                }\n            }\n            if( m_mode == Name ) {\n                if( c == ',' ) {\n                    addPattern<TestSpec::NamePattern>();\n                    addFilter();\n                }\n                else if( c == '[' ) {\n                    if( subString() == \"exclude:\" )\n                        m_exclusion = true;\n                    else\n                        addPattern<TestSpec::NamePattern>();\n                    startNewMode( Tag, ++m_pos );\n                }\n                else if( c == '\\\\' )\n                    escape();\n            }\n            else if( m_mode == EscapedName )\n                m_mode = Name;\n            else if( m_mode == QuotedName && c == '\"' )\n                addPattern<TestSpec::NamePattern>();\n            else if( m_mode == Tag && c == ']' )\n                addPattern<TestSpec::TagPattern>();\n        }\n        void startNewMode( Mode mode, std::size_t start ) {\n            m_mode = mode;\n            m_start = start;\n        }\n        void escape() {\n            if( m_mode == None )\n                m_start = m_pos;\n            m_mode = EscapedName;\n            m_escapeChars.push_back( m_pos );\n        }\n        std::string subString() const { return m_arg.substr( m_start, m_pos - m_start ); }\n        template<typename T>\n        void addPattern() {\n            std::string token = subString();\n            for( size_t i = 0; i < m_escapeChars.size(); ++i )\n                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );\n            m_escapeChars.clear();\n            if( startsWith( token, \"exclude:\" ) ) {\n                m_exclusion = true;\n                token = token.substr( 8 );\n            }\n            if( !token.empty() ) {\n                Ptr<TestSpec::Pattern> pattern = new T( token );\n                if( m_exclusion )\n                    pattern = new TestSpec::ExcludedPattern( pattern );\n                m_currentFilter.m_patterns.push_back( pattern );\n            }\n            m_exclusion = false;\n            m_mode = None;\n        }\n        void addFilter() {\n            if( !m_currentFilter.m_patterns.empty() ) {\n                m_testSpec.m_filters.push_back( m_currentFilter );\n                m_currentFilter = TestSpec::Filter();\n            }\n        }\n    };\n    inline TestSpec parseTestSpec( std::string const& arg ) {\n        return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();\n    }\n\n} // namespace Catch\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n// #included from: catch_interfaces_config.h\n#define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED\n\n#include <iosfwd>\n#include <string>\n#include <vector>\n\nnamespace Catch {\n\n    struct Verbosity { enum Level {\n        NoOutput = 0,\n        Quiet,\n        Normal\n    }; };\n\n    struct WarnAbout { enum What {\n        Nothing = 0x00,\n        NoAssertions = 0x01\n    }; };\n\n    struct ShowDurations { enum OrNot {\n        DefaultForReporter,\n        Always,\n        Never\n    }; };\n    struct RunTests { enum InWhatOrder {\n        InDeclarationOrder,\n        InLexicographicalOrder,\n        InRandomOrder\n    }; };\n    struct UseColour { enum YesOrNo {\n        Auto,\n        Yes,\n        No\n    }; };\n\n    class TestSpec;\n\n    struct IConfig : IShared {\n\n        virtual ~IConfig();\n\n        virtual bool allowThrows() const = 0;\n        virtual std::ostream& stream() const = 0;\n        virtual std::string name() const = 0;\n        virtual bool includeSuccessfulResults() const = 0;\n        virtual bool shouldDebugBreak() const = 0;\n        virtual bool warnAboutMissingAssertions() const = 0;\n        virtual int abortAfter() const = 0;\n        virtual bool showInvisibles() const = 0;\n        virtual ShowDurations::OrNot showDurations() const = 0;\n        virtual TestSpec const& testSpec() const = 0;\n        virtual RunTests::InWhatOrder runOrder() const = 0;\n        virtual unsigned int rngSeed() const = 0;\n        virtual UseColour::YesOrNo useColour() const = 0;\n        virtual std::vector<std::string> const& getSectionsToRun() const = 0;\n\n    };\n}\n\n// #included from: catch_stream.h\n#define TWOBLUECUBES_CATCH_STREAM_H_INCLUDED\n\n// #included from: catch_streambuf.h\n#define TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED\n\n#include <streambuf>\n\nnamespace Catch {\n\n    class StreamBufBase : public std::streambuf {\n    public:\n        virtual ~StreamBufBase() CATCH_NOEXCEPT;\n    };\n}\n\n#include <streambuf>\n#include <ostream>\n#include <fstream>\n#include <memory>\n\nnamespace Catch {\n\n    std::ostream& cout();\n    std::ostream& cerr();\n\n    struct IStream {\n        virtual ~IStream() CATCH_NOEXCEPT;\n        virtual std::ostream& stream() const = 0;\n    };\n\n    class FileStream : public IStream {\n        mutable std::ofstream m_ofs;\n    public:\n        FileStream( std::string const& filename );\n        virtual ~FileStream() CATCH_NOEXCEPT;\n    public: // IStream\n        virtual std::ostream& stream() const CATCH_OVERRIDE;\n    };\n\n    class CoutStream : public IStream {\n        mutable std::ostream m_os;\n    public:\n        CoutStream();\n        virtual ~CoutStream() CATCH_NOEXCEPT;\n\n    public: // IStream\n        virtual std::ostream& stream() const CATCH_OVERRIDE;\n    };\n\n    class DebugOutStream : public IStream {\n        CATCH_AUTO_PTR( StreamBufBase ) m_streamBuf;\n        mutable std::ostream m_os;\n    public:\n        DebugOutStream();\n        virtual ~DebugOutStream() CATCH_NOEXCEPT;\n\n    public: // IStream\n        virtual std::ostream& stream() const CATCH_OVERRIDE;\n    };\n}\n\n#include <memory>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\n#ifndef CATCH_CONFIG_CONSOLE_WIDTH\n#define CATCH_CONFIG_CONSOLE_WIDTH 80\n#endif\n\nnamespace Catch {\n\n    struct ConfigData {\n\n        ConfigData()\n        :   listTests( false ),\n            listTags( false ),\n            listReporters( false ),\n            listTestNamesOnly( false ),\n            listExtraInfo( false ),\n            showSuccessfulTests( false ),\n            shouldDebugBreak( false ),\n            noThrow( false ),\n            showHelp( false ),\n            showInvisibles( false ),\n            filenamesAsTags( false ),\n            abortAfter( -1 ),\n            rngSeed( 0 ),\n            verbosity( Verbosity::Normal ),\n            warnings( WarnAbout::Nothing ),\n            showDurations( ShowDurations::DefaultForReporter ),\n            runOrder( RunTests::InDeclarationOrder ),\n            useColour( UseColour::Auto )\n        {}\n\n        bool listTests;\n        bool listTags;\n        bool listReporters;\n        bool listTestNamesOnly;\n        bool listExtraInfo;\n\n        bool showSuccessfulTests;\n        bool shouldDebugBreak;\n        bool noThrow;\n        bool showHelp;\n        bool showInvisibles;\n        bool filenamesAsTags;\n\n        int abortAfter;\n        unsigned int rngSeed;\n\n        Verbosity::Level verbosity;\n        WarnAbout::What warnings;\n        ShowDurations::OrNot showDurations;\n        RunTests::InWhatOrder runOrder;\n        UseColour::YesOrNo useColour;\n\n        std::string outputFilename;\n        std::string name;\n        std::string processName;\n\n        std::vector<std::string> reporterNames;\n        std::vector<std::string> testsOrTags;\n        std::vector<std::string> sectionsToRun;\n    };\n\n    class Config : public SharedImpl<IConfig> {\n    private:\n        Config( Config const& other );\n        Config& operator = ( Config const& other );\n        virtual void dummy();\n    public:\n\n        Config()\n        {}\n\n        Config( ConfigData const& data )\n        :   m_data( data ),\n            m_stream( openStream() )\n        {\n            if( !data.testsOrTags.empty() ) {\n                TestSpecParser parser( ITagAliasRegistry::get() );\n                for( std::size_t i = 0; i < data.testsOrTags.size(); ++i )\n                    parser.parse( data.testsOrTags[i] );\n                m_testSpec = parser.testSpec();\n            }\n        }\n\n        virtual ~Config() {}\n\n        std::string const& getFilename() const {\n            return m_data.outputFilename ;\n        }\n\n        bool listTests() const { return m_data.listTests; }\n        bool listTestNamesOnly() const { return m_data.listTestNamesOnly; }\n        bool listTags() const { return m_data.listTags; }\n        bool listReporters() const { return m_data.listReporters; }\n        bool listExtraInfo() const { return m_data.listExtraInfo; }\n\n        std::string getProcessName() const { return m_data.processName; }\n\n        std::vector<std::string> const& getReporterNames() const { return m_data.reporterNames; }\n        std::vector<std::string> const& getSectionsToRun() const CATCH_OVERRIDE { return m_data.sectionsToRun; }\n\n        virtual TestSpec const& testSpec() const CATCH_OVERRIDE { return m_testSpec; }\n\n        bool showHelp() const { return m_data.showHelp; }\n\n        // IConfig interface\n        virtual bool allowThrows() const CATCH_OVERRIDE                 { return !m_data.noThrow; }\n        virtual std::ostream& stream() const CATCH_OVERRIDE             { return m_stream->stream(); }\n        virtual std::string name() const CATCH_OVERRIDE                 { return m_data.name.empty() ? m_data.processName : m_data.name; }\n        virtual bool includeSuccessfulResults() const CATCH_OVERRIDE    { return m_data.showSuccessfulTests; }\n        virtual bool warnAboutMissingAssertions() const CATCH_OVERRIDE  { return m_data.warnings & WarnAbout::NoAssertions; }\n        virtual ShowDurations::OrNot showDurations() const CATCH_OVERRIDE { return m_data.showDurations; }\n        virtual RunTests::InWhatOrder runOrder() const CATCH_OVERRIDE   { return m_data.runOrder; }\n        virtual unsigned int rngSeed() const CATCH_OVERRIDE             { return m_data.rngSeed; }\n        virtual UseColour::YesOrNo useColour() const CATCH_OVERRIDE     { return m_data.useColour; }\n        virtual bool shouldDebugBreak() const CATCH_OVERRIDE { return m_data.shouldDebugBreak; }\n        virtual int abortAfter() const CATCH_OVERRIDE { return m_data.abortAfter; }\n        virtual bool showInvisibles() const CATCH_OVERRIDE { return m_data.showInvisibles; }\n\n    private:\n\n        IStream const* openStream() {\n            if( m_data.outputFilename.empty() )\n                return new CoutStream();\n            else if( m_data.outputFilename[0] == '%' ) {\n                if( m_data.outputFilename == \"%debug\" )\n                    return new DebugOutStream();\n                else\n                    throw std::domain_error( \"Unrecognised stream: \" + m_data.outputFilename );\n            }\n            else\n                return new FileStream( m_data.outputFilename );\n        }\n        ConfigData m_data;\n\n        CATCH_AUTO_PTR( IStream const ) m_stream;\n        TestSpec m_testSpec;\n    };\n\n} // end namespace Catch\n\n// #included from: catch_clara.h\n#define TWOBLUECUBES_CATCH_CLARA_H_INCLUDED\n\n// Use Catch's value for console width (store Clara's off to the side, if present)\n#ifdef CLARA_CONFIG_CONSOLE_WIDTH\n#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CLARA_CONFIG_CONSOLE_WIDTH\n#undef CLARA_CONFIG_CONSOLE_WIDTH\n#endif\n#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH\n\n// Declare Clara inside the Catch namespace\n#define STITCH_CLARA_OPEN_NAMESPACE namespace Catch {\n// #included from: ../external/clara.h\n\n// Version 0.0.2.4\n\n// Only use header guard if we are not using an outer namespace\n#if !defined(TWOBLUECUBES_CLARA_H_INCLUDED) || defined(STITCH_CLARA_OPEN_NAMESPACE)\n\n#ifndef STITCH_CLARA_OPEN_NAMESPACE\n#define TWOBLUECUBES_CLARA_H_INCLUDED\n#define STITCH_CLARA_OPEN_NAMESPACE\n#define STITCH_CLARA_CLOSE_NAMESPACE\n#else\n#define STITCH_CLARA_CLOSE_NAMESPACE }\n#endif\n\n#define STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE STITCH_CLARA_OPEN_NAMESPACE\n\n// ----------- #included from tbc_text_format.h -----------\n\n// Only use header guard if we are not using an outer namespace\n#if !defined(TBC_TEXT_FORMAT_H_INCLUDED) || defined(STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE)\n#ifndef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE\n#define TBC_TEXT_FORMAT_H_INCLUDED\n#endif\n\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <cctype>\n\n// Use optional outer namespace\n#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE\nnamespace STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE {\n#endif\n\nnamespace Tbc {\n\n#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH\n    const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;\n#else\n    const unsigned int consoleWidth = 80;\n#endif\n\n    struct TextAttributes {\n        TextAttributes()\n        :   initialIndent( std::string::npos ),\n            indent( 0 ),\n            width( consoleWidth-1 ),\n            tabChar( '\\t' )\n        {}\n\n        TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return *this; }\n        TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this; }\n        TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; }\n        TextAttributes& setTabChar( char _value )               { tabChar = _value; return *this; }\n\n        std::size_t initialIndent;  // indent of first line, or npos\n        std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos\n        std::size_t width;          // maximum width of text, including indent. Longer text will wrap\n        char tabChar;               // If this char is seen the indent is changed to current pos\n    };\n\n    class Text {\n    public:\n        Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() )\n        : attr( _attr )\n        {\n            std::string wrappableChars = \" [({.,/|\\\\-\";\n            std::size_t indent = _attr.initialIndent != std::string::npos\n                ? _attr.initialIndent\n                : _attr.indent;\n            std::string remainder = _str;\n\n            while( !remainder.empty() ) {\n                if( lines.size() >= 1000 ) {\n                    lines.push_back( \"... message truncated due to excessive size\" );\n                    return;\n                }\n                std::size_t tabPos = std::string::npos;\n                std::size_t width = (std::min)( remainder.size(), _attr.width - indent );\n                std::size_t pos = remainder.find_first_of( '\\n' );\n                if( pos <= width ) {\n                    width = pos;\n                }\n                pos = remainder.find_last_of( _attr.tabChar, width );\n                if( pos != std::string::npos ) {\n                    tabPos = pos;\n                    if( remainder[width] == '\\n' )\n                        width--;\n                    remainder = remainder.substr( 0, tabPos ) + remainder.substr( tabPos+1 );\n                }\n\n                if( width == remainder.size() ) {\n                    spliceLine( indent, remainder, width );\n                }\n                else if( remainder[width] == '\\n' ) {\n                    spliceLine( indent, remainder, width );\n                    if( width <= 1 || remainder.size() != 1 )\n                        remainder = remainder.substr( 1 );\n                    indent = _attr.indent;\n                }\n                else {\n                    pos = remainder.find_last_of( wrappableChars, width );\n                    if( pos != std::string::npos && pos > 0 ) {\n                        spliceLine( indent, remainder, pos );\n                        if( remainder[0] == ' ' )\n                            remainder = remainder.substr( 1 );\n                    }\n                    else {\n                        spliceLine( indent, remainder, width-1 );\n                        lines.back() += \"-\";\n                    }\n                    if( lines.size() == 1 )\n                        indent = _attr.indent;\n                    if( tabPos != std::string::npos )\n                        indent += tabPos;\n                }\n            }\n        }\n\n        void spliceLine( std::size_t _indent, std::string& _remainder, std::size_t _pos ) {\n            lines.push_back( std::string( _indent, ' ' ) + _remainder.substr( 0, _pos ) );\n            _remainder = _remainder.substr( _pos );\n        }\n\n        typedef std::vector<std::string>::const_iterator const_iterator;\n\n        const_iterator begin() const { return lines.begin(); }\n        const_iterator end() const { return lines.end(); }\n        std::string const& last() const { return lines.back(); }\n        std::size_t size() const { return lines.size(); }\n        std::string const& operator[]( std::size_t _index ) const { return lines[_index]; }\n        std::string toString() const {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n\n        inline friend std::ostream& operator << ( std::ostream& _stream, Text const& _text ) {\n            for( Text::const_iterator it = _text.begin(), itEnd = _text.end();\n                it != itEnd; ++it ) {\n                if( it != _text.begin() )\n                    _stream << \"\\n\";\n                _stream << *it;\n            }\n            return _stream;\n        }\n\n    private:\n        std::string str;\n        TextAttributes attr;\n        std::vector<std::string> lines;\n    };\n\n} // end namespace Tbc\n\n#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE\n} // end outer namespace\n#endif\n\n#endif // TBC_TEXT_FORMAT_H_INCLUDED\n\n// ----------- end of #include from tbc_text_format.h -----------\n// ........... back in clara.h\n\n#undef STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE\n\n// ----------- #included from clara_compilers.h -----------\n\n#ifndef TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED\n#define TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED\n\n// Detect a number of compiler features - mostly C++11/14 conformance - by compiler\n// The following features are defined:\n//\n// CLARA_CONFIG_CPP11_NULLPTR : is nullptr supported?\n// CLARA_CONFIG_CPP11_NOEXCEPT : is noexcept supported?\n// CLARA_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods\n// CLARA_CONFIG_CPP11_OVERRIDE : is override supported?\n// CLARA_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)\n\n// CLARA_CONFIG_CPP11_OR_GREATER : Is C++11 supported?\n\n// CLARA_CONFIG_VARIADIC_MACROS : are variadic macros supported?\n\n// In general each macro has a _NO_<feature name> form\n// (e.g. CLARA_CONFIG_CPP11_NO_NULLPTR) which disables the feature.\n// Many features, at point of detection, define an _INTERNAL_ macro, so they\n// can be combined, en-mass, with the _NO_ forms later.\n\n// All the C++11 features can be disabled with CLARA_CONFIG_NO_CPP11\n\n#ifdef __clang__\n\n#if __has_feature(cxx_nullptr)\n#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR\n#endif\n\n#if __has_feature(cxx_noexcept)\n#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT\n#endif\n\n#endif // __clang__\n\n////////////////////////////////////////////////////////////////////////////////\n// GCC\n#ifdef __GNUC__\n\n#if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)\n#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR\n#endif\n\n// - otherwise more recent versions define __cplusplus >= 201103L\n// and will get picked up below\n\n#endif // __GNUC__\n\n////////////////////////////////////////////////////////////////////////////////\n// Visual C++\n#ifdef _MSC_VER\n\n#if (_MSC_VER >= 1600)\n#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR\n#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR\n#endif\n\n#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))\n#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT\n#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS\n#endif\n\n#endif // _MSC_VER\n\n////////////////////////////////////////////////////////////////////////////////\n// C++ language feature support\n\n// catch all support for C++11\n#if defined(__cplusplus) && __cplusplus >= 201103L\n\n#define CLARA_CPP11_OR_GREATER\n\n#if !defined(CLARA_INTERNAL_CONFIG_CPP11_NULLPTR)\n#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR\n#endif\n\n#ifndef CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT\n#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT\n#endif\n\n#ifndef CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS\n#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS\n#endif\n\n#if !defined(CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE)\n#define CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE\n#endif\n#if !defined(CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)\n#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR\n#endif\n\n#endif // __cplusplus >= 201103L\n\n// Now set the actual defines based on the above + anything the user has configured\n#if defined(CLARA_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CLARA_CONFIG_CPP11_NO_NULLPTR) && !defined(CLARA_CONFIG_CPP11_NULLPTR) && !defined(CLARA_CONFIG_NO_CPP11)\n#define CLARA_CONFIG_CPP11_NULLPTR\n#endif\n#if defined(CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CLARA_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_CONFIG_NO_CPP11)\n#define CLARA_CONFIG_CPP11_NOEXCEPT\n#endif\n#if defined(CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CLARA_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CLARA_CONFIG_CPP11_GENERATED_METHODS) && !defined(CLARA_CONFIG_NO_CPP11)\n#define CLARA_CONFIG_CPP11_GENERATED_METHODS\n#endif\n#if defined(CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CLARA_CONFIG_NO_OVERRIDE) && !defined(CLARA_CONFIG_CPP11_OVERRIDE) && !defined(CLARA_CONFIG_NO_CPP11)\n#define CLARA_CONFIG_CPP11_OVERRIDE\n#endif\n#if defined(CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CLARA_CONFIG_NO_UNIQUE_PTR) && !defined(CLARA_CONFIG_CPP11_UNIQUE_PTR) && !defined(CLARA_CONFIG_NO_CPP11)\n#define CLARA_CONFIG_CPP11_UNIQUE_PTR\n#endif\n\n// noexcept support:\n#if defined(CLARA_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_NOEXCEPT)\n#define CLARA_NOEXCEPT noexcept\n#  define CLARA_NOEXCEPT_IS(x) noexcept(x)\n#else\n#define CLARA_NOEXCEPT throw()\n#  define CLARA_NOEXCEPT_IS(x)\n#endif\n\n// nullptr support\n#ifdef CLARA_CONFIG_CPP11_NULLPTR\n#define CLARA_NULL nullptr\n#else\n#define CLARA_NULL NULL\n#endif\n\n// override support\n#ifdef CLARA_CONFIG_CPP11_OVERRIDE\n#define CLARA_OVERRIDE override\n#else\n#define CLARA_OVERRIDE\n#endif\n\n// unique_ptr support\n#ifdef CLARA_CONFIG_CPP11_UNIQUE_PTR\n#   define CLARA_AUTO_PTR( T ) std::unique_ptr<T>\n#else\n#   define CLARA_AUTO_PTR( T ) std::auto_ptr<T>\n#endif\n\n#endif // TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED\n\n// ----------- end of #include from clara_compilers.h -----------\n// ........... back in clara.h\n\n#include <map>\n#include <stdexcept>\n#include <memory>\n\n#if defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)\n#define CLARA_PLATFORM_WINDOWS\n#endif\n\n// Use optional outer namespace\n#ifdef STITCH_CLARA_OPEN_NAMESPACE\nSTITCH_CLARA_OPEN_NAMESPACE\n#endif\n\nnamespace Clara {\n\n    struct UnpositionalTag {};\n\n    extern UnpositionalTag _;\n\n#ifdef CLARA_CONFIG_MAIN\n    UnpositionalTag _;\n#endif\n\n    namespace Detail {\n\n#ifdef CLARA_CONSOLE_WIDTH\n    const unsigned int consoleWidth = CLARA_CONFIG_CONSOLE_WIDTH;\n#else\n    const unsigned int consoleWidth = 80;\n#endif\n\n        using namespace Tbc;\n\n        inline bool startsWith( std::string const& str, std::string const& prefix ) {\n            return str.size() >= prefix.size() && str.substr( 0, prefix.size() ) == prefix;\n        }\n\n        template<typename T> struct RemoveConstRef{ typedef T type; };\n        template<typename T> struct RemoveConstRef<T&>{ typedef T type; };\n        template<typename T> struct RemoveConstRef<T const&>{ typedef T type; };\n        template<typename T> struct RemoveConstRef<T const>{ typedef T type; };\n\n        template<typename T>    struct IsBool       { static const bool value = false; };\n        template<>              struct IsBool<bool> { static const bool value = true; };\n\n        template<typename T>\n        void convertInto( std::string const& _source, T& _dest ) {\n            std::stringstream ss;\n            ss << _source;\n            ss >> _dest;\n            if( ss.fail() )\n                throw std::runtime_error( \"Unable to convert \" + _source + \" to destination type\" );\n        }\n        inline void convertInto( std::string const& _source, std::string& _dest ) {\n            _dest = _source;\n        }\n        char toLowerCh(char c) {\n            return static_cast<char>( std::tolower( c ) );\n        }\n        inline void convertInto( std::string const& _source, bool& _dest ) {\n            std::string sourceLC = _source;\n            std::transform( sourceLC.begin(), sourceLC.end(), sourceLC.begin(), toLowerCh );\n            if( sourceLC == \"y\" || sourceLC == \"1\" || sourceLC == \"true\" || sourceLC == \"yes\" || sourceLC == \"on\" )\n                _dest = true;\n            else if( sourceLC == \"n\" || sourceLC == \"0\" || sourceLC == \"false\" || sourceLC == \"no\" || sourceLC == \"off\" )\n                _dest = false;\n            else\n                throw std::runtime_error( \"Expected a boolean value but did not recognise:\\n  '\" + _source + \"'\" );\n        }\n\n        template<typename ConfigT>\n        struct IArgFunction {\n            virtual ~IArgFunction() {}\n#ifdef CLARA_CONFIG_CPP11_GENERATED_METHODS\n            IArgFunction()                      = default;\n            IArgFunction( IArgFunction const& ) = default;\n#endif\n            virtual void set( ConfigT& config, std::string const& value ) const = 0;\n            virtual bool takesArg() const = 0;\n            virtual IArgFunction* clone() const = 0;\n        };\n\n        template<typename ConfigT>\n        class BoundArgFunction {\n        public:\n            BoundArgFunction() : functionObj( CLARA_NULL ) {}\n            BoundArgFunction( IArgFunction<ConfigT>* _functionObj ) : functionObj( _functionObj ) {}\n            BoundArgFunction( BoundArgFunction const& other ) : functionObj( other.functionObj ? other.functionObj->clone() : CLARA_NULL ) {}\n            BoundArgFunction& operator = ( BoundArgFunction const& other ) {\n                IArgFunction<ConfigT>* newFunctionObj = other.functionObj ? other.functionObj->clone() : CLARA_NULL;\n                delete functionObj;\n                functionObj = newFunctionObj;\n                return *this;\n            }\n            ~BoundArgFunction() { delete functionObj; }\n\n            void set( ConfigT& config, std::string const& value ) const {\n                functionObj->set( config, value );\n            }\n            bool takesArg() const { return functionObj->takesArg(); }\n\n            bool isSet() const {\n                return functionObj != CLARA_NULL;\n            }\n        private:\n            IArgFunction<ConfigT>* functionObj;\n        };\n\n        template<typename C>\n        struct NullBinder : IArgFunction<C>{\n            virtual void set( C&, std::string const& ) const {}\n            virtual bool takesArg() const { return true; }\n            virtual IArgFunction<C>* clone() const { return new NullBinder( *this ); }\n        };\n\n        template<typename C, typename M>\n        struct BoundDataMember : IArgFunction<C>{\n            BoundDataMember( M C::* _member ) : member( _member ) {}\n            virtual void set( C& p, std::string const& stringValue ) const {\n                convertInto( stringValue, p.*member );\n            }\n            virtual bool takesArg() const { return !IsBool<M>::value; }\n            virtual IArgFunction<C>* clone() const { return new BoundDataMember( *this ); }\n            M C::* member;\n        };\n        template<typename C, typename M>\n        struct BoundUnaryMethod : IArgFunction<C>{\n            BoundUnaryMethod( void (C::*_member)( M ) ) : member( _member ) {}\n            virtual void set( C& p, std::string const& stringValue ) const {\n                typename RemoveConstRef<M>::type value;\n                convertInto( stringValue, value );\n                (p.*member)( value );\n            }\n            virtual bool takesArg() const { return !IsBool<M>::value; }\n            virtual IArgFunction<C>* clone() const { return new BoundUnaryMethod( *this ); }\n            void (C::*member)( M );\n        };\n        template<typename C>\n        struct BoundNullaryMethod : IArgFunction<C>{\n            BoundNullaryMethod( void (C::*_member)() ) : member( _member ) {}\n            virtual void set( C& p, std::string const& stringValue ) const {\n                bool value;\n                convertInto( stringValue, value );\n                if( value )\n                    (p.*member)();\n            }\n            virtual bool takesArg() const { return false; }\n            virtual IArgFunction<C>* clone() const { return new BoundNullaryMethod( *this ); }\n            void (C::*member)();\n        };\n\n        template<typename C>\n        struct BoundUnaryFunction : IArgFunction<C>{\n            BoundUnaryFunction( void (*_function)( C& ) ) : function( _function ) {}\n            virtual void set( C& obj, std::string const& stringValue ) const {\n                bool value;\n                convertInto( stringValue, value );\n                if( value )\n                    function( obj );\n            }\n            virtual bool takesArg() const { return false; }\n            virtual IArgFunction<C>* clone() const { return new BoundUnaryFunction( *this ); }\n            void (*function)( C& );\n        };\n\n        template<typename C, typename T>\n        struct BoundBinaryFunction : IArgFunction<C>{\n            BoundBinaryFunction( void (*_function)( C&, T ) ) : function( _function ) {}\n            virtual void set( C& obj, std::string const& stringValue ) const {\n                typename RemoveConstRef<T>::type value;\n                convertInto( stringValue, value );\n                function( obj, value );\n            }\n            virtual bool takesArg() const { return !IsBool<T>::value; }\n            virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction( *this ); }\n            void (*function)( C&, T );\n        };\n\n    } // namespace Detail\n\n    inline std::vector<std::string> argsToVector( int argc, char const* const* const argv ) {\n        std::vector<std::string> args( static_cast<std::size_t>( argc ) );\n        for( std::size_t i = 0; i < static_cast<std::size_t>( argc ); ++i )\n            args[i] = argv[i];\n\n        return args;\n    }\n\n    class Parser {\n        enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };\n        Mode mode;\n        std::size_t from;\n        bool inQuotes;\n    public:\n\n        struct Token {\n            enum Type { Positional, ShortOpt, LongOpt };\n            Token( Type _type, std::string const& _data ) : type( _type ), data( _data ) {}\n            Type type;\n            std::string data;\n        };\n\n        Parser() : mode( None ), from( 0 ), inQuotes( false ){}\n\n        void parseIntoTokens( std::vector<std::string> const& args, std::vector<Token>& tokens ) {\n            const std::string doubleDash = \"--\";\n            for( std::size_t i = 1; i < args.size() && args[i] != doubleDash; ++i )\n                parseIntoTokens( args[i], tokens);\n        }\n\n        void parseIntoTokens( std::string const& arg, std::vector<Token>& tokens ) {\n            for( std::size_t i = 0; i < arg.size(); ++i ) {\n                char c = arg[i];\n                if( c == '\"' )\n                    inQuotes = !inQuotes;\n                mode = handleMode( i, c, arg, tokens );\n            }\n            mode = handleMode( arg.size(), '\\0', arg, tokens );\n        }\n        Mode handleMode( std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens ) {\n            switch( mode ) {\n                case None: return handleNone( i, c );\n                case MaybeShortOpt: return handleMaybeShortOpt( i, c );\n                case ShortOpt:\n                case LongOpt:\n                case SlashOpt: return handleOpt( i, c, arg, tokens );\n                case Positional: return handlePositional( i, c, arg, tokens );\n                default: throw std::logic_error( \"Unknown mode\" );\n            }\n        }\n\n        Mode handleNone( std::size_t i, char c ) {\n            if( inQuotes ) {\n                from = i;\n                return Positional;\n            }\n            switch( c ) {\n                case '-': return MaybeShortOpt;\n#ifdef CLARA_PLATFORM_WINDOWS\n                case '/': from = i+1; return SlashOpt;\n#endif\n                default: from = i; return Positional;\n            }\n        }\n        Mode handleMaybeShortOpt( std::size_t i, char c ) {\n            switch( c ) {\n                case '-': from = i+1; return LongOpt;\n                default: from = i; return ShortOpt;\n            }\n        }\n\n        Mode handleOpt( std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens ) {\n            if( std::string( \":=\\0\", 3 ).find( c ) == std::string::npos )\n                return mode;\n\n            std::string optName = arg.substr( from, i-from );\n            if( mode == ShortOpt )\n                for( std::size_t j = 0; j < optName.size(); ++j )\n                    tokens.push_back( Token( Token::ShortOpt, optName.substr( j, 1 ) ) );\n            else if( mode == SlashOpt && optName.size() == 1 )\n                tokens.push_back( Token( Token::ShortOpt, optName ) );\n            else\n                tokens.push_back( Token( Token::LongOpt, optName ) );\n            return None;\n        }\n        Mode handlePositional( std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens ) {\n            if( inQuotes || std::string( \"\\0\", 1 ).find( c ) == std::string::npos )\n                return mode;\n\n            std::string data = arg.substr( from, i-from );\n            tokens.push_back( Token( Token::Positional, data ) );\n            return None;\n        }\n    };\n\n    template<typename ConfigT>\n    struct CommonArgProperties {\n        CommonArgProperties() {}\n        CommonArgProperties( Detail::BoundArgFunction<ConfigT> const& _boundField ) : boundField( _boundField ) {}\n\n        Detail::BoundArgFunction<ConfigT> boundField;\n        std::string description;\n        std::string detail;\n        std::string placeholder; // Only value if boundField takes an arg\n\n        bool takesArg() const {\n            return !placeholder.empty();\n        }\n        void validate() const {\n            if( !boundField.isSet() )\n                throw std::logic_error( \"option not bound\" );\n        }\n    };\n    struct OptionArgProperties {\n        std::vector<std::string> shortNames;\n        std::string longName;\n\n        bool hasShortName( std::string const& shortName ) const {\n            return std::find( shortNames.begin(), shortNames.end(), shortName ) != shortNames.end();\n        }\n        bool hasLongName( std::string const& _longName ) const {\n            return _longName == longName;\n        }\n    };\n    struct PositionalArgProperties {\n        PositionalArgProperties() : position( -1 ) {}\n        int position; // -1 means non-positional (floating)\n\n        bool isFixedPositional() const {\n            return position != -1;\n        }\n    };\n\n    template<typename ConfigT>\n    class CommandLine {\n\n        struct Arg : CommonArgProperties<ConfigT>, OptionArgProperties, PositionalArgProperties {\n            Arg() {}\n            Arg( Detail::BoundArgFunction<ConfigT> const& _boundField ) : CommonArgProperties<ConfigT>( _boundField ) {}\n\n            using CommonArgProperties<ConfigT>::placeholder; // !TBD\n\n            std::string dbgName() const {\n                if( !longName.empty() )\n                    return \"--\" + longName;\n                if( !shortNames.empty() )\n                    return \"-\" + shortNames[0];\n                return \"positional args\";\n            }\n            std::string commands() const {\n                std::ostringstream oss;\n                bool first = true;\n                std::vector<std::string>::const_iterator it = shortNames.begin(), itEnd = shortNames.end();\n                for(; it != itEnd; ++it ) {\n                    if( first )\n                        first = false;\n                    else\n                        oss << \", \";\n                    oss << \"-\" << *it;\n                }\n                if( !longName.empty() ) {\n                    if( !first )\n                        oss << \", \";\n                    oss << \"--\" << longName;\n                }\n                if( !placeholder.empty() )\n                    oss << \" <\" << placeholder << \">\";\n                return oss.str();\n            }\n        };\n\n        typedef CLARA_AUTO_PTR( Arg ) ArgAutoPtr;\n\n        friend void addOptName( Arg& arg, std::string const& optName )\n        {\n            if( optName.empty() )\n                return;\n            if( Detail::startsWith( optName, \"--\" ) ) {\n                if( !arg.longName.empty() )\n                    throw std::logic_error( \"Only one long opt may be specified. '\"\n                        + arg.longName\n                        + \"' already specified, now attempting to add '\"\n                        + optName + \"'\" );\n                arg.longName = optName.substr( 2 );\n            }\n            else if( Detail::startsWith( optName, \"-\" ) )\n                arg.shortNames.push_back( optName.substr( 1 ) );\n            else\n                throw std::logic_error( \"option must begin with - or --. Option was: '\" + optName + \"'\" );\n        }\n        friend void setPositionalArg( Arg& arg, int position )\n        {\n            arg.position = position;\n        }\n\n        class ArgBuilder {\n        public:\n            ArgBuilder( Arg* arg ) : m_arg( arg ) {}\n\n            // Bind a non-boolean data member (requires placeholder string)\n            template<typename C, typename M>\n            void bind( M C::* field, std::string const& placeholder ) {\n                m_arg->boundField = new Detail::BoundDataMember<C,M>( field );\n                m_arg->placeholder = placeholder;\n            }\n            // Bind a boolean data member (no placeholder required)\n            template<typename C>\n            void bind( bool C::* field ) {\n                m_arg->boundField = new Detail::BoundDataMember<C,bool>( field );\n            }\n\n            // Bind a method taking a single, non-boolean argument (requires a placeholder string)\n            template<typename C, typename M>\n            void bind( void (C::* unaryMethod)( M ), std::string const& placeholder ) {\n                m_arg->boundField = new Detail::BoundUnaryMethod<C,M>( unaryMethod );\n                m_arg->placeholder = placeholder;\n            }\n\n            // Bind a method taking a single, boolean argument (no placeholder string required)\n            template<typename C>\n            void bind( void (C::* unaryMethod)( bool ) ) {\n                m_arg->boundField = new Detail::BoundUnaryMethod<C,bool>( unaryMethod );\n            }\n\n            // Bind a method that takes no arguments (will be called if opt is present)\n            template<typename C>\n            void bind( void (C::* nullaryMethod)() ) {\n                m_arg->boundField = new Detail::BoundNullaryMethod<C>( nullaryMethod );\n            }\n\n            // Bind a free function taking a single argument - the object to operate on (no placeholder string required)\n            template<typename C>\n            void bind( void (* unaryFunction)( C& ) ) {\n                m_arg->boundField = new Detail::BoundUnaryFunction<C>( unaryFunction );\n            }\n\n            // Bind a free function taking a single argument - the object to operate on (requires a placeholder string)\n            template<typename C, typename T>\n            void bind( void (* binaryFunction)( C&, T ), std::string const& placeholder ) {\n                m_arg->boundField = new Detail::BoundBinaryFunction<C, T>( binaryFunction );\n                m_arg->placeholder = placeholder;\n            }\n\n            ArgBuilder& describe( std::string const& description ) {\n                m_arg->description = description;\n                return *this;\n            }\n            ArgBuilder& detail( std::string const& detail ) {\n                m_arg->detail = detail;\n                return *this;\n            }\n\n        protected:\n            Arg* m_arg;\n        };\n\n        class OptBuilder : public ArgBuilder {\n        public:\n            OptBuilder( Arg* arg ) : ArgBuilder( arg ) {}\n            OptBuilder( OptBuilder& other ) : ArgBuilder( other ) {}\n\n            OptBuilder& operator[]( std::string const& optName ) {\n                addOptName( *ArgBuilder::m_arg, optName );\n                return *this;\n            }\n        };\n\n    public:\n\n        CommandLine()\n        :   m_boundProcessName( new Detail::NullBinder<ConfigT>() ),\n            m_highestSpecifiedArgPosition( 0 ),\n            m_throwOnUnrecognisedTokens( false )\n        {}\n        CommandLine( CommandLine const& other )\n        :   m_boundProcessName( other.m_boundProcessName ),\n            m_options ( other.m_options ),\n            m_positionalArgs( other.m_positionalArgs ),\n            m_highestSpecifiedArgPosition( other.m_highestSpecifiedArgPosition ),\n            m_throwOnUnrecognisedTokens( other.m_throwOnUnrecognisedTokens )\n        {\n            if( other.m_floatingArg.get() )\n                m_floatingArg.reset( new Arg( *other.m_floatingArg ) );\n        }\n\n        CommandLine& setThrowOnUnrecognisedTokens( bool shouldThrow = true ) {\n            m_throwOnUnrecognisedTokens = shouldThrow;\n            return *this;\n        }\n\n        OptBuilder operator[]( std::string const& optName ) {\n            m_options.push_back( Arg() );\n            addOptName( m_options.back(), optName );\n            OptBuilder builder( &m_options.back() );\n            return builder;\n        }\n\n        ArgBuilder operator[]( int position ) {\n            m_positionalArgs.insert( std::make_pair( position, Arg() ) );\n            if( position > m_highestSpecifiedArgPosition )\n                m_highestSpecifiedArgPosition = position;\n            setPositionalArg( m_positionalArgs[position], position );\n            ArgBuilder builder( &m_positionalArgs[position] );\n            return builder;\n        }\n\n        // Invoke this with the _ instance\n        ArgBuilder operator[]( UnpositionalTag ) {\n            if( m_floatingArg.get() )\n                throw std::logic_error( \"Only one unpositional argument can be added\" );\n            m_floatingArg.reset( new Arg() );\n            ArgBuilder builder( m_floatingArg.get() );\n            return builder;\n        }\n\n        template<typename C, typename M>\n        void bindProcessName( M C::* field ) {\n            m_boundProcessName = new Detail::BoundDataMember<C,M>( field );\n        }\n        template<typename C, typename M>\n        void bindProcessName( void (C::*_unaryMethod)( M ) ) {\n            m_boundProcessName = new Detail::BoundUnaryMethod<C,M>( _unaryMethod );\n        }\n\n        void optUsage( std::ostream& os, std::size_t indent = 0, std::size_t width = Detail::consoleWidth ) const {\n            typename std::vector<Arg>::const_iterator itBegin = m_options.begin(), itEnd = m_options.end(), it;\n            std::size_t maxWidth = 0;\n            for( it = itBegin; it != itEnd; ++it )\n                maxWidth = (std::max)( maxWidth, it->commands().size() );\n\n            for( it = itBegin; it != itEnd; ++it ) {\n                Detail::Text usage( it->commands(), Detail::TextAttributes()\n                                                        .setWidth( maxWidth+indent )\n                                                        .setIndent( indent ) );\n                Detail::Text desc( it->description, Detail::TextAttributes()\n                                                        .setWidth( width - maxWidth - 3 ) );\n\n                for( std::size_t i = 0; i < (std::max)( usage.size(), desc.size() ); ++i ) {\n                    std::string usageCol = i < usage.size() ? usage[i] : \"\";\n                    os << usageCol;\n\n                    if( i < desc.size() && !desc[i].empty() )\n                        os  << std::string( indent + 2 + maxWidth - usageCol.size(), ' ' )\n                            << desc[i];\n                    os << \"\\n\";\n                }\n            }\n        }\n        std::string optUsage() const {\n            std::ostringstream oss;\n            optUsage( oss );\n            return oss.str();\n        }\n\n        void argSynopsis( std::ostream& os ) const {\n            for( int i = 1; i <= m_highestSpecifiedArgPosition; ++i ) {\n                if( i > 1 )\n                    os << \" \";\n                typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find( i );\n                if( it != m_positionalArgs.end() )\n                    os << \"<\" << it->second.placeholder << \">\";\n                else if( m_floatingArg.get() )\n                    os << \"<\" << m_floatingArg->placeholder << \">\";\n                else\n                    throw std::logic_error( \"non consecutive positional arguments with no floating args\" );\n            }\n            // !TBD No indication of mandatory args\n            if( m_floatingArg.get() ) {\n                if( m_highestSpecifiedArgPosition > 1 )\n                    os << \" \";\n                os << \"[<\" << m_floatingArg->placeholder << \"> ...]\";\n            }\n        }\n        std::string argSynopsis() const {\n            std::ostringstream oss;\n            argSynopsis( oss );\n            return oss.str();\n        }\n\n        void usage( std::ostream& os, std::string const& procName ) const {\n            validate();\n            os << \"usage:\\n  \" << procName << \" \";\n            argSynopsis( os );\n            if( !m_options.empty() ) {\n                os << \" [options]\\n\\nwhere options are: \\n\";\n                optUsage( os, 2 );\n            }\n            os << \"\\n\";\n        }\n        std::string usage( std::string const& procName ) const {\n            std::ostringstream oss;\n            usage( oss, procName );\n            return oss.str();\n        }\n\n        ConfigT parse( std::vector<std::string> const& args ) const {\n            ConfigT config;\n            parseInto( args, config );\n            return config;\n        }\n\n        std::vector<Parser::Token> parseInto( std::vector<std::string> const& args, ConfigT& config ) const {\n            std::string processName = args.empty() ? std::string() : args[0];\n            std::size_t lastSlash = processName.find_last_of( \"/\\\\\" );\n            if( lastSlash != std::string::npos )\n                processName = processName.substr( lastSlash+1 );\n            m_boundProcessName.set( config, processName );\n            std::vector<Parser::Token> tokens;\n            Parser parser;\n            parser.parseIntoTokens( args, tokens );\n            return populate( tokens, config );\n        }\n\n        std::vector<Parser::Token> populate( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {\n            validate();\n            std::vector<Parser::Token> unusedTokens = populateOptions( tokens, config );\n            unusedTokens = populateFixedArgs( unusedTokens, config );\n            unusedTokens = populateFloatingArgs( unusedTokens, config );\n            return unusedTokens;\n        }\n\n        std::vector<Parser::Token> populateOptions( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {\n            std::vector<Parser::Token> unusedTokens;\n            std::vector<std::string> errors;\n            for( std::size_t i = 0; i < tokens.size(); ++i ) {\n                Parser::Token const& token = tokens[i];\n                typename std::vector<Arg>::const_iterator it = m_options.begin(), itEnd = m_options.end();\n                for(; it != itEnd; ++it ) {\n                    Arg const& arg = *it;\n\n                    try {\n                        if( ( token.type == Parser::Token::ShortOpt && arg.hasShortName( token.data ) ) ||\n                            ( token.type == Parser::Token::LongOpt && arg.hasLongName( token.data ) ) ) {\n                            if( arg.takesArg() ) {\n                                if( i == tokens.size()-1 || tokens[i+1].type != Parser::Token::Positional )\n                                    errors.push_back( \"Expected argument to option: \" + token.data );\n                                else\n                                    arg.boundField.set( config, tokens[++i].data );\n                            }\n                            else {\n                                arg.boundField.set( config, \"true\" );\n                            }\n                            break;\n                        }\n                    }\n                    catch( std::exception& ex ) {\n                        errors.push_back( std::string( ex.what() ) + \"\\n- while parsing: (\" + arg.commands() + \")\" );\n                    }\n                }\n                if( it == itEnd ) {\n                    if( token.type == Parser::Token::Positional || !m_throwOnUnrecognisedTokens )\n                        unusedTokens.push_back( token );\n                    else if( errors.empty() && m_throwOnUnrecognisedTokens )\n                        errors.push_back( \"unrecognised option: \" + token.data );\n                }\n            }\n            if( !errors.empty() ) {\n                std::ostringstream oss;\n                for( std::vector<std::string>::const_iterator it = errors.begin(), itEnd = errors.end();\n                        it != itEnd;\n                        ++it ) {\n                    if( it != errors.begin() )\n                        oss << \"\\n\";\n                    oss << *it;\n                }\n                throw std::runtime_error( oss.str() );\n            }\n            return unusedTokens;\n        }\n        std::vector<Parser::Token> populateFixedArgs( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {\n            std::vector<Parser::Token> unusedTokens;\n            int position = 1;\n            for( std::size_t i = 0; i < tokens.size(); ++i ) {\n                Parser::Token const& token = tokens[i];\n                typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find( position );\n                if( it != m_positionalArgs.end() )\n                    it->second.boundField.set( config, token.data );\n                else\n                    unusedTokens.push_back( token );\n                if( token.type == Parser::Token::Positional )\n                    position++;\n            }\n            return unusedTokens;\n        }\n        std::vector<Parser::Token> populateFloatingArgs( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {\n            if( !m_floatingArg.get() )\n                return tokens;\n            std::vector<Parser::Token> unusedTokens;\n            for( std::size_t i = 0; i < tokens.size(); ++i ) {\n                Parser::Token const& token = tokens[i];\n                if( token.type == Parser::Token::Positional )\n                    m_floatingArg->boundField.set( config, token.data );\n                else\n                    unusedTokens.push_back( token );\n            }\n            return unusedTokens;\n        }\n\n        void validate() const\n        {\n            if( m_options.empty() && m_positionalArgs.empty() && !m_floatingArg.get() )\n                throw std::logic_error( \"No options or arguments specified\" );\n\n            for( typename std::vector<Arg>::const_iterator  it = m_options.begin(),\n                                                            itEnd = m_options.end();\n                    it != itEnd; ++it )\n                it->validate();\n        }\n\n    private:\n        Detail::BoundArgFunction<ConfigT> m_boundProcessName;\n        std::vector<Arg> m_options;\n        std::map<int, Arg> m_positionalArgs;\n        ArgAutoPtr m_floatingArg;\n        int m_highestSpecifiedArgPosition;\n        bool m_throwOnUnrecognisedTokens;\n    };\n\n} // end namespace Clara\n\nSTITCH_CLARA_CLOSE_NAMESPACE\n#undef STITCH_CLARA_OPEN_NAMESPACE\n#undef STITCH_CLARA_CLOSE_NAMESPACE\n\n#endif // TWOBLUECUBES_CLARA_H_INCLUDED\n#undef STITCH_CLARA_OPEN_NAMESPACE\n\n// Restore Clara's value for console width, if present\n#ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH\n#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH\n#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH\n#endif\n\n#include <fstream>\n#include <ctime>\n\nnamespace Catch {\n\n    inline void abortAfterFirst( ConfigData& config ) { config.abortAfter = 1; }\n    inline void abortAfterX( ConfigData& config, int x ) {\n        if( x < 1 )\n            throw std::runtime_error( \"Value after -x or --abortAfter must be greater than zero\" );\n        config.abortAfter = x;\n    }\n    inline void addTestOrTags( ConfigData& config, std::string const& _testSpec ) { config.testsOrTags.push_back( _testSpec ); }\n    inline void addSectionToRun( ConfigData& config, std::string const& sectionName ) { config.sectionsToRun.push_back( sectionName ); }\n    inline void addReporterName( ConfigData& config, std::string const& _reporterName ) { config.reporterNames.push_back( _reporterName ); }\n\n    inline void addWarning( ConfigData& config, std::string const& _warning ) {\n        if( _warning == \"NoAssertions\" )\n            config.warnings = static_cast<WarnAbout::What>( config.warnings | WarnAbout::NoAssertions );\n        else\n            throw std::runtime_error( \"Unrecognised warning: '\" + _warning + '\\'' );\n    }\n    inline void setOrder( ConfigData& config, std::string const& order ) {\n        if( startsWith( \"declared\", order ) )\n            config.runOrder = RunTests::InDeclarationOrder;\n        else if( startsWith( \"lexical\", order ) )\n            config.runOrder = RunTests::InLexicographicalOrder;\n        else if( startsWith( \"random\", order ) )\n            config.runOrder = RunTests::InRandomOrder;\n        else\n            throw std::runtime_error( \"Unrecognised ordering: '\" + order + '\\'' );\n    }\n    inline void setRngSeed( ConfigData& config, std::string const& seed ) {\n        if( seed == \"time\" ) {\n            config.rngSeed = static_cast<unsigned int>( std::time(0) );\n        }\n        else {\n            std::stringstream ss;\n            ss << seed;\n            ss >> config.rngSeed;\n            if( ss.fail() )\n                throw std::runtime_error( \"Argument to --rng-seed should be the word 'time' or a number\" );\n        }\n    }\n    inline void setVerbosity( ConfigData& config, int level ) {\n        // !TBD: accept strings?\n        config.verbosity = static_cast<Verbosity::Level>( level );\n    }\n    inline void setShowDurations( ConfigData& config, bool _showDurations ) {\n        config.showDurations = _showDurations\n            ? ShowDurations::Always\n            : ShowDurations::Never;\n    }\n    inline void setUseColour( ConfigData& config, std::string const& value ) {\n        std::string mode = toLower( value );\n\n        if( mode == \"yes\" )\n            config.useColour = UseColour::Yes;\n        else if( mode == \"no\" )\n            config.useColour = UseColour::No;\n        else if( mode == \"auto\" )\n            config.useColour = UseColour::Auto;\n        else\n            throw std::runtime_error( \"colour mode must be one of: auto, yes or no\" );\n    }\n    inline void forceColour( ConfigData& config ) {\n        config.useColour = UseColour::Yes;\n    }\n    inline void loadTestNamesFromFile( ConfigData& config, std::string const& _filename ) {\n        std::ifstream f( _filename.c_str() );\n        if( !f.is_open() )\n            throw std::domain_error( \"Unable to load input file: \" + _filename );\n\n        std::string line;\n        while( std::getline( f, line ) ) {\n            line = trim(line);\n            if( !line.empty() && !startsWith( line, '#' ) ) {\n                if( !startsWith( line, '\"' ) )\n                    line = '\"' + line + '\"';\n                addTestOrTags( config, line + ',' );\n            }\n        }\n    }\n\n    inline Clara::CommandLine<ConfigData> makeCommandLineParser() {\n\n        using namespace Clara;\n        CommandLine<ConfigData> cli;\n\n        cli.bindProcessName( &ConfigData::processName );\n\n        cli[\"-?\"][\"-h\"][\"--help\"]\n            .describe( \"display usage information\" )\n            .bind( &ConfigData::showHelp );\n\n        cli[\"-l\"][\"--list-tests\"]\n            .describe( \"list all/matching test cases\" )\n            .bind( &ConfigData::listTests );\n\n        cli[\"-t\"][\"--list-tags\"]\n            .describe( \"list all/matching tags\" )\n            .bind( &ConfigData::listTags );\n\n        cli[\"-s\"][\"--success\"]\n            .describe( \"include successful tests in output\" )\n            .bind( &ConfigData::showSuccessfulTests );\n\n        cli[\"-b\"][\"--break\"]\n            .describe( \"break into debugger on failure\" )\n            .bind( &ConfigData::shouldDebugBreak );\n\n        cli[\"-e\"][\"--nothrow\"]\n            .describe( \"skip exception tests\" )\n            .bind( &ConfigData::noThrow );\n\n        cli[\"-i\"][\"--invisibles\"]\n            .describe( \"show invisibles (tabs, newlines)\" )\n            .bind( &ConfigData::showInvisibles );\n\n        cli[\"-o\"][\"--out\"]\n            .describe( \"output filename\" )\n            .bind( &ConfigData::outputFilename, \"filename\" );\n\n        cli[\"-r\"][\"--reporter\"]\n//            .placeholder( \"name[:filename]\" )\n            .describe( \"reporter to use (defaults to console)\" )\n            .bind( &addReporterName, \"name\" );\n\n        cli[\"-n\"][\"--name\"]\n            .describe( \"suite name\" )\n            .bind( &ConfigData::name, \"name\" );\n\n        cli[\"-a\"][\"--abort\"]\n            .describe( \"abort at first failure\" )\n            .bind( &abortAfterFirst );\n\n        cli[\"-x\"][\"--abortx\"]\n            .describe( \"abort after x failures\" )\n            .bind( &abortAfterX, \"no. failures\" );\n\n        cli[\"-w\"][\"--warn\"]\n            .describe( \"enable warnings\" )\n            .bind( &addWarning, \"warning name\" );\n\n// - needs updating if reinstated\n//        cli.into( &setVerbosity )\n//            .describe( \"level of verbosity (0=no output)\" )\n//            .shortOpt( \"v\")\n//            .longOpt( \"verbosity\" )\n//            .placeholder( \"level\" );\n\n        cli[_]\n            .describe( \"which test or tests to use\" )\n            .bind( &addTestOrTags, \"test name, pattern or tags\" );\n\n        cli[\"-d\"][\"--durations\"]\n            .describe( \"show test durations\" )\n            .bind( &setShowDurations, \"yes|no\" );\n\n        cli[\"-f\"][\"--input-file\"]\n            .describe( \"load test names to run from a file\" )\n            .bind( &loadTestNamesFromFile, \"filename\" );\n\n        cli[\"-#\"][\"--filenames-as-tags\"]\n            .describe( \"adds a tag for the filename\" )\n            .bind( &ConfigData::filenamesAsTags );\n\n        cli[\"-c\"][\"--section\"]\n                .describe( \"specify section to run\" )\n                .bind( &addSectionToRun, \"section name\" );\n\n        // Less common commands which don't have a short form\n        cli[\"--list-test-names-only\"]\n            .describe( \"list all/matching test cases names only\" )\n            .bind( &ConfigData::listTestNamesOnly );\n\n        cli[\"--list-extra-info\"]\n            .describe( \"list all/matching test cases with more info\" )\n            .bind( &ConfigData::listExtraInfo );\n\n        cli[\"--list-reporters\"]\n            .describe( \"list all reporters\" )\n            .bind( &ConfigData::listReporters );\n\n        cli[\"--order\"]\n            .describe( \"test case order (defaults to decl)\" )\n            .bind( &setOrder, \"decl|lex|rand\" );\n\n        cli[\"--rng-seed\"]\n            .describe( \"set a specific seed for random numbers\" )\n            .bind( &setRngSeed, \"'time'|number\" );\n\n        cli[\"--force-colour\"]\n            .describe( \"force colourised output (deprecated)\" )\n            .bind( &forceColour );\n\n        cli[\"--use-colour\"]\n            .describe( \"should output be colourised\" )\n            .bind( &setUseColour, \"yes|no\" );\n\n        return cli;\n    }\n\n} // end namespace Catch\n\n// #included from: internal/catch_list.hpp\n#define TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED\n\n// #included from: catch_text.h\n#define TWOBLUECUBES_CATCH_TEXT_H_INCLUDED\n\n#define TBC_TEXT_FORMAT_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH\n\n#define CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE Catch\n// #included from: ../external/tbc_text_format.h\n// Only use header guard if we are not using an outer namespace\n#ifndef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE\n# ifdef TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED\n#  ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED\n#   define TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED\n#  endif\n# else\n#  define TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED\n# endif\n#endif\n#ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED\n#include <string>\n#include <vector>\n#include <sstream>\n\n// Use optional outer namespace\n#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE\nnamespace CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE {\n#endif\n\nnamespace Tbc {\n\n#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH\n    const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;\n#else\n    const unsigned int consoleWidth = 80;\n#endif\n\n    struct TextAttributes {\n        TextAttributes()\n        :   initialIndent( std::string::npos ),\n            indent( 0 ),\n            width( consoleWidth-1 )\n        {}\n\n        TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return *this; }\n        TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this; }\n        TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; }\n\n        std::size_t initialIndent;  // indent of first line, or npos\n        std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos\n        std::size_t width;          // maximum width of text, including indent. Longer text will wrap\n    };\n\n    class Text {\n    public:\n        Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() )\n        : attr( _attr )\n        {\n            const std::string wrappableBeforeChars = \"[({<\\t\";\n            const std::string wrappableAfterChars = \"])}>-,./|\\\\\";\n            const std::string wrappableInsteadOfChars = \" \\n\\r\";\n            std::string indent = _attr.initialIndent != std::string::npos\n                ? std::string( _attr.initialIndent, ' ' )\n                : std::string( _attr.indent, ' ' );\n\n            typedef std::string::const_iterator iterator;\n            iterator it = _str.begin();\n            const iterator strEnd = _str.end();\n\n            while( it != strEnd ) {\n\n                if( lines.size() >= 1000 ) {\n                    lines.push_back( \"... message truncated due to excessive size\" );\n                    return;\n                }\n\n                std::string suffix;\n                std::size_t width = (std::min)( static_cast<size_t>( strEnd-it ), _attr.width-static_cast<size_t>( indent.size() ) );\n                iterator itEnd = it+width;\n                iterator itNext = _str.end();\n\n                iterator itNewLine = std::find( it, itEnd, '\\n' );\n                if( itNewLine != itEnd )\n                    itEnd = itNewLine;\n\n                if( itEnd != strEnd  ) {\n                    bool foundWrapPoint = false;\n                    iterator findIt = itEnd;\n                    do {\n                        if( wrappableAfterChars.find( *findIt ) != std::string::npos && findIt != itEnd ) {\n                            itEnd = findIt+1;\n                            itNext = findIt+1;\n                            foundWrapPoint = true;\n                        }\n                        else if( findIt > it && wrappableBeforeChars.find( *findIt ) != std::string::npos ) {\n                            itEnd = findIt;\n                            itNext = findIt;\n                            foundWrapPoint = true;\n                        }\n                        else if( wrappableInsteadOfChars.find( *findIt ) != std::string::npos ) {\n                            itNext = findIt+1;\n                            itEnd = findIt;\n                            foundWrapPoint = true;\n                        }\n                        if( findIt == it )\n                            break;\n                        else\n                            --findIt;\n                    }\n                    while( !foundWrapPoint );\n\n                    if( !foundWrapPoint ) {\n                        // No good wrap char, so we'll break mid word and add a hyphen\n                        --itEnd;\n                        itNext = itEnd;\n                        suffix = \"-\";\n                    }\n                    else {\n                        while( itEnd > it && wrappableInsteadOfChars.find( *(itEnd-1) ) != std::string::npos )\n                            --itEnd;\n                    }\n                }\n                lines.push_back( indent + std::string( it, itEnd ) + suffix );\n\n                if( indent.size() != _attr.indent )\n                    indent = std::string( _attr.indent, ' ' );\n                it = itNext;\n            }\n        }\n\n        typedef std::vector<std::string>::const_iterator const_iterator;\n\n        const_iterator begin() const { return lines.begin(); }\n        const_iterator end() const { return lines.end(); }\n        std::string const& last() const { return lines.back(); }\n        std::size_t size() const { return lines.size(); }\n        std::string const& operator[]( std::size_t _index ) const { return lines[_index]; }\n        std::string toString() const {\n            std::ostringstream oss;\n            oss << *this;\n            return oss.str();\n        }\n\n        inline friend std::ostream& operator << ( std::ostream& _stream, Text const& _text ) {\n            for( Text::const_iterator it = _text.begin(), itEnd = _text.end();\n                it != itEnd; ++it ) {\n                if( it != _text.begin() )\n                    _stream << \"\\n\";\n                _stream << *it;\n            }\n            return _stream;\n        }\n\n    private:\n        std::string str;\n        TextAttributes attr;\n        std::vector<std::string> lines;\n    };\n\n} // end namespace Tbc\n\n#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE\n} // end outer namespace\n#endif\n\n#endif // TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED\n#undef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE\n\nnamespace Catch {\n    using Tbc::Text;\n    using Tbc::TextAttributes;\n}\n\n// #included from: catch_console_colour.hpp\n#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED\n\nnamespace Catch {\n\n    struct Colour {\n        enum Code {\n            None = 0,\n\n            White,\n            Red,\n            Green,\n            Blue,\n            Cyan,\n            Yellow,\n            Grey,\n\n            Bright = 0x10,\n\n            BrightRed = Bright | Red,\n            BrightGreen = Bright | Green,\n            LightGrey = Bright | Grey,\n            BrightWhite = Bright | White,\n\n            // By intention\n            FileName = LightGrey,\n            Warning = Yellow,\n            ResultError = BrightRed,\n            ResultSuccess = BrightGreen,\n            ResultExpectedFailure = Warning,\n\n            Error = BrightRed,\n            Success = Green,\n\n            OriginalExpression = Cyan,\n            ReconstructedExpression = Yellow,\n\n            SecondaryText = LightGrey,\n            Headers = White\n        };\n\n        // Use constructed object for RAII guard\n        Colour( Code _colourCode );\n        Colour( Colour const& other );\n        ~Colour();\n\n        // Use static method for one-shot changes\n        static void use( Code _colourCode );\n\n    private:\n        bool m_moved;\n    };\n\n    inline std::ostream& operator << ( std::ostream& os, Colour const& ) { return os; }\n\n} // end namespace Catch\n\n// #included from: catch_interfaces_reporter.h\n#define TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED\n\n#include <string>\n#include <ostream>\n#include <map>\n\nnamespace Catch\n{\n    struct ReporterConfig {\n        explicit ReporterConfig( Ptr<IConfig const> const& _fullConfig )\n        :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}\n\n        ReporterConfig( Ptr<IConfig const> const& _fullConfig, std::ostream& _stream )\n        :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}\n\n        std::ostream& stream() const    { return *m_stream; }\n        Ptr<IConfig const> fullConfig() const { return m_fullConfig; }\n\n    private:\n        std::ostream* m_stream;\n        Ptr<IConfig const> m_fullConfig;\n    };\n\n    struct ReporterPreferences {\n        ReporterPreferences()\n        : shouldRedirectStdOut( false )\n        {}\n\n        bool shouldRedirectStdOut;\n    };\n\n    template<typename T>\n    struct LazyStat : Option<T> {\n        LazyStat() : used( false ) {}\n        LazyStat& operator=( T const& _value ) {\n            Option<T>::operator=( _value );\n            used = false;\n            return *this;\n        }\n        void reset() {\n            Option<T>::reset();\n            used = false;\n        }\n        bool used;\n    };\n\n    struct TestRunInfo {\n        TestRunInfo( std::string const& _name ) : name( _name ) {}\n        std::string name;\n    };\n    struct GroupInfo {\n        GroupInfo(  std::string const& _name,\n                    std::size_t _groupIndex,\n                    std::size_t _groupsCount )\n        :   name( _name ),\n            groupIndex( _groupIndex ),\n            groupsCounts( _groupsCount )\n        {}\n\n        std::string name;\n        std::size_t groupIndex;\n        std::size_t groupsCounts;\n    };\n\n    struct AssertionStats {\n        AssertionStats( AssertionResult const& _assertionResult,\n                        std::vector<MessageInfo> const& _infoMessages,\n                        Totals const& _totals )\n        :   assertionResult( _assertionResult ),\n            infoMessages( _infoMessages ),\n            totals( _totals )\n        {\n            if( assertionResult.hasMessage() ) {\n                // Copy message into messages list.\n                // !TBD This should have been done earlier, somewhere\n                MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );\n                builder << assertionResult.getMessage();\n                builder.m_info.message = builder.m_stream.str();\n\n                infoMessages.push_back( builder.m_info );\n            }\n        }\n        virtual ~AssertionStats();\n\n#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS\n        AssertionStats( AssertionStats const& )              = default;\n        AssertionStats( AssertionStats && )                  = default;\n        AssertionStats& operator = ( AssertionStats const& ) = default;\n        AssertionStats& operator = ( AssertionStats && )     = default;\n#  endif\n\n        AssertionResult assertionResult;\n        std::vector<MessageInfo> infoMessages;\n        Totals totals;\n    };\n\n    struct SectionStats {\n        SectionStats(   SectionInfo const& _sectionInfo,\n                        Counts const& _assertions,\n                        double _durationInSeconds,\n                        bool _missingAssertions )\n        :   sectionInfo( _sectionInfo ),\n            assertions( _assertions ),\n            durationInSeconds( _durationInSeconds ),\n            missingAssertions( _missingAssertions )\n        {}\n        virtual ~SectionStats();\n#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS\n        SectionStats( SectionStats const& )              = default;\n        SectionStats( SectionStats && )                  = default;\n        SectionStats& operator = ( SectionStats const& ) = default;\n        SectionStats& operator = ( SectionStats && )     = default;\n#  endif\n\n        SectionInfo sectionInfo;\n        Counts assertions;\n        double durationInSeconds;\n        bool missingAssertions;\n    };\n\n    struct TestCaseStats {\n        TestCaseStats(  TestCaseInfo const& _testInfo,\n                        Totals const& _totals,\n                        std::string const& _stdOut,\n                        std::string const& _stdErr,\n                        bool _aborting )\n        : testInfo( _testInfo ),\n            totals( _totals ),\n            stdOut( _stdOut ),\n            stdErr( _stdErr ),\n            aborting( _aborting )\n        {}\n        virtual ~TestCaseStats();\n\n#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS\n        TestCaseStats( TestCaseStats const& )              = default;\n        TestCaseStats( TestCaseStats && )                  = default;\n        TestCaseStats& operator = ( TestCaseStats const& ) = default;\n        TestCaseStats& operator = ( TestCaseStats && )     = default;\n#  endif\n\n        TestCaseInfo testInfo;\n        Totals totals;\n        std::string stdOut;\n        std::string stdErr;\n        bool aborting;\n    };\n\n    struct TestGroupStats {\n        TestGroupStats( GroupInfo const& _groupInfo,\n                        Totals const& _totals,\n                        bool _aborting )\n        :   groupInfo( _groupInfo ),\n            totals( _totals ),\n            aborting( _aborting )\n        {}\n        TestGroupStats( GroupInfo const& _groupInfo )\n        :   groupInfo( _groupInfo ),\n            aborting( false )\n        {}\n        virtual ~TestGroupStats();\n\n#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS\n        TestGroupStats( TestGroupStats const& )              = default;\n        TestGroupStats( TestGroupStats && )                  = default;\n        TestGroupStats& operator = ( TestGroupStats const& ) = default;\n        TestGroupStats& operator = ( TestGroupStats && )     = default;\n#  endif\n\n        GroupInfo groupInfo;\n        Totals totals;\n        bool aborting;\n    };\n\n    struct TestRunStats {\n        TestRunStats(   TestRunInfo const& _runInfo,\n                        Totals const& _totals,\n                        bool _aborting )\n        :   runInfo( _runInfo ),\n            totals( _totals ),\n            aborting( _aborting )\n        {}\n        virtual ~TestRunStats();\n\n#  ifndef CATCH_CONFIG_CPP11_GENERATED_METHODS\n        TestRunStats( TestRunStats const& _other )\n        :   runInfo( _other.runInfo ),\n            totals( _other.totals ),\n            aborting( _other.aborting )\n        {}\n#  else\n        TestRunStats( TestRunStats const& )              = default;\n        TestRunStats( TestRunStats && )                  = default;\n        TestRunStats& operator = ( TestRunStats const& ) = default;\n        TestRunStats& operator = ( TestRunStats && )     = default;\n#  endif\n\n        TestRunInfo runInfo;\n        Totals totals;\n        bool aborting;\n    };\n\n    class MultipleReporters;\n\n    struct IStreamingReporter : IShared {\n        virtual ~IStreamingReporter();\n\n        // Implementing class must also provide the following static method:\n        // static std::string getDescription();\n\n        virtual ReporterPreferences getPreferences() const = 0;\n\n        virtual void noMatchingTestCases( std::string const& spec ) = 0;\n\n        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;\n        virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;\n\n        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;\n        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;\n\n        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;\n\n        // The return value indicates if the messages buffer should be cleared:\n        virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;\n\n        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;\n        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;\n        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;\n        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;\n\n        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;\n\n        virtual MultipleReporters* tryAsMulti() { return CATCH_NULL; }\n    };\n\n    struct IReporterFactory : IShared {\n        virtual ~IReporterFactory();\n        virtual IStreamingReporter* create( ReporterConfig const& config ) const = 0;\n        virtual std::string getDescription() const = 0;\n    };\n\n    struct IReporterRegistry {\n        typedef std::map<std::string, Ptr<IReporterFactory> > FactoryMap;\n        typedef std::vector<Ptr<IReporterFactory> > Listeners;\n\n        virtual ~IReporterRegistry();\n        virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig const> const& config ) const = 0;\n        virtual FactoryMap const& getFactories() const = 0;\n        virtual Listeners const& getListeners() const = 0;\n    };\n\n    Ptr<IStreamingReporter> addReporter( Ptr<IStreamingReporter> const& existingReporter, Ptr<IStreamingReporter> const& additionalReporter );\n\n}\n\n#include <limits>\n#include <algorithm>\n\nnamespace Catch {\n\n    inline std::size_t listTests( Config const& config ) {\n\n        TestSpec testSpec = config.testSpec();\n        if( config.testSpec().hasFilters() )\n            Catch::cout() << \"Matching test cases:\\n\";\n        else {\n            Catch::cout() << \"All available test cases:\\n\";\n            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( \"*\" ).testSpec();\n        }\n\n        std::size_t matchedTests = 0;\n        TextAttributes nameAttr, descAttr, tagsAttr;\n        nameAttr.setInitialIndent( 2 ).setIndent( 4 );\n        descAttr.setIndent( 4 );\n        tagsAttr.setIndent( 6 );\n\n        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\n        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();\n                it != itEnd;\n                ++it ) {\n            matchedTests++;\n            TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();\n            Colour::Code colour = testCaseInfo.isHidden()\n                ? Colour::SecondaryText\n                : Colour::None;\n            Colour colourGuard( colour );\n\n            Catch::cout() << Text( testCaseInfo.name, nameAttr ) << std::endl;\n            if( config.listExtraInfo() ) {\n                Catch::cout() << \"    \" << testCaseInfo.lineInfo << std::endl;\n                std::string description = testCaseInfo.description;\n                if( description.empty() )\n                    description = \"(NO DESCRIPTION)\";\n                Catch::cout() << Text( description, descAttr ) << std::endl;\n            }\n            if( !testCaseInfo.tags.empty() )\n                Catch::cout() << Text( testCaseInfo.tagsAsString, tagsAttr ) << std::endl;\n        }\n\n        if( !config.testSpec().hasFilters() )\n            Catch::cout() << pluralise( matchedTests, \"test case\" ) << '\\n' << std::endl;\n        else\n            Catch::cout() << pluralise( matchedTests, \"matching test case\" ) << '\\n' << std::endl;\n        return matchedTests;\n    }\n\n    inline std::size_t listTestsNamesOnly( Config const& config ) {\n        TestSpec testSpec = config.testSpec();\n        if( !config.testSpec().hasFilters() )\n            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( \"*\" ).testSpec();\n        std::size_t matchedTests = 0;\n        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\n        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();\n                it != itEnd;\n                ++it ) {\n            matchedTests++;\n            TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();\n            if( startsWith( testCaseInfo.name, '#' ) )\n               Catch::cout() << '\"' << testCaseInfo.name << '\"';\n            else\n               Catch::cout() << testCaseInfo.name;\n            if ( config.listExtraInfo() )\n                Catch::cout() << \"\\t@\" << testCaseInfo.lineInfo;\n            Catch::cout() << std::endl;\n        }\n        return matchedTests;\n    }\n\n    struct TagInfo {\n        TagInfo() : count ( 0 ) {}\n        void add( std::string const& spelling ) {\n            ++count;\n            spellings.insert( spelling );\n        }\n        std::string all() const {\n            std::string out;\n            for( std::set<std::string>::const_iterator it = spellings.begin(), itEnd = spellings.end();\n                        it != itEnd;\n                        ++it )\n                out += \"[\" + *it + \"]\";\n            return out;\n        }\n        std::set<std::string> spellings;\n        std::size_t count;\n    };\n\n    inline std::size_t listTags( Config const& config ) {\n        TestSpec testSpec = config.testSpec();\n        if( config.testSpec().hasFilters() )\n            Catch::cout() << \"Tags for matching test cases:\\n\";\n        else {\n            Catch::cout() << \"All available tags:\\n\";\n            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( \"*\" ).testSpec();\n        }\n\n        std::map<std::string, TagInfo> tagCounts;\n\n        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\n        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();\n                it != itEnd;\n                ++it ) {\n            for( std::set<std::string>::const_iterator  tagIt = it->getTestCaseInfo().tags.begin(),\n                                                        tagItEnd = it->getTestCaseInfo().tags.end();\n                    tagIt != tagItEnd;\n                    ++tagIt ) {\n                std::string tagName = *tagIt;\n                std::string lcaseTagName = toLower( tagName );\n                std::map<std::string, TagInfo>::iterator countIt = tagCounts.find( lcaseTagName );\n                if( countIt == tagCounts.end() )\n                    countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;\n                countIt->second.add( tagName );\n            }\n        }\n\n        for( std::map<std::string, TagInfo>::const_iterator countIt = tagCounts.begin(),\n                                                            countItEnd = tagCounts.end();\n                countIt != countItEnd;\n                ++countIt ) {\n            std::ostringstream oss;\n            oss << \"  \" << std::setw(2) << countIt->second.count << \"  \";\n            Text wrapper( countIt->second.all(), TextAttributes()\n                                                    .setInitialIndent( 0 )\n                                                    .setIndent( oss.str().size() )\n                                                    .setWidth( CATCH_CONFIG_CONSOLE_WIDTH-10 ) );\n            Catch::cout() << oss.str() << wrapper << '\\n';\n        }\n        Catch::cout() << pluralise( tagCounts.size(), \"tag\" ) << '\\n' << std::endl;\n        return tagCounts.size();\n    }\n\n    inline std::size_t listReporters( Config const& /*config*/ ) {\n        Catch::cout() << \"Available reporters:\\n\";\n        IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n        IReporterRegistry::FactoryMap::const_iterator itBegin = factories.begin(), itEnd = factories.end(), it;\n        std::size_t maxNameLen = 0;\n        for(it = itBegin; it != itEnd; ++it )\n            maxNameLen = (std::max)( maxNameLen, it->first.size() );\n\n        for(it = itBegin; it != itEnd; ++it ) {\n            Text wrapper( it->second->getDescription(), TextAttributes()\n                                                        .setInitialIndent( 0 )\n                                                        .setIndent( 7+maxNameLen )\n                                                        .setWidth( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 ) );\n            Catch::cout() << \"  \"\n                    << it->first\n                    << ':'\n                    << std::string( maxNameLen - it->first.size() + 2, ' ' )\n                    << wrapper << '\\n';\n        }\n        Catch::cout() << std::endl;\n        return factories.size();\n    }\n\n    inline Option<std::size_t> list( Config const& config ) {\n        Option<std::size_t> listedCount;\n        if( config.listTests() || ( config.listExtraInfo() && !config.listTestNamesOnly() ) )\n            listedCount = listedCount.valueOr(0) + listTests( config );\n        if( config.listTestNamesOnly() )\n            listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );\n        if( config.listTags() )\n            listedCount = listedCount.valueOr(0) + listTags( config );\n        if( config.listReporters() )\n            listedCount = listedCount.valueOr(0) + listReporters( config );\n        return listedCount;\n    }\n\n} // end namespace Catch\n\n// #included from: internal/catch_run_context.hpp\n#define TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED\n\n// #included from: catch_test_case_tracker.hpp\n#define TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED\n\n#include <algorithm>\n#include <string>\n#include <assert.h>\n#include <vector>\n#include <stdexcept>\n\nCATCH_INTERNAL_SUPPRESS_ETD_WARNINGS\n\nnamespace Catch {\nnamespace TestCaseTracking {\n\n    struct NameAndLocation {\n        std::string name;\n        SourceLineInfo location;\n\n        NameAndLocation( std::string const& _name, SourceLineInfo const& _location )\n        :   name( _name ),\n            location( _location )\n        {}\n    };\n\n    struct ITracker : SharedImpl<> {\n        virtual ~ITracker();\n\n        // static queries\n        virtual NameAndLocation const& nameAndLocation() const = 0;\n\n        // dynamic queries\n        virtual bool isComplete() const = 0; // Successfully completed or failed\n        virtual bool isSuccessfullyCompleted() const = 0;\n        virtual bool isOpen() const = 0; // Started but not complete\n        virtual bool hasChildren() const = 0;\n\n        virtual ITracker& parent() = 0;\n\n        // actions\n        virtual void close() = 0; // Successfully complete\n        virtual void fail() = 0;\n        virtual void markAsNeedingAnotherRun() = 0;\n\n        virtual void addChild( Ptr<ITracker> const& child ) = 0;\n        virtual ITracker* findChild( NameAndLocation const& nameAndLocation ) = 0;\n        virtual void openChild() = 0;\n\n        // Debug/ checking\n        virtual bool isSectionTracker() const = 0;\n        virtual bool isIndexTracker() const = 0;\n    };\n\n    class  TrackerContext {\n\n        enum RunState {\n            NotStarted,\n            Executing,\n            CompletedCycle\n        };\n\n        Ptr<ITracker> m_rootTracker;\n        ITracker* m_currentTracker;\n        RunState m_runState;\n\n    public:\n\n        static TrackerContext& instance() {\n            static TrackerContext s_instance;\n            return s_instance;\n        }\n\n        TrackerContext()\n        :   m_currentTracker( CATCH_NULL ),\n            m_runState( NotStarted )\n        {}\n\n        ITracker& startRun();\n\n        void endRun() {\n            m_rootTracker.reset();\n            m_currentTracker = CATCH_NULL;\n            m_runState = NotStarted;\n        }\n\n        void startCycle() {\n            m_currentTracker = m_rootTracker.get();\n            m_runState = Executing;\n        }\n        void completeCycle() {\n            m_runState = CompletedCycle;\n        }\n\n        bool completedCycle() const {\n            return m_runState == CompletedCycle;\n        }\n        ITracker& currentTracker() {\n            return *m_currentTracker;\n        }\n        void setCurrentTracker( ITracker* tracker ) {\n            m_currentTracker = tracker;\n        }\n    };\n\n    class TrackerBase : public ITracker {\n    protected:\n        enum CycleState {\n            NotStarted,\n            Executing,\n            ExecutingChildren,\n            NeedsAnotherRun,\n            CompletedSuccessfully,\n            Failed\n        };\n        class TrackerHasName {\n            NameAndLocation m_nameAndLocation;\n        public:\n            TrackerHasName( NameAndLocation const& nameAndLocation ) : m_nameAndLocation( nameAndLocation ) {}\n            bool operator ()( Ptr<ITracker> const& tracker ) {\n                return\n                    tracker->nameAndLocation().name == m_nameAndLocation.name &&\n                    tracker->nameAndLocation().location == m_nameAndLocation.location;\n            }\n        };\n        typedef std::vector<Ptr<ITracker> > Children;\n        NameAndLocation m_nameAndLocation;\n        TrackerContext& m_ctx;\n        ITracker* m_parent;\n        Children m_children;\n        CycleState m_runState;\n    public:\n        TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )\n        :   m_nameAndLocation( nameAndLocation ),\n            m_ctx( ctx ),\n            m_parent( parent ),\n            m_runState( NotStarted )\n        {}\n        virtual ~TrackerBase();\n\n        virtual NameAndLocation const& nameAndLocation() const CATCH_OVERRIDE {\n            return m_nameAndLocation;\n        }\n        virtual bool isComplete() const CATCH_OVERRIDE {\n            return m_runState == CompletedSuccessfully || m_runState == Failed;\n        }\n        virtual bool isSuccessfullyCompleted() const CATCH_OVERRIDE {\n            return m_runState == CompletedSuccessfully;\n        }\n        virtual bool isOpen() const CATCH_OVERRIDE {\n            return m_runState != NotStarted && !isComplete();\n        }\n        virtual bool hasChildren() const CATCH_OVERRIDE {\n            return !m_children.empty();\n        }\n\n        virtual void addChild( Ptr<ITracker> const& child ) CATCH_OVERRIDE {\n            m_children.push_back( child );\n        }\n\n        virtual ITracker* findChild( NameAndLocation const& nameAndLocation ) CATCH_OVERRIDE {\n            Children::const_iterator it = std::find_if( m_children.begin(), m_children.end(), TrackerHasName( nameAndLocation ) );\n            return( it != m_children.end() )\n                ? it->get()\n                : CATCH_NULL;\n        }\n        virtual ITracker& parent() CATCH_OVERRIDE {\n            assert( m_parent ); // Should always be non-null except for root\n            return *m_parent;\n        }\n\n        virtual void openChild() CATCH_OVERRIDE {\n            if( m_runState != ExecutingChildren ) {\n                m_runState = ExecutingChildren;\n                if( m_parent )\n                    m_parent->openChild();\n            }\n        }\n\n        virtual bool isSectionTracker() const CATCH_OVERRIDE { return false; }\n        virtual bool isIndexTracker() const CATCH_OVERRIDE { return false; }\n\n        void open() {\n            m_runState = Executing;\n            moveToThis();\n            if( m_parent )\n                m_parent->openChild();\n        }\n\n        virtual void close() CATCH_OVERRIDE {\n\n            // Close any still open children (e.g. generators)\n            while( &m_ctx.currentTracker() != this )\n                m_ctx.currentTracker().close();\n\n            switch( m_runState ) {\n                case NotStarted:\n                case CompletedSuccessfully:\n                case Failed:\n                    throw std::logic_error( \"Illogical state\" );\n\n                case NeedsAnotherRun:\n                    break;;\n\n                case Executing:\n                    m_runState = CompletedSuccessfully;\n                    break;\n                case ExecutingChildren:\n                    if( m_children.empty() || m_children.back()->isComplete() )\n                        m_runState = CompletedSuccessfully;\n                    break;\n\n                default:\n                    throw std::logic_error( \"Unexpected state\" );\n            }\n            moveToParent();\n            m_ctx.completeCycle();\n        }\n        virtual void fail() CATCH_OVERRIDE {\n            m_runState = Failed;\n            if( m_parent )\n                m_parent->markAsNeedingAnotherRun();\n            moveToParent();\n            m_ctx.completeCycle();\n        }\n        virtual void markAsNeedingAnotherRun() CATCH_OVERRIDE {\n            m_runState = NeedsAnotherRun;\n        }\n    private:\n        void moveToParent() {\n            assert( m_parent );\n            m_ctx.setCurrentTracker( m_parent );\n        }\n        void moveToThis() {\n            m_ctx.setCurrentTracker( this );\n        }\n    };\n\n    class SectionTracker : public TrackerBase {\n        std::vector<std::string> m_filters;\n    public:\n        SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )\n        :   TrackerBase( nameAndLocation, ctx, parent )\n        {\n            if( parent ) {\n                while( !parent->isSectionTracker() )\n                    parent = &parent->parent();\n\n                SectionTracker& parentSection = static_cast<SectionTracker&>( *parent );\n                addNextFilters( parentSection.m_filters );\n            }\n        }\n        virtual ~SectionTracker();\n\n        virtual bool isSectionTracker() const CATCH_OVERRIDE { return true; }\n\n        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {\n            SectionTracker* section = CATCH_NULL;\n\n            ITracker& currentTracker = ctx.currentTracker();\n            if( ITracker* childTracker = currentTracker.findChild( nameAndLocation ) ) {\n                assert( childTracker );\n                assert( childTracker->isSectionTracker() );\n                section = static_cast<SectionTracker*>( childTracker );\n            }\n            else {\n                section = new SectionTracker( nameAndLocation, ctx, &currentTracker );\n                currentTracker.addChild( section );\n            }\n            if( !ctx.completedCycle() )\n                section->tryOpen();\n            return *section;\n        }\n\n        void tryOpen() {\n            if( !isComplete() && (m_filters.empty() || m_filters[0].empty() ||  m_filters[0] == m_nameAndLocation.name ) )\n                open();\n        }\n\n        void addInitialFilters( std::vector<std::string> const& filters ) {\n            if( !filters.empty() ) {\n                m_filters.push_back(\"\"); // Root - should never be consulted\n                m_filters.push_back(\"\"); // Test Case - not a section filter\n                m_filters.insert( m_filters.end(), filters.begin(), filters.end() );\n            }\n        }\n        void addNextFilters( std::vector<std::string> const& filters ) {\n            if( filters.size() > 1 )\n                m_filters.insert( m_filters.end(), ++filters.begin(), filters.end() );\n        }\n    };\n\n    class IndexTracker : public TrackerBase {\n        int m_size;\n        int m_index;\n    public:\n        IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size )\n        :   TrackerBase( nameAndLocation, ctx, parent ),\n            m_size( size ),\n            m_index( -1 )\n        {}\n        virtual ~IndexTracker();\n\n        virtual bool isIndexTracker() const CATCH_OVERRIDE { return true; }\n\n        static IndexTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size ) {\n            IndexTracker* tracker = CATCH_NULL;\n\n            ITracker& currentTracker = ctx.currentTracker();\n            if( ITracker* childTracker = currentTracker.findChild( nameAndLocation ) ) {\n                assert( childTracker );\n                assert( childTracker->isIndexTracker() );\n                tracker = static_cast<IndexTracker*>( childTracker );\n            }\n            else {\n                tracker = new IndexTracker( nameAndLocation, ctx, &currentTracker, size );\n                currentTracker.addChild( tracker );\n            }\n\n            if( !ctx.completedCycle() && !tracker->isComplete() ) {\n                if( tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun )\n                    tracker->moveNext();\n                tracker->open();\n            }\n\n            return *tracker;\n        }\n\n        int index() const { return m_index; }\n\n        void moveNext() {\n            m_index++;\n            m_children.clear();\n        }\n\n        virtual void close() CATCH_OVERRIDE {\n            TrackerBase::close();\n            if( m_runState == CompletedSuccessfully && m_index < m_size-1 )\n                m_runState = Executing;\n        }\n    };\n\n    inline ITracker& TrackerContext::startRun() {\n        m_rootTracker = new SectionTracker( NameAndLocation( \"{root}\", CATCH_INTERNAL_LINEINFO ), *this, CATCH_NULL );\n        m_currentTracker = CATCH_NULL;\n        m_runState = Executing;\n        return *m_rootTracker;\n    }\n\n} // namespace TestCaseTracking\n\nusing TestCaseTracking::ITracker;\nusing TestCaseTracking::TrackerContext;\nusing TestCaseTracking::SectionTracker;\nusing TestCaseTracking::IndexTracker;\n\n} // namespace Catch\n\nCATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS\n\n// #included from: catch_fatal_condition.hpp\n#define TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED\n\nnamespace Catch {\n\n    // Report the error condition\n    inline void reportFatal( std::string const& message ) {\n        IContext& context = Catch::getCurrentContext();\n        IResultCapture* resultCapture = context.getResultCapture();\n        resultCapture->handleFatalErrorCondition( message );\n    }\n\n} // namespace Catch\n\n#if defined ( CATCH_PLATFORM_WINDOWS ) /////////////////////////////////////////\n// #included from: catch_windows_h_proxy.h\n\n#define TWOBLUECUBES_CATCH_WINDOWS_H_PROXY_H_INCLUDED\n\n#ifdef CATCH_DEFINES_NOMINMAX\n#  define NOMINMAX\n#endif\n#ifdef CATCH_DEFINES_WIN32_LEAN_AND_MEAN\n#  define WIN32_LEAN_AND_MEAN\n#endif\n\n#ifdef __AFXDLL\n#include <AfxWin.h>\n#else\n#include <windows.h>\n#endif\n\n#ifdef CATCH_DEFINES_NOMINMAX\n#  undef NOMINMAX\n#endif\n#ifdef CATCH_DEFINES_WIN32_LEAN_AND_MEAN\n#  undef WIN32_LEAN_AND_MEAN\n#endif\n\n\n#  if !defined ( CATCH_CONFIG_WINDOWS_SEH )\n\nnamespace Catch {\n    struct FatalConditionHandler {\n        void reset() {}\n    };\n}\n\n#  else // CATCH_CONFIG_WINDOWS_SEH is defined\n\nnamespace Catch {\n\n    struct SignalDefs { DWORD id; const char* name; };\n    extern SignalDefs signalDefs[];\n    // There is no 1-1 mapping between signals and windows exceptions.\n    // Windows can easily distinguish between SO and SigSegV,\n    // but SigInt, SigTerm, etc are handled differently.\n    SignalDefs signalDefs[] = {\n        { EXCEPTION_ILLEGAL_INSTRUCTION,  \"SIGILL - Illegal instruction signal\" },\n        { EXCEPTION_STACK_OVERFLOW, \"SIGSEGV - Stack overflow\" },\n        { EXCEPTION_ACCESS_VIOLATION, \"SIGSEGV - Segmentation violation signal\" },\n        { EXCEPTION_INT_DIVIDE_BY_ZERO, \"Divide by zero error\" },\n    };\n\n    struct FatalConditionHandler {\n\n        static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {\n            for (int i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i) {\n                if (ExceptionInfo->ExceptionRecord->ExceptionCode == signalDefs[i].id) {\n                    reportFatal(signalDefs[i].name);\n                }\n            }\n            // If its not an exception we care about, pass it along.\n            // This stops us from eating debugger breaks etc.\n            return EXCEPTION_CONTINUE_SEARCH;\n        }\n\n        FatalConditionHandler() {\n            isSet = true;\n            // 32k seems enough for Catch to handle stack overflow,\n            // but the value was found experimentally, so there is no strong guarantee\n            guaranteeSize = 32 * 1024;\n            exceptionHandlerHandle = CATCH_NULL;\n            // Register as first handler in current chain\n            exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\n            // Pass in guarantee size to be filled\n            SetThreadStackGuarantee(&guaranteeSize);\n        }\n\n        static void reset() {\n            if (isSet) {\n                // Unregister handler and restore the old guarantee\n                RemoveVectoredExceptionHandler(exceptionHandlerHandle);\n                SetThreadStackGuarantee(&guaranteeSize);\n                exceptionHandlerHandle = CATCH_NULL;\n                isSet = false;\n            }\n        }\n\n        ~FatalConditionHandler() {\n            reset();\n        }\n    private:\n        static bool isSet;\n        static ULONG guaranteeSize;\n        static PVOID exceptionHandlerHandle;\n    };\n\n    bool FatalConditionHandler::isSet = false;\n    ULONG FatalConditionHandler::guaranteeSize = 0;\n    PVOID FatalConditionHandler::exceptionHandlerHandle = CATCH_NULL;\n\n} // namespace Catch\n\n#  endif // CATCH_CONFIG_WINDOWS_SEH\n\n#else // Not Windows - assumed to be POSIX compatible //////////////////////////\n\n#  if !defined(CATCH_CONFIG_POSIX_SIGNALS)\n\nnamespace Catch {\n    struct FatalConditionHandler {\n        void reset() {}\n    };\n}\n\n#  else // CATCH_CONFIG_POSIX_SIGNALS is defined\n\n#include <signal.h>\n\nnamespace Catch {\n\n    struct SignalDefs {\n        int id;\n        const char* name;\n    };\n    extern SignalDefs signalDefs[];\n    SignalDefs signalDefs[] = {\n            { SIGINT,  \"SIGINT - Terminal interrupt signal\" },\n            { SIGILL,  \"SIGILL - Illegal instruction signal\" },\n            { SIGFPE,  \"SIGFPE - Floating point error signal\" },\n            { SIGSEGV, \"SIGSEGV - Segmentation violation signal\" },\n            { SIGTERM, \"SIGTERM - Termination request signal\" },\n            { SIGABRT, \"SIGABRT - Abort (abnormal termination) signal\" }\n    };\n\n    struct FatalConditionHandler {\n\n        static bool isSet;\n        static struct sigaction oldSigActions [sizeof(signalDefs)/sizeof(SignalDefs)];\n        static stack_t oldSigStack;\n        static char altStackMem[SIGSTKSZ];\n\n        static void handleSignal( int sig ) {\n            std::string name = \"<unknown signal>\";\n            for (std::size_t i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i) {\n                SignalDefs &def = signalDefs[i];\n                if (sig == def.id) {\n                    name = def.name;\n                    break;\n                }\n            }\n            reset();\n            reportFatal(name);\n            raise( sig );\n        }\n\n        FatalConditionHandler() {\n            isSet = true;\n            stack_t sigStack;\n            sigStack.ss_sp = altStackMem;\n            sigStack.ss_size = SIGSTKSZ;\n            sigStack.ss_flags = 0;\n            sigaltstack(&sigStack, &oldSigStack);\n            struct sigaction sa = { 0 };\n\n            sa.sa_handler = handleSignal;\n            sa.sa_flags = SA_ONSTACK;\n            for (std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i) {\n                sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);\n            }\n        }\n\n        ~FatalConditionHandler() {\n            reset();\n        }\n        static void reset() {\n            if( isSet ) {\n                // Set signals back to previous values -- hopefully nobody overwrote them in the meantime\n                for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i ) {\n                    sigaction(signalDefs[i].id, &oldSigActions[i], CATCH_NULL);\n                }\n                // Return the old stack\n                sigaltstack(&oldSigStack, CATCH_NULL);\n                isSet = false;\n            }\n        }\n    };\n\n    bool FatalConditionHandler::isSet = false;\n    struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};\n    stack_t FatalConditionHandler::oldSigStack = {};\n    char FatalConditionHandler::altStackMem[SIGSTKSZ] = {};\n\n} // namespace Catch\n\n#  endif // CATCH_CONFIG_POSIX_SIGNALS\n\n#endif // not Windows\n\n#include <set>\n#include <string>\n\nnamespace Catch {\n\n    class StreamRedirect {\n\n    public:\n        StreamRedirect( std::ostream& stream, std::string& targetString )\n        :   m_stream( stream ),\n            m_prevBuf( stream.rdbuf() ),\n            m_targetString( targetString )\n        {\n            stream.rdbuf( m_oss.rdbuf() );\n        }\n\n        ~StreamRedirect() {\n            m_targetString += m_oss.str();\n            m_stream.rdbuf( m_prevBuf );\n        }\n\n    private:\n        std::ostream& m_stream;\n        std::streambuf* m_prevBuf;\n        std::ostringstream m_oss;\n        std::string& m_targetString;\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    class RunContext : public IResultCapture, public IRunner {\n\n        RunContext( RunContext const& );\n        void operator =( RunContext const& );\n\n    public:\n\n        explicit RunContext( Ptr<IConfig const> const& _config, Ptr<IStreamingReporter> const& reporter )\n        :   m_runInfo( _config->name() ),\n            m_context( getCurrentMutableContext() ),\n            m_activeTestCase( CATCH_NULL ),\n            m_config( _config ),\n            m_reporter( reporter ),\n            m_shouldReportUnexpected ( true )\n        {\n            m_context.setRunner( this );\n            m_context.setConfig( m_config );\n            m_context.setResultCapture( this );\n            m_reporter->testRunStarting( m_runInfo );\n        }\n\n        virtual ~RunContext() {\n            m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, aborting() ) );\n        }\n\n        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount ) {\n            m_reporter->testGroupStarting( GroupInfo( testSpec, groupIndex, groupsCount ) );\n        }\n        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount ) {\n            m_reporter->testGroupEnded( TestGroupStats( GroupInfo( testSpec, groupIndex, groupsCount ), totals, aborting() ) );\n        }\n\n        Totals runTest( TestCase const& testCase ) {\n            Totals prevTotals = m_totals;\n\n            std::string redirectedCout;\n            std::string redirectedCerr;\n\n            TestCaseInfo testInfo = testCase.getTestCaseInfo();\n\n            m_reporter->testCaseStarting( testInfo );\n\n            m_activeTestCase = &testCase;\n\n            do {\n                ITracker& rootTracker = m_trackerContext.startRun();\n                assert( rootTracker.isSectionTracker() );\n                static_cast<SectionTracker&>( rootTracker ).addInitialFilters( m_config->getSectionsToRun() );\n                do {\n                    m_trackerContext.startCycle();\n                    m_testCaseTracker = &SectionTracker::acquire( m_trackerContext, TestCaseTracking::NameAndLocation( testInfo.name, testInfo.lineInfo ) );\n                    runCurrentTest( redirectedCout, redirectedCerr );\n                }\n                while( !m_testCaseTracker->isSuccessfullyCompleted() && !aborting() );\n            }\n            // !TBD: deprecated - this will be replaced by indexed trackers\n            while( getCurrentContext().advanceGeneratorsForCurrentTest() && !aborting() );\n\n            Totals deltaTotals = m_totals.delta( prevTotals );\n            if( testInfo.expectedToFail() && deltaTotals.testCases.passed > 0 ) {\n                deltaTotals.assertions.failed++;\n                deltaTotals.testCases.passed--;\n                deltaTotals.testCases.failed++;\n            }\n            m_totals.testCases += deltaTotals.testCases;\n            m_reporter->testCaseEnded( TestCaseStats(   testInfo,\n                                                        deltaTotals,\n                                                        redirectedCout,\n                                                        redirectedCerr,\n                                                        aborting() ) );\n\n            m_activeTestCase = CATCH_NULL;\n            m_testCaseTracker = CATCH_NULL;\n\n            return deltaTotals;\n        }\n\n        Ptr<IConfig const> config() const {\n            return m_config;\n        }\n\n    private: // IResultCapture\n\n        virtual void assertionEnded( AssertionResult const& result ) {\n            if( result.getResultType() == ResultWas::Ok ) {\n                m_totals.assertions.passed++;\n            }\n            else if( !result.isOk() ) {\n                m_totals.assertions.failed++;\n            }\n\n            // We have no use for the return value (whether messages should be cleared), because messages were made scoped\n            // and should be let to clear themselves out.\n            static_cast<void>(m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)));\n\n            // Reset working state\n            m_lastAssertionInfo = AssertionInfo( \"\", m_lastAssertionInfo.lineInfo, \"{Unknown expression after the reported line}\" , m_lastAssertionInfo.resultDisposition );\n            m_lastResult = result;\n        }\n\n        virtual bool sectionStarted (\n            SectionInfo const& sectionInfo,\n            Counts& assertions\n        )\n        {\n            ITracker& sectionTracker = SectionTracker::acquire( m_trackerContext, TestCaseTracking::NameAndLocation( sectionInfo.name, sectionInfo.lineInfo ) );\n            if( !sectionTracker.isOpen() )\n                return false;\n            m_activeSections.push_back( &sectionTracker );\n\n            m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;\n\n            m_reporter->sectionStarting( sectionInfo );\n\n            assertions = m_totals.assertions;\n\n            return true;\n        }\n        bool testForMissingAssertions( Counts& assertions ) {\n            if( assertions.total() != 0 )\n                return false;\n            if( !m_config->warnAboutMissingAssertions() )\n                return false;\n            if( m_trackerContext.currentTracker().hasChildren() )\n                return false;\n            m_totals.assertions.failed++;\n            assertions.failed++;\n            return true;\n        }\n\n        virtual void sectionEnded( SectionEndInfo const& endInfo ) {\n            Counts assertions = m_totals.assertions - endInfo.prevAssertions;\n            bool missingAssertions = testForMissingAssertions( assertions );\n\n            if( !m_activeSections.empty() ) {\n                m_activeSections.back()->close();\n                m_activeSections.pop_back();\n            }\n\n            m_reporter->sectionEnded( SectionStats( endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions ) );\n            m_messages.clear();\n        }\n\n        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) {\n            if( m_unfinishedSections.empty() )\n                m_activeSections.back()->fail();\n            else\n                m_activeSections.back()->close();\n            m_activeSections.pop_back();\n\n            m_unfinishedSections.push_back( endInfo );\n        }\n\n        virtual void pushScopedMessage( MessageInfo const& message ) {\n            m_messages.push_back( message );\n        }\n\n        virtual void popScopedMessage( MessageInfo const& message ) {\n            m_messages.erase( std::remove( m_messages.begin(), m_messages.end(), message ), m_messages.end() );\n        }\n\n        virtual std::string getCurrentTestName() const {\n            return m_activeTestCase\n                ? m_activeTestCase->getTestCaseInfo().name\n                : std::string();\n        }\n\n        virtual const AssertionResult* getLastResult() const {\n            return &m_lastResult;\n        }\n\n        virtual void exceptionEarlyReported() {\n            m_shouldReportUnexpected = false;\n        }\n\n        virtual void handleFatalErrorCondition( std::string const& message ) {\n            // Don't rebuild the result -- the stringification itself can cause more fatal errors\n            // Instead, fake a result data.\n            AssertionResultData tempResult;\n            tempResult.resultType = ResultWas::FatalErrorCondition;\n            tempResult.message = message;\n            AssertionResult result(m_lastAssertionInfo, tempResult);\n\n            getResultCapture().assertionEnded(result);\n\n            handleUnfinishedSections();\n\n            // Recreate section for test case (as we will lose the one that was in scope)\n            TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();\n            SectionInfo testCaseSection( testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description );\n\n            Counts assertions;\n            assertions.failed = 1;\n            SectionStats testCaseSectionStats( testCaseSection, assertions, 0, false );\n            m_reporter->sectionEnded( testCaseSectionStats );\n\n            TestCaseInfo testInfo = m_activeTestCase->getTestCaseInfo();\n\n            Totals deltaTotals;\n            deltaTotals.testCases.failed = 1;\n            m_reporter->testCaseEnded( TestCaseStats(   testInfo,\n                                                        deltaTotals,\n                                                        std::string(),\n                                                        std::string(),\n                                                        false ) );\n            m_totals.testCases.failed++;\n            testGroupEnded( std::string(), m_totals, 1, 1 );\n            m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, false ) );\n        }\n\n    public:\n        // !TBD We need to do this another way!\n        bool aborting() const {\n            return m_totals.assertions.failed == static_cast<std::size_t>( m_config->abortAfter() );\n        }\n\n    private:\n\n        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr ) {\n            TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();\n            SectionInfo testCaseSection( testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description );\n            m_reporter->sectionStarting( testCaseSection );\n            Counts prevAssertions = m_totals.assertions;\n            double duration = 0;\n            m_shouldReportUnexpected = true;\n            try {\n                m_lastAssertionInfo = AssertionInfo( \"TEST_CASE\", testCaseInfo.lineInfo, \"\", ResultDisposition::Normal );\n\n                seedRng( *m_config );\n\n                Timer timer;\n                timer.start();\n                if( m_reporter->getPreferences().shouldRedirectStdOut ) {\n                    StreamRedirect coutRedir( Catch::cout(), redirectedCout );\n                    StreamRedirect cerrRedir( Catch::cerr(), redirectedCerr );\n                    invokeActiveTestCase();\n                }\n                else {\n                    invokeActiveTestCase();\n                }\n                duration = timer.getElapsedSeconds();\n            }\n            catch( TestFailureException& ) {\n                // This just means the test was aborted due to failure\n            }\n            catch(...) {\n                // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions\n                // are reported without translation at the point of origin.\n                if (m_shouldReportUnexpected) {\n                    makeUnexpectedResultBuilder().useActiveException();\n                }\n            }\n            m_testCaseTracker->close();\n            handleUnfinishedSections();\n            m_messages.clear();\n\n            Counts assertions = m_totals.assertions - prevAssertions;\n            bool missingAssertions = testForMissingAssertions( assertions );\n\n            if( testCaseInfo.okToFail() ) {\n                std::swap( assertions.failedButOk, assertions.failed );\n                m_totals.assertions.failed -= assertions.failedButOk;\n                m_totals.assertions.failedButOk += assertions.failedButOk;\n            }\n\n            SectionStats testCaseSectionStats( testCaseSection, assertions, duration, missingAssertions );\n            m_reporter->sectionEnded( testCaseSectionStats );\n        }\n\n        void invokeActiveTestCase() {\n            FatalConditionHandler fatalConditionHandler; // Handle signals\n            m_activeTestCase->invoke();\n            fatalConditionHandler.reset();\n        }\n\n    private:\n\n        ResultBuilder makeUnexpectedResultBuilder() const {\n            return ResultBuilder(   m_lastAssertionInfo.macroName,\n                                    m_lastAssertionInfo.lineInfo,\n                                    m_lastAssertionInfo.capturedExpression,\n                                    m_lastAssertionInfo.resultDisposition );\n        }\n\n        void handleUnfinishedSections() {\n            // If sections ended prematurely due to an exception we stored their\n            // infos here so we can tear them down outside the unwind process.\n            for( std::vector<SectionEndInfo>::const_reverse_iterator it = m_unfinishedSections.rbegin(),\n                        itEnd = m_unfinishedSections.rend();\n                    it != itEnd;\n                    ++it )\n                sectionEnded( *it );\n            m_unfinishedSections.clear();\n        }\n\n        TestRunInfo m_runInfo;\n        IMutableContext& m_context;\n        TestCase const* m_activeTestCase;\n        ITracker* m_testCaseTracker;\n        ITracker* m_currentSectionTracker;\n        AssertionResult m_lastResult;\n\n        Ptr<IConfig const> m_config;\n        Totals m_totals;\n        Ptr<IStreamingReporter> m_reporter;\n        std::vector<MessageInfo> m_messages;\n        AssertionInfo m_lastAssertionInfo;\n        std::vector<SectionEndInfo> m_unfinishedSections;\n        std::vector<ITracker*> m_activeSections;\n        TrackerContext m_trackerContext;\n        bool m_shouldReportUnexpected;\n    };\n\n    IResultCapture& getResultCapture() {\n        if( IResultCapture* capture = getCurrentContext().getResultCapture() )\n            return *capture;\n        else\n            throw std::logic_error( \"No result capture instance\" );\n    }\n\n} // end namespace Catch\n\n// #included from: internal/catch_version.h\n#define TWOBLUECUBES_CATCH_VERSION_H_INCLUDED\n\nnamespace Catch {\n\n    // Versioning information\n    struct Version {\n        Version(    unsigned int _majorVersion,\n                    unsigned int _minorVersion,\n                    unsigned int _patchNumber,\n                    char const * const _branchName,\n                    unsigned int _buildNumber );\n\n        unsigned int const majorVersion;\n        unsigned int const minorVersion;\n        unsigned int const patchNumber;\n\n        // buildNumber is only used if branchName is not null\n        char const * const branchName;\n        unsigned int const buildNumber;\n\n        friend std::ostream& operator << ( std::ostream& os, Version const& version );\n\n    private:\n        void operator=( Version const& );\n    };\n\n    inline Version libraryVersion();\n}\n\n#include <fstream>\n#include <stdlib.h>\n#include <limits>\n\nnamespace Catch {\n\n    Ptr<IStreamingReporter> createReporter( std::string const& reporterName, Ptr<Config> const& config ) {\n        Ptr<IStreamingReporter> reporter = getRegistryHub().getReporterRegistry().create( reporterName, config.get() );\n        if( !reporter ) {\n            std::ostringstream oss;\n            oss << \"No reporter registered with name: '\" << reporterName << \"'\";\n            throw std::domain_error( oss.str() );\n        }\n        return reporter;\n    }\n\n    Ptr<IStreamingReporter> makeReporter( Ptr<Config> const& config ) {\n        std::vector<std::string> reporters = config->getReporterNames();\n        if( reporters.empty() )\n            reporters.push_back( \"console\" );\n\n        Ptr<IStreamingReporter> reporter;\n        for( std::vector<std::string>::const_iterator it = reporters.begin(), itEnd = reporters.end();\n                it != itEnd;\n                ++it )\n            reporter = addReporter( reporter, createReporter( *it, config ) );\n        return reporter;\n    }\n    Ptr<IStreamingReporter> addListeners( Ptr<IConfig const> const& config, Ptr<IStreamingReporter> reporters ) {\n        IReporterRegistry::Listeners listeners = getRegistryHub().getReporterRegistry().getListeners();\n        for( IReporterRegistry::Listeners::const_iterator it = listeners.begin(), itEnd = listeners.end();\n                it != itEnd;\n                ++it )\n            reporters = addReporter(reporters, (*it)->create( ReporterConfig( config ) ) );\n        return reporters;\n    }\n\n    Totals runTests( Ptr<Config> const& config ) {\n\n        Ptr<IConfig const> iconfig = config.get();\n\n        Ptr<IStreamingReporter> reporter = makeReporter( config );\n        reporter = addListeners( iconfig, reporter );\n\n        RunContext context( iconfig, reporter );\n\n        Totals totals;\n\n        context.testGroupStarting( config->name(), 1, 1 );\n\n        TestSpec testSpec = config->testSpec();\n        if( !testSpec.hasFilters() )\n            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( \"~[.]\" ).testSpec(); // All not hidden tests\n\n        std::vector<TestCase> const& allTestCases = getAllTestCasesSorted( *iconfig );\n        for( std::vector<TestCase>::const_iterator it = allTestCases.begin(), itEnd = allTestCases.end();\n                it != itEnd;\n                ++it ) {\n            if( !context.aborting() && matchTest( *it, testSpec, *iconfig ) )\n                totals += context.runTest( *it );\n            else\n                reporter->skipTest( *it );\n        }\n\n        context.testGroupEnded( iconfig->name(), totals, 1, 1 );\n        return totals;\n    }\n\n    void applyFilenamesAsTags( IConfig const& config ) {\n        std::vector<TestCase> const& tests = getAllTestCasesSorted( config );\n        for(std::size_t i = 0; i < tests.size(); ++i ) {\n            TestCase& test = const_cast<TestCase&>( tests[i] );\n            std::set<std::string> tags = test.tags;\n\n            std::string filename = test.lineInfo.file;\n            std::string::size_type lastSlash = filename.find_last_of( \"\\\\/\" );\n            if( lastSlash != std::string::npos )\n                filename = filename.substr( lastSlash+1 );\n\n            std::string::size_type lastDot = filename.find_last_of( \".\" );\n            if( lastDot != std::string::npos )\n                filename = filename.substr( 0, lastDot );\n\n            tags.insert( \"#\" + filename );\n            setTags( test, tags );\n        }\n    }\n\n    class Session : NonCopyable {\n        static bool alreadyInstantiated;\n\n    public:\n\n        struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };\n\n        Session()\n        : m_cli( makeCommandLineParser() ) {\n            if( alreadyInstantiated ) {\n                std::string msg = \"Only one instance of Catch::Session can ever be used\";\n                Catch::cerr() << msg << std::endl;\n                throw std::logic_error( msg );\n            }\n            alreadyInstantiated = true;\n        }\n        ~Session() {\n            Catch::cleanUp();\n        }\n\n        void showHelp( std::string const& processName ) {\n            Catch::cout() << \"\\nCatch v\" << libraryVersion() << \"\\n\";\n\n            m_cli.usage( Catch::cout(), processName );\n            Catch::cout() << \"For more detail usage please see the project docs\\n\" << std::endl;\n        }\n\n        int applyCommandLine( int argc, char const* const* const argv, OnUnusedOptions::DoWhat unusedOptionBehaviour = OnUnusedOptions::Fail ) {\n            try {\n                m_cli.setThrowOnUnrecognisedTokens( unusedOptionBehaviour == OnUnusedOptions::Fail );\n                m_unusedTokens = m_cli.parseInto( Clara::argsToVector( argc, argv ), m_configData );\n                if( m_configData.showHelp )\n                    showHelp( m_configData.processName );\n                m_config.reset();\n            }\n            catch( std::exception& ex ) {\n                {\n                    Colour colourGuard( Colour::Red );\n                    Catch::cerr()\n                        << \"\\nError(s) in input:\\n\"\n                        << Text( ex.what(), TextAttributes().setIndent(2) )\n                        << \"\\n\\n\";\n                }\n                m_cli.usage( Catch::cout(), m_configData.processName );\n                return (std::numeric_limits<int>::max)();\n            }\n            return 0;\n        }\n\n        void useConfigData( ConfigData const& _configData ) {\n            m_configData = _configData;\n            m_config.reset();\n        }\n\n        int run( int argc, char const* const* const argv ) {\n\n            int returnCode = applyCommandLine( argc, argv );\n            if( returnCode == 0 )\n                returnCode = run();\n            return returnCode;\n        }\n\n    #if defined(WIN32) && defined(UNICODE)\n        int run( int argc, wchar_t const* const* const argv ) {\n\n            char **utf8Argv = new char *[ argc ];\n\n            for ( int i = 0; i < argc; ++i ) {\n                int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, NULL, 0, NULL, NULL );\n\n                utf8Argv[ i ] = new char[ bufSize ];\n\n                WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, NULL, NULL );\n            }\n\n            int returnCode = applyCommandLine( argc, utf8Argv );\n            if( returnCode == 0 )\n                returnCode = run();\n\n            for ( int i = 0; i < argc; ++i )\n                delete [] utf8Argv[ i ];\n\n            delete [] utf8Argv;\n\n            return returnCode;\n        }\n    #endif\n\n        int run() {\n            if( m_configData.showHelp )\n                return 0;\n\n            try\n            {\n                config(); // Force config to be constructed\n\n                seedRng( *m_config );\n\n                if( m_configData.filenamesAsTags )\n                    applyFilenamesAsTags( *m_config );\n\n                // Handle list request\n                if( Option<std::size_t> listed = list( config() ) )\n                    return static_cast<int>( *listed );\n\n                return static_cast<int>( runTests( m_config ).assertions.failed );\n            }\n            catch( std::exception& ex ) {\n                Catch::cerr() << ex.what() << std::endl;\n                return (std::numeric_limits<int>::max)();\n            }\n        }\n\n        Clara::CommandLine<ConfigData> const& cli() const {\n            return m_cli;\n        }\n        std::vector<Clara::Parser::Token> const& unusedTokens() const {\n            return m_unusedTokens;\n        }\n        ConfigData& configData() {\n            return m_configData;\n        }\n        Config& config() {\n            if( !m_config )\n                m_config = new Config( m_configData );\n            return *m_config;\n        }\n    private:\n        Clara::CommandLine<ConfigData> m_cli;\n        std::vector<Clara::Parser::Token> m_unusedTokens;\n        ConfigData m_configData;\n        Ptr<Config> m_config;\n    };\n\n    bool Session::alreadyInstantiated = false;\n\n} // end namespace Catch\n\n// #included from: catch_registry_hub.hpp\n#define TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED\n\n// #included from: catch_test_case_registry_impl.hpp\n#define TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED\n\n#include <vector>\n#include <set>\n#include <sstream>\n#include <algorithm>\n\nnamespace Catch {\n\n    struct RandomNumberGenerator {\n        typedef std::ptrdiff_t result_type;\n\n        result_type operator()( result_type n ) const { return std::rand() % n; }\n\n#ifdef CATCH_CONFIG_CPP11_SHUFFLE\n        static constexpr result_type min() { return 0; }\n        static constexpr result_type max() { return 1000000; }\n        result_type operator()() const { return std::rand() % max(); }\n#endif\n        template<typename V>\n        static void shuffle( V& vector ) {\n            RandomNumberGenerator rng;\n#ifdef CATCH_CONFIG_CPP11_SHUFFLE\n            std::shuffle( vector.begin(), vector.end(), rng );\n#else\n            std::random_shuffle( vector.begin(), vector.end(), rng );\n#endif\n        }\n    };\n\n    inline std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases ) {\n\n        std::vector<TestCase> sorted = unsortedTestCases;\n\n        switch( config.runOrder() ) {\n            case RunTests::InLexicographicalOrder:\n                std::sort( sorted.begin(), sorted.end() );\n                break;\n            case RunTests::InRandomOrder:\n                {\n                    seedRng( config );\n                    RandomNumberGenerator::shuffle( sorted );\n                }\n                break;\n            case RunTests::InDeclarationOrder:\n                // already in declaration order\n                break;\n        }\n        return sorted;\n    }\n    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {\n        return testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );\n    }\n\n    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {\n        std::set<TestCase> seenFunctions;\n        for( std::vector<TestCase>::const_iterator it = functions.begin(), itEnd = functions.end();\n            it != itEnd;\n            ++it ) {\n            std::pair<std::set<TestCase>::const_iterator, bool> prev = seenFunctions.insert( *it );\n            if( !prev.second ) {\n                std::ostringstream ss;\n\n                ss  << Colour( Colour::Red )\n                    << \"error: TEST_CASE( \\\"\" << it->name << \"\\\" ) already defined.\\n\"\n                    << \"\\tFirst seen at \" << prev.first->getTestCaseInfo().lineInfo << '\\n'\n                    << \"\\tRedefined at \" << it->getTestCaseInfo().lineInfo << std::endl;\n\n                throw std::runtime_error(ss.str());\n            }\n        }\n    }\n\n    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config ) {\n        std::vector<TestCase> filtered;\n        filtered.reserve( testCases.size() );\n        for( std::vector<TestCase>::const_iterator it = testCases.begin(), itEnd = testCases.end();\n                it != itEnd;\n                ++it )\n            if( matchTest( *it, testSpec, config ) )\n                filtered.push_back( *it );\n        return filtered;\n    }\n    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config ) {\n        return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );\n    }\n\n    class TestRegistry : public ITestCaseRegistry {\n    public:\n        TestRegistry()\n        :   m_currentSortOrder( RunTests::InDeclarationOrder ),\n            m_unnamedCount( 0 )\n        {}\n        virtual ~TestRegistry();\n\n        virtual void registerTest( TestCase const& testCase ) {\n            std::string name = testCase.getTestCaseInfo().name;\n            if( name.empty() ) {\n                std::ostringstream oss;\n                oss << \"Anonymous test case \" << ++m_unnamedCount;\n                return registerTest( testCase.withName( oss.str() ) );\n            }\n            m_functions.push_back( testCase );\n        }\n\n        virtual std::vector<TestCase> const& getAllTests() const {\n            return m_functions;\n        }\n        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const {\n            if( m_sortedFunctions.empty() )\n                enforceNoDuplicateTestCases( m_functions );\n\n            if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {\n                m_sortedFunctions = sortTests( config, m_functions );\n                m_currentSortOrder = config.runOrder();\n            }\n            return m_sortedFunctions;\n        }\n\n    private:\n        std::vector<TestCase> m_functions;\n        mutable RunTests::InWhatOrder m_currentSortOrder;\n        mutable std::vector<TestCase> m_sortedFunctions;\n        size_t m_unnamedCount;\n        std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    class FreeFunctionTestCase : public SharedImpl<ITestCase> {\n    public:\n\n        FreeFunctionTestCase( TestFunction fun ) : m_fun( fun ) {}\n\n        virtual void invoke() const {\n            m_fun();\n        }\n\n    private:\n        virtual ~FreeFunctionTestCase();\n\n        TestFunction m_fun;\n    };\n\n    inline std::string extractClassName( std::string const& classOrQualifiedMethodName ) {\n        std::string className = classOrQualifiedMethodName;\n        if( startsWith( className, '&' ) )\n        {\n            std::size_t lastColons = className.rfind( \"::\" );\n            std::size_t penultimateColons = className.rfind( \"::\", lastColons-1 );\n            if( penultimateColons == std::string::npos )\n                penultimateColons = 1;\n            className = className.substr( penultimateColons, lastColons-penultimateColons );\n        }\n        return className;\n    }\n\n    void registerTestCase\n        (   ITestCase* testCase,\n            char const* classOrQualifiedMethodName,\n            NameAndDesc const& nameAndDesc,\n            SourceLineInfo const& lineInfo ) {\n\n        getMutableRegistryHub().registerTest\n            ( makeTestCase\n                (   testCase,\n                    extractClassName( classOrQualifiedMethodName ),\n                    nameAndDesc.name,\n                    nameAndDesc.description,\n                    lineInfo ) );\n    }\n    void registerTestCaseFunction\n        (   TestFunction function,\n            SourceLineInfo const& lineInfo,\n            NameAndDesc const& nameAndDesc ) {\n        registerTestCase( new FreeFunctionTestCase( function ), \"\", nameAndDesc, lineInfo );\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    AutoReg::AutoReg\n        (   TestFunction function,\n            SourceLineInfo const& lineInfo,\n            NameAndDesc const& nameAndDesc ) {\n        registerTestCaseFunction( function, lineInfo, nameAndDesc );\n    }\n\n    AutoReg::~AutoReg() {}\n\n} // end namespace Catch\n\n// #included from: catch_reporter_registry.hpp\n#define TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED\n\n#include <map>\n\nnamespace Catch {\n\n    class ReporterRegistry : public IReporterRegistry {\n\n    public:\n\n        virtual ~ReporterRegistry() CATCH_OVERRIDE {}\n\n        virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig const> const& config ) const CATCH_OVERRIDE {\n            FactoryMap::const_iterator it =  m_factories.find( name );\n            if( it == m_factories.end() )\n                return CATCH_NULL;\n            return it->second->create( ReporterConfig( config ) );\n        }\n\n        void registerReporter( std::string const& name, Ptr<IReporterFactory> const& factory ) {\n            m_factories.insert( std::make_pair( name, factory ) );\n        }\n        void registerListener( Ptr<IReporterFactory> const& factory ) {\n            m_listeners.push_back( factory );\n        }\n\n        virtual FactoryMap const& getFactories() const CATCH_OVERRIDE {\n            return m_factories;\n        }\n        virtual Listeners const& getListeners() const CATCH_OVERRIDE {\n            return m_listeners;\n        }\n\n    private:\n        FactoryMap m_factories;\n        Listeners m_listeners;\n    };\n}\n\n// #included from: catch_exception_translator_registry.hpp\n#define TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED\n\n#ifdef __OBJC__\n#import \"Foundation/Foundation.h\"\n#endif\n\nnamespace Catch {\n\n    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {\n    public:\n        ~ExceptionTranslatorRegistry() {\n            deleteAll( m_translators );\n        }\n\n        virtual void registerTranslator( const IExceptionTranslator* translator ) {\n            m_translators.push_back( translator );\n        }\n\n        virtual std::string translateActiveException() const {\n            try {\n#ifdef __OBJC__\n                // In Objective-C try objective-c exceptions first\n                @try {\n                    return tryTranslators();\n                }\n                @catch (NSException *exception) {\n                    return Catch::toString( [exception description] );\n                }\n#else\n                return tryTranslators();\n#endif\n            }\n            catch( TestFailureException& ) {\n                throw;\n            }\n            catch( std::exception& ex ) {\n                return ex.what();\n            }\n            catch( std::string& msg ) {\n                return msg;\n            }\n            catch( const char* msg ) {\n                return msg;\n            }\n            catch(...) {\n                return \"Unknown exception\";\n            }\n        }\n\n        std::string tryTranslators() const {\n            if( m_translators.empty() )\n                throw;\n            else\n                return m_translators[0]->translate( m_translators.begin()+1, m_translators.end() );\n        }\n\n    private:\n        std::vector<const IExceptionTranslator*> m_translators;\n    };\n}\n\n// #included from: catch_tag_alias_registry.h\n#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED\n\n#include <map>\n\nnamespace Catch {\n\n    class TagAliasRegistry : public ITagAliasRegistry {\n    public:\n        virtual ~TagAliasRegistry();\n        virtual Option<TagAlias> find( std::string const& alias ) const;\n        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const;\n        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );\n\n    private:\n        std::map<std::string, TagAlias> m_registry;\n    };\n\n} // end namespace Catch\n\nnamespace Catch {\n\n    namespace {\n\n        class RegistryHub : public IRegistryHub, public IMutableRegistryHub {\n\n            RegistryHub( RegistryHub const& );\n            void operator=( RegistryHub const& );\n\n        public: // IRegistryHub\n            RegistryHub() {\n            }\n            virtual IReporterRegistry const& getReporterRegistry() const CATCH_OVERRIDE {\n                return m_reporterRegistry;\n            }\n            virtual ITestCaseRegistry const& getTestCaseRegistry() const CATCH_OVERRIDE {\n                return m_testCaseRegistry;\n            }\n            virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() CATCH_OVERRIDE {\n                return m_exceptionTranslatorRegistry;\n            }\n            virtual ITagAliasRegistry const& getTagAliasRegistry() const CATCH_OVERRIDE {\n                return m_tagAliasRegistry;\n            }\n\n        public: // IMutableRegistryHub\n            virtual void registerReporter( std::string const& name, Ptr<IReporterFactory> const& factory ) CATCH_OVERRIDE {\n                m_reporterRegistry.registerReporter( name, factory );\n            }\n            virtual void registerListener( Ptr<IReporterFactory> const& factory ) CATCH_OVERRIDE {\n                m_reporterRegistry.registerListener( factory );\n            }\n            virtual void registerTest( TestCase const& testInfo ) CATCH_OVERRIDE {\n                m_testCaseRegistry.registerTest( testInfo );\n            }\n            virtual void registerTranslator( const IExceptionTranslator* translator ) CATCH_OVERRIDE {\n                m_exceptionTranslatorRegistry.registerTranslator( translator );\n            }\n            virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) CATCH_OVERRIDE {\n                m_tagAliasRegistry.add( alias, tag, lineInfo );\n            }\n\n        private:\n            TestRegistry m_testCaseRegistry;\n            ReporterRegistry m_reporterRegistry;\n            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;\n            TagAliasRegistry m_tagAliasRegistry;\n        };\n\n        // Single, global, instance\n        inline RegistryHub*& getTheRegistryHub() {\n            static RegistryHub* theRegistryHub = CATCH_NULL;\n            if( !theRegistryHub )\n                theRegistryHub = new RegistryHub();\n            return theRegistryHub;\n        }\n    }\n\n    IRegistryHub& getRegistryHub() {\n        return *getTheRegistryHub();\n    }\n    IMutableRegistryHub& getMutableRegistryHub() {\n        return *getTheRegistryHub();\n    }\n    void cleanUp() {\n        delete getTheRegistryHub();\n        getTheRegistryHub() = CATCH_NULL;\n        cleanUpContext();\n    }\n    std::string translateActiveException() {\n        return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();\n    }\n\n} // end namespace Catch\n\n// #included from: catch_notimplemented_exception.hpp\n#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED\n\n#include <sstream>\n\nnamespace Catch {\n\n    NotImplementedException::NotImplementedException( SourceLineInfo const& lineInfo )\n    :   m_lineInfo( lineInfo ) {\n        std::ostringstream oss;\n        oss << lineInfo << \": function \";\n        oss << \"not implemented\";\n        m_what = oss.str();\n    }\n\n    const char* NotImplementedException::what() const CATCH_NOEXCEPT {\n        return m_what.c_str();\n    }\n\n} // end namespace Catch\n\n// #included from: catch_context_impl.hpp\n#define TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED\n\n// #included from: catch_stream.hpp\n#define TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED\n\n#include <stdexcept>\n#include <cstdio>\n#include <iostream>\n\nnamespace Catch {\n\n    template<typename WriterF, size_t bufferSize=256>\n    class StreamBufImpl : public StreamBufBase {\n        char data[bufferSize];\n        WriterF m_writer;\n\n    public:\n        StreamBufImpl() {\n            setp( data, data + sizeof(data) );\n        }\n\n        ~StreamBufImpl() CATCH_NOEXCEPT {\n            sync();\n        }\n\n    private:\n        int overflow( int c ) {\n            sync();\n\n            if( c != EOF ) {\n                if( pbase() == epptr() )\n                    m_writer( std::string( 1, static_cast<char>( c ) ) );\n                else\n                    sputc( static_cast<char>( c ) );\n            }\n            return 0;\n        }\n\n        int sync() {\n            if( pbase() != pptr() ) {\n                m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );\n                setp( pbase(), epptr() );\n            }\n            return 0;\n        }\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    FileStream::FileStream( std::string const& filename ) {\n        m_ofs.open( filename.c_str() );\n        if( m_ofs.fail() ) {\n            std::ostringstream oss;\n            oss << \"Unable to open file: '\" << filename << '\\'';\n            throw std::domain_error( oss.str() );\n        }\n    }\n\n    std::ostream& FileStream::stream() const {\n        return m_ofs;\n    }\n\n    struct OutputDebugWriter {\n\n        void operator()( std::string const&str ) {\n            writeToDebugConsole( str );\n        }\n    };\n\n    DebugOutStream::DebugOutStream()\n    :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),\n        m_os( m_streamBuf.get() )\n    {}\n\n    std::ostream& DebugOutStream::stream() const {\n        return m_os;\n    }\n\n    // Store the streambuf from cout up-front because\n    // cout may get redirected when running tests\n    CoutStream::CoutStream()\n    :   m_os( Catch::cout().rdbuf() )\n    {}\n\n    std::ostream& CoutStream::stream() const {\n        return m_os;\n    }\n\n#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions\n    std::ostream& cout() {\n        return std::cout;\n    }\n    std::ostream& cerr() {\n        return std::cerr;\n    }\n#endif\n}\n\nnamespace Catch {\n\n    class Context : public IMutableContext {\n\n        Context() : m_config( CATCH_NULL ), m_runner( CATCH_NULL ), m_resultCapture( CATCH_NULL ) {}\n        Context( Context const& );\n        void operator=( Context const& );\n\n    public:\n        virtual ~Context() {\n            deleteAllValues( m_generatorsByTestName );\n        }\n\n    public: // IContext\n        virtual IResultCapture* getResultCapture() {\n            return m_resultCapture;\n        }\n        virtual IRunner* getRunner() {\n            return m_runner;\n        }\n        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) {\n            return getGeneratorsForCurrentTest()\n            .getGeneratorInfo( fileInfo, totalSize )\n            .getCurrentIndex();\n        }\n        virtual bool advanceGeneratorsForCurrentTest() {\n            IGeneratorsForTest* generators = findGeneratorsForCurrentTest();\n            return generators && generators->moveNext();\n        }\n\n        virtual Ptr<IConfig const> getConfig() const {\n            return m_config;\n        }\n\n    public: // IMutableContext\n        virtual void setResultCapture( IResultCapture* resultCapture ) {\n            m_resultCapture = resultCapture;\n        }\n        virtual void setRunner( IRunner* runner ) {\n            m_runner = runner;\n        }\n        virtual void setConfig( Ptr<IConfig const> const& config ) {\n            m_config = config;\n        }\n\n        friend IMutableContext& getCurrentMutableContext();\n\n    private:\n        IGeneratorsForTest* findGeneratorsForCurrentTest() {\n            std::string testName = getResultCapture()->getCurrentTestName();\n\n            std::map<std::string, IGeneratorsForTest*>::const_iterator it =\n                m_generatorsByTestName.find( testName );\n            return it != m_generatorsByTestName.end()\n                ? it->second\n                : CATCH_NULL;\n        }\n\n        IGeneratorsForTest& getGeneratorsForCurrentTest() {\n            IGeneratorsForTest* generators = findGeneratorsForCurrentTest();\n            if( !generators ) {\n                std::string testName = getResultCapture()->getCurrentTestName();\n                generators = createGeneratorsForTest();\n                m_generatorsByTestName.insert( std::make_pair( testName, generators ) );\n            }\n            return *generators;\n        }\n\n    private:\n        Ptr<IConfig const> m_config;\n        IRunner* m_runner;\n        IResultCapture* m_resultCapture;\n        std::map<std::string, IGeneratorsForTest*> m_generatorsByTestName;\n    };\n\n    namespace {\n        Context* currentContext = CATCH_NULL;\n    }\n    IMutableContext& getCurrentMutableContext() {\n        if( !currentContext )\n            currentContext = new Context();\n        return *currentContext;\n    }\n    IContext& getCurrentContext() {\n        return getCurrentMutableContext();\n    }\n\n    void cleanUpContext() {\n        delete currentContext;\n        currentContext = CATCH_NULL;\n    }\n}\n\n// #included from: catch_console_colour_impl.hpp\n#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED\n\n// #included from: catch_errno_guard.hpp\n#define TWOBLUECUBES_CATCH_ERRNO_GUARD_HPP_INCLUDED\n\n#include <cerrno>\n\nnamespace Catch {\n\n    class ErrnoGuard {\n    public:\n        ErrnoGuard():m_oldErrno(errno){}\n        ~ErrnoGuard() { errno = m_oldErrno; }\n    private:\n        int m_oldErrno;\n    };\n\n}\n\nnamespace Catch {\n    namespace {\n\n        struct IColourImpl {\n            virtual ~IColourImpl() {}\n            virtual void use( Colour::Code _colourCode ) = 0;\n        };\n\n        struct NoColourImpl : IColourImpl {\n            void use( Colour::Code ) {}\n\n            static IColourImpl* instance() {\n                static NoColourImpl s_instance;\n                return &s_instance;\n            }\n        };\n\n    } // anon namespace\n} // namespace Catch\n\n#if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )\n#   ifdef CATCH_PLATFORM_WINDOWS\n#       define CATCH_CONFIG_COLOUR_WINDOWS\n#   else\n#       define CATCH_CONFIG_COLOUR_ANSI\n#   endif\n#endif\n\n#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////\n\nnamespace Catch {\nnamespace {\n\n    class Win32ColourImpl : public IColourImpl {\n    public:\n        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )\n        {\n            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;\n            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );\n            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );\n            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );\n        }\n\n        virtual void use( Colour::Code _colourCode ) {\n            switch( _colourCode ) {\n                case Colour::None:      return setTextAttribute( originalForegroundAttributes );\n                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\n                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );\n                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );\n                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );\n                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );\n                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );\n                case Colour::Grey:      return setTextAttribute( 0 );\n\n                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );\n                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );\n                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );\n                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\n\n                case Colour::Bright: throw std::logic_error( \"not a colour\" );\n            }\n        }\n\n    private:\n        void setTextAttribute( WORD _textAttribute ) {\n            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );\n        }\n        HANDLE stdoutHandle;\n        WORD originalForegroundAttributes;\n        WORD originalBackgroundAttributes;\n    };\n\n    IColourImpl* platformColourInstance() {\n        static Win32ColourImpl s_instance;\n\n        Ptr<IConfig const> config = getCurrentContext().getConfig();\n        UseColour::YesOrNo colourMode = config\n            ? config->useColour()\n            : UseColour::Auto;\n        if( colourMode == UseColour::Auto )\n            colourMode = !isDebuggerActive()\n                ? UseColour::Yes\n                : UseColour::No;\n        return colourMode == UseColour::Yes\n            ? &s_instance\n            : NoColourImpl::instance();\n    }\n\n} // end anon namespace\n} // end namespace Catch\n\n#elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////\n\n#include <unistd.h>\n\nnamespace Catch {\nnamespace {\n\n    // use POSIX/ ANSI console terminal codes\n    // Thanks to Adam Strzelecki for original contribution\n    // (http://github.com/nanoant)\n    // https://github.com/philsquared/Catch/pull/131\n    class PosixColourImpl : public IColourImpl {\n    public:\n        virtual void use( Colour::Code _colourCode ) {\n            switch( _colourCode ) {\n                case Colour::None:\n                case Colour::White:     return setColour( \"[0m\" );\n                case Colour::Red:       return setColour( \"[0;31m\" );\n                case Colour::Green:     return setColour( \"[0;32m\" );\n                case Colour::Blue:      return setColour( \"[0;34m\" );\n                case Colour::Cyan:      return setColour( \"[0;36m\" );\n                case Colour::Yellow:    return setColour( \"[0;33m\" );\n                case Colour::Grey:      return setColour( \"[1;30m\" );\n\n                case Colour::LightGrey:     return setColour( \"[0;37m\" );\n                case Colour::BrightRed:     return setColour( \"[1;31m\" );\n                case Colour::BrightGreen:   return setColour( \"[1;32m\" );\n                case Colour::BrightWhite:   return setColour( \"[1;37m\" );\n\n                case Colour::Bright: throw std::logic_error( \"not a colour\" );\n            }\n        }\n        static IColourImpl* instance() {\n            static PosixColourImpl s_instance;\n            return &s_instance;\n        }\n\n    private:\n        void setColour( const char* _escapeCode ) {\n            Catch::cout() << '\\033' << _escapeCode;\n        }\n    };\n\n    IColourImpl* platformColourInstance() {\n        ErrnoGuard guard;\n        Ptr<IConfig const> config = getCurrentContext().getConfig();\n        UseColour::YesOrNo colourMode = config\n            ? config->useColour()\n            : UseColour::Auto;\n        if( colourMode == UseColour::Auto )\n            colourMode = (!isDebuggerActive() && isatty(STDOUT_FILENO) )\n                ? UseColour::Yes\n                : UseColour::No;\n        return colourMode == UseColour::Yes\n            ? PosixColourImpl::instance()\n            : NoColourImpl::instance();\n    }\n\n} // end anon namespace\n} // end namespace Catch\n\n#else  // not Windows or ANSI ///////////////////////////////////////////////\n\nnamespace Catch {\n\n    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }\n\n} // end namespace Catch\n\n#endif // Windows/ ANSI/ None\n\nnamespace Catch {\n\n    Colour::Colour( Code _colourCode ) : m_moved( false ) { use( _colourCode ); }\n    Colour::Colour( Colour const& _other ) : m_moved( false ) { const_cast<Colour&>( _other ).m_moved = true; }\n    Colour::~Colour(){ if( !m_moved ) use( None ); }\n\n    void Colour::use( Code _colourCode ) {\n        static IColourImpl* impl = platformColourInstance();\n        impl->use( _colourCode );\n    }\n\n} // end namespace Catch\n\n// #included from: catch_generators_impl.hpp\n#define TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED\n\n#include <vector>\n#include <string>\n#include <map>\n\nnamespace Catch {\n\n    struct GeneratorInfo : IGeneratorInfo {\n\n        GeneratorInfo( std::size_t size )\n        :   m_size( size ),\n            m_currentIndex( 0 )\n        {}\n\n        bool moveNext() {\n            if( ++m_currentIndex == m_size ) {\n                m_currentIndex = 0;\n                return false;\n            }\n            return true;\n        }\n\n        std::size_t getCurrentIndex() const {\n            return m_currentIndex;\n        }\n\n        std::size_t m_size;\n        std::size_t m_currentIndex;\n    };\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    class GeneratorsForTest : public IGeneratorsForTest {\n\n    public:\n        ~GeneratorsForTest() {\n            deleteAll( m_generatorsInOrder );\n        }\n\n        IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) {\n            std::map<std::string, IGeneratorInfo*>::const_iterator it = m_generatorsByName.find( fileInfo );\n            if( it == m_generatorsByName.end() ) {\n                IGeneratorInfo* info = new GeneratorInfo( size );\n                m_generatorsByName.insert( std::make_pair( fileInfo, info ) );\n                m_generatorsInOrder.push_back( info );\n                return *info;\n            }\n            return *it->second;\n        }\n\n        bool moveNext() {\n            std::vector<IGeneratorInfo*>::const_iterator it = m_generatorsInOrder.begin();\n            std::vector<IGeneratorInfo*>::const_iterator itEnd = m_generatorsInOrder.end();\n            for(; it != itEnd; ++it ) {\n                if( (*it)->moveNext() )\n                    return true;\n            }\n            return false;\n        }\n\n    private:\n        std::map<std::string, IGeneratorInfo*> m_generatorsByName;\n        std::vector<IGeneratorInfo*> m_generatorsInOrder;\n    };\n\n    IGeneratorsForTest* createGeneratorsForTest()\n    {\n        return new GeneratorsForTest();\n    }\n\n} // end namespace Catch\n\n// #included from: catch_assertionresult.hpp\n#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED\n\nnamespace Catch {\n\n    AssertionInfo::AssertionInfo(   char const * _macroName,\n                                    SourceLineInfo const& _lineInfo,\n                                    char const * _capturedExpression,\n                                    ResultDisposition::Flags _resultDisposition,\n                                    char const * _secondArg)\n    :   macroName( _macroName ),\n        lineInfo( _lineInfo ),\n        capturedExpression( _capturedExpression ),\n        resultDisposition( _resultDisposition ),\n        secondArg( _secondArg )\n    {}\n\n    AssertionResult::AssertionResult() {}\n\n    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )\n    :   m_info( info ),\n        m_resultData( data )\n    {}\n\n    AssertionResult::~AssertionResult() {}\n\n    // Result was a success\n    bool AssertionResult::succeeded() const {\n        return Catch::isOk( m_resultData.resultType );\n    }\n\n    // Result was a success, or failure is suppressed\n    bool AssertionResult::isOk() const {\n        return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );\n    }\n\n    ResultWas::OfType AssertionResult::getResultType() const {\n        return m_resultData.resultType;\n    }\n\n    bool AssertionResult::hasExpression() const {\n        return m_info.capturedExpression[0] != 0;\n    }\n\n    bool AssertionResult::hasMessage() const {\n        return !m_resultData.message.empty();\n    }\n\n    std::string capturedExpressionWithSecondArgument( char const * capturedExpression, char const * secondArg ) {\n        return (secondArg[0] == 0 || secondArg[0] == '\"' && secondArg[1] == '\"')\n            ? capturedExpression\n            : std::string(capturedExpression) + \", \" + secondArg;\n    }\n\n    std::string AssertionResult::getExpression() const {\n        if( isFalseTest( m_info.resultDisposition ) )\n            return '!' + capturedExpressionWithSecondArgument(m_info.capturedExpression, m_info.secondArg);\n        else\n            return capturedExpressionWithSecondArgument(m_info.capturedExpression, m_info.secondArg);\n    }\n    std::string AssertionResult::getExpressionInMacro() const {\n        if( m_info.macroName[0] == 0 )\n            return capturedExpressionWithSecondArgument(m_info.capturedExpression, m_info.secondArg);\n        else\n            return std::string(m_info.macroName) + \"( \" + capturedExpressionWithSecondArgument(m_info.capturedExpression, m_info.secondArg) + \" )\";\n    }\n\n    bool AssertionResult::hasExpandedExpression() const {\n        return hasExpression() && getExpandedExpression() != getExpression();\n    }\n\n    std::string AssertionResult::getExpandedExpression() const {\n        return m_resultData.reconstructExpression();\n    }\n\n    std::string AssertionResult::getMessage() const {\n        return m_resultData.message;\n    }\n    SourceLineInfo AssertionResult::getSourceInfo() const {\n        return m_info.lineInfo;\n    }\n\n    std::string AssertionResult::getTestMacroName() const {\n        return m_info.macroName;\n    }\n\n    void AssertionResult::discardDecomposedExpression() const {\n        m_resultData.decomposedExpression = CATCH_NULL;\n    }\n\n    void AssertionResult::expandDecomposedExpression() const {\n        m_resultData.reconstructExpression();\n    }\n\n} // end namespace Catch\n\n// #included from: catch_test_case_info.hpp\n#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED\n\n#include <cctype>\n\nnamespace Catch {\n\n    inline TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {\n        if( startsWith( tag, '.' ) ||\n            tag == \"hide\" ||\n            tag == \"!hide\" )\n            return TestCaseInfo::IsHidden;\n        else if( tag == \"!throws\" )\n            return TestCaseInfo::Throws;\n        else if( tag == \"!shouldfail\" )\n            return TestCaseInfo::ShouldFail;\n        else if( tag == \"!mayfail\" )\n            return TestCaseInfo::MayFail;\n        else if( tag == \"!nonportable\" )\n            return TestCaseInfo::NonPortable;\n        else\n            return TestCaseInfo::None;\n    }\n    inline bool isReservedTag( std::string const& tag ) {\n        return parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !std::isalnum( tag[0] );\n    }\n    inline void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo ) {\n        if( isReservedTag( tag ) ) {\n            std::ostringstream ss;\n            ss << Colour(Colour::Red)\n               << \"Tag name [\" << tag << \"] not allowed.\\n\"\n               << \"Tag names starting with non alpha-numeric characters are reserved\\n\"\n               << Colour(Colour::FileName)\n               << _lineInfo << '\\n';\n            throw std::runtime_error(ss.str());\n        }\n    }\n\n    TestCase makeTestCase(  ITestCase* _testCase,\n                            std::string const& _className,\n                            std::string const& _name,\n                            std::string const& _descOrTags,\n                            SourceLineInfo const& _lineInfo )\n    {\n        bool isHidden( startsWith( _name, \"./\" ) ); // Legacy support\n\n        // Parse out tags\n        std::set<std::string> tags;\n        std::string desc, tag;\n        bool inTag = false;\n        for( std::size_t i = 0; i < _descOrTags.size(); ++i ) {\n            char c = _descOrTags[i];\n            if( !inTag ) {\n                if( c == '[' )\n                    inTag = true;\n                else\n                    desc += c;\n            }\n            else {\n                if( c == ']' ) {\n                    TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );\n                    if( prop == TestCaseInfo::IsHidden )\n                        isHidden = true;\n                    else if( prop == TestCaseInfo::None )\n                        enforceNotReservedTag( tag, _lineInfo );\n\n                    tags.insert( tag );\n                    tag.clear();\n                    inTag = false;\n                }\n                else\n                    tag += c;\n            }\n        }\n        if( isHidden ) {\n            tags.insert( \"hide\" );\n            tags.insert( \".\" );\n        }\n\n        TestCaseInfo info( _name, _className, desc, tags, _lineInfo );\n        return TestCase( _testCase, info );\n    }\n\n    void setTags( TestCaseInfo& testCaseInfo, std::set<std::string> const& tags )\n    {\n        testCaseInfo.tags = tags;\n        testCaseInfo.lcaseTags.clear();\n\n        std::ostringstream oss;\n        for( std::set<std::string>::const_iterator it = tags.begin(), itEnd = tags.end(); it != itEnd; ++it ) {\n            oss << '[' << *it << ']';\n            std::string lcaseTag = toLower( *it );\n            testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );\n            testCaseInfo.lcaseTags.insert( lcaseTag );\n        }\n        testCaseInfo.tagsAsString = oss.str();\n    }\n\n    TestCaseInfo::TestCaseInfo( std::string const& _name,\n                                std::string const& _className,\n                                std::string const& _description,\n                                std::set<std::string> const& _tags,\n                                SourceLineInfo const& _lineInfo )\n    :   name( _name ),\n        className( _className ),\n        description( _description ),\n        lineInfo( _lineInfo ),\n        properties( None )\n    {\n        setTags( *this, _tags );\n    }\n\n    TestCaseInfo::TestCaseInfo( TestCaseInfo const& other )\n    :   name( other.name ),\n        className( other.className ),\n        description( other.description ),\n        tags( other.tags ),\n        lcaseTags( other.lcaseTags ),\n        tagsAsString( other.tagsAsString ),\n        lineInfo( other.lineInfo ),\n        properties( other.properties )\n    {}\n\n    bool TestCaseInfo::isHidden() const {\n        return ( properties & IsHidden ) != 0;\n    }\n    bool TestCaseInfo::throws() const {\n        return ( properties & Throws ) != 0;\n    }\n    bool TestCaseInfo::okToFail() const {\n        return ( properties & (ShouldFail | MayFail ) ) != 0;\n    }\n    bool TestCaseInfo::expectedToFail() const {\n        return ( properties & (ShouldFail ) ) != 0;\n    }\n\n    TestCase::TestCase( ITestCase* testCase, TestCaseInfo const& info ) : TestCaseInfo( info ), test( testCase ) {}\n\n    TestCase::TestCase( TestCase const& other )\n    :   TestCaseInfo( other ),\n        test( other.test )\n    {}\n\n    TestCase TestCase::withName( std::string const& _newName ) const {\n        TestCase other( *this );\n        other.name = _newName;\n        return other;\n    }\n\n    void TestCase::swap( TestCase& other ) {\n        test.swap( other.test );\n        name.swap( other.name );\n        className.swap( other.className );\n        description.swap( other.description );\n        tags.swap( other.tags );\n        lcaseTags.swap( other.lcaseTags );\n        tagsAsString.swap( other.tagsAsString );\n        std::swap( TestCaseInfo::properties, static_cast<TestCaseInfo&>( other ).properties );\n        std::swap( lineInfo, other.lineInfo );\n    }\n\n    void TestCase::invoke() const {\n        test->invoke();\n    }\n\n    bool TestCase::operator == ( TestCase const& other ) const {\n        return  test.get() == other.test.get() &&\n                name == other.name &&\n                className == other.className;\n    }\n\n    bool TestCase::operator < ( TestCase const& other ) const {\n        return name < other.name;\n    }\n    TestCase& TestCase::operator = ( TestCase const& other ) {\n        TestCase temp( other );\n        swap( temp );\n        return *this;\n    }\n\n    TestCaseInfo const& TestCase::getTestCaseInfo() const\n    {\n        return *this;\n    }\n\n} // end namespace Catch\n\n// #included from: catch_version.hpp\n#define TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED\n\nnamespace Catch {\n\n    Version::Version\n        (   unsigned int _majorVersion,\n            unsigned int _minorVersion,\n            unsigned int _patchNumber,\n            char const * const _branchName,\n            unsigned int _buildNumber )\n    :   majorVersion( _majorVersion ),\n        minorVersion( _minorVersion ),\n        patchNumber( _patchNumber ),\n        branchName( _branchName ),\n        buildNumber( _buildNumber )\n    {}\n\n    std::ostream& operator << ( std::ostream& os, Version const& version ) {\n        os  << version.majorVersion << '.'\n            << version.minorVersion << '.'\n            << version.patchNumber;\n        // branchName is never null -> 0th char is \\0 if it is empty\n        if (version.branchName[0]) {\n            os << '-' << version.branchName\n               << '.' << version.buildNumber;\n        }\n        return os;\n    }\n\n    inline Version libraryVersion() {\n        static Version version( 1, 9, 6, \"\", 0 );\n        return version;\n    }\n\n}\n\n// #included from: catch_message.hpp\n#define TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED\n\nnamespace Catch {\n\n    MessageInfo::MessageInfo(   std::string const& _macroName,\n                                SourceLineInfo const& _lineInfo,\n                                ResultWas::OfType _type )\n    :   macroName( _macroName ),\n        lineInfo( _lineInfo ),\n        type( _type ),\n        sequence( ++globalCount )\n    {}\n\n    // This may need protecting if threading support is added\n    unsigned int MessageInfo::globalCount = 0;\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    ScopedMessage::ScopedMessage( MessageBuilder const& builder )\n    : m_info( builder.m_info )\n    {\n        m_info.message = builder.m_stream.str();\n        getResultCapture().pushScopedMessage( m_info );\n    }\n    ScopedMessage::ScopedMessage( ScopedMessage const& other )\n    : m_info( other.m_info )\n    {}\n\n    ScopedMessage::~ScopedMessage() {\n        if ( !std::uncaught_exception() ){\n            getResultCapture().popScopedMessage(m_info);\n        }\n    }\n\n} // end namespace Catch\n\n// #included from: catch_legacy_reporter_adapter.hpp\n#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED\n\n// #included from: catch_legacy_reporter_adapter.h\n#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED\n\nnamespace Catch\n{\n    // Deprecated\n    struct IReporter : IShared {\n        virtual ~IReporter();\n\n        virtual bool shouldRedirectStdout() const = 0;\n\n        virtual void StartTesting() = 0;\n        virtual void EndTesting( Totals const& totals ) = 0;\n        virtual void StartGroup( std::string const& groupName ) = 0;\n        virtual void EndGroup( std::string const& groupName, Totals const& totals ) = 0;\n        virtual void StartTestCase( TestCaseInfo const& testInfo ) = 0;\n        virtual void EndTestCase( TestCaseInfo const& testInfo, Totals const& totals, std::string const& stdOut, std::string const& stdErr ) = 0;\n        virtual void StartSection( std::string const& sectionName, std::string const& description ) = 0;\n        virtual void EndSection( std::string const& sectionName, Counts const& assertions ) = 0;\n        virtual void NoAssertionsInSection( std::string const& sectionName ) = 0;\n        virtual void NoAssertionsInTestCase( std::string const& testName ) = 0;\n        virtual void Aborted() = 0;\n        virtual void Result( AssertionResult const& result ) = 0;\n    };\n\n    class LegacyReporterAdapter : public SharedImpl<IStreamingReporter>\n    {\n    public:\n        LegacyReporterAdapter( Ptr<IReporter> const& legacyReporter );\n        virtual ~LegacyReporterAdapter();\n\n        virtual ReporterPreferences getPreferences() const;\n        virtual void noMatchingTestCases( std::string const& );\n        virtual void testRunStarting( TestRunInfo const& );\n        virtual void testGroupStarting( GroupInfo const& groupInfo );\n        virtual void testCaseStarting( TestCaseInfo const& testInfo );\n        virtual void sectionStarting( SectionInfo const& sectionInfo );\n        virtual void assertionStarting( AssertionInfo const& );\n        virtual bool assertionEnded( AssertionStats const& assertionStats );\n        virtual void sectionEnded( SectionStats const& sectionStats );\n        virtual void testCaseEnded( TestCaseStats const& testCaseStats );\n        virtual void testGroupEnded( TestGroupStats const& testGroupStats );\n        virtual void testRunEnded( TestRunStats const& testRunStats );\n        virtual void skipTest( TestCaseInfo const& );\n\n    private:\n        Ptr<IReporter> m_legacyReporter;\n    };\n}\n\nnamespace Catch\n{\n    LegacyReporterAdapter::LegacyReporterAdapter( Ptr<IReporter> const& legacyReporter )\n    :   m_legacyReporter( legacyReporter )\n    {}\n    LegacyReporterAdapter::~LegacyReporterAdapter() {}\n\n    ReporterPreferences LegacyReporterAdapter::getPreferences() const {\n        ReporterPreferences prefs;\n        prefs.shouldRedirectStdOut = m_legacyReporter->shouldRedirectStdout();\n        return prefs;\n    }\n\n    void LegacyReporterAdapter::noMatchingTestCases( std::string const& ) {}\n    void LegacyReporterAdapter::testRunStarting( TestRunInfo const& ) {\n        m_legacyReporter->StartTesting();\n    }\n    void LegacyReporterAdapter::testGroupStarting( GroupInfo const& groupInfo ) {\n        m_legacyReporter->StartGroup( groupInfo.name );\n    }\n    void LegacyReporterAdapter::testCaseStarting( TestCaseInfo const& testInfo ) {\n        m_legacyReporter->StartTestCase( testInfo );\n    }\n    void LegacyReporterAdapter::sectionStarting( SectionInfo const& sectionInfo ) {\n        m_legacyReporter->StartSection( sectionInfo.name, sectionInfo.description );\n    }\n    void LegacyReporterAdapter::assertionStarting( AssertionInfo const& ) {\n        // Not on legacy interface\n    }\n\n    bool LegacyReporterAdapter::assertionEnded( AssertionStats const& assertionStats ) {\n        if( assertionStats.assertionResult.getResultType() != ResultWas::Ok ) {\n            for( std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();\n                    it != itEnd;\n                    ++it ) {\n                if( it->type == ResultWas::Info ) {\n                    ResultBuilder rb( it->macroName.c_str(), it->lineInfo, \"\", ResultDisposition::Normal );\n                    rb << it->message;\n                    rb.setResultType( ResultWas::Info );\n                    AssertionResult result = rb.build();\n                    m_legacyReporter->Result( result );\n                }\n            }\n        }\n        m_legacyReporter->Result( assertionStats.assertionResult );\n        return true;\n    }\n    void LegacyReporterAdapter::sectionEnded( SectionStats const& sectionStats ) {\n        if( sectionStats.missingAssertions )\n            m_legacyReporter->NoAssertionsInSection( sectionStats.sectionInfo.name );\n        m_legacyReporter->EndSection( sectionStats.sectionInfo.name, sectionStats.assertions );\n    }\n    void LegacyReporterAdapter::testCaseEnded( TestCaseStats const& testCaseStats ) {\n        m_legacyReporter->EndTestCase\n            (   testCaseStats.testInfo,\n                testCaseStats.totals,\n                testCaseStats.stdOut,\n                testCaseStats.stdErr );\n    }\n    void LegacyReporterAdapter::testGroupEnded( TestGroupStats const& testGroupStats ) {\n        if( testGroupStats.aborting )\n            m_legacyReporter->Aborted();\n        m_legacyReporter->EndGroup( testGroupStats.groupInfo.name, testGroupStats.totals );\n    }\n    void LegacyReporterAdapter::testRunEnded( TestRunStats const& testRunStats ) {\n        m_legacyReporter->EndTesting( testRunStats.totals );\n    }\n    void LegacyReporterAdapter::skipTest( TestCaseInfo const& ) {\n    }\n}\n\n// #included from: catch_timer.hpp\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++11-long-long\"\n#endif\n\n#ifdef CATCH_PLATFORM_WINDOWS\n\n#else\n\n#include <sys/time.h>\n\n#endif\n\nnamespace Catch {\n\n    namespace {\n#ifdef CATCH_PLATFORM_WINDOWS\n        UInt64 getCurrentTicks() {\n            static UInt64 hz=0, hzo=0;\n            if (!hz) {\n                QueryPerformanceFrequency( reinterpret_cast<LARGE_INTEGER*>( &hz ) );\n                QueryPerformanceCounter( reinterpret_cast<LARGE_INTEGER*>( &hzo ) );\n            }\n            UInt64 t;\n            QueryPerformanceCounter( reinterpret_cast<LARGE_INTEGER*>( &t ) );\n            return ((t-hzo)*1000000)/hz;\n        }\n#else\n        UInt64 getCurrentTicks() {\n            timeval t;\n            gettimeofday(&t,CATCH_NULL);\n            return static_cast<UInt64>( t.tv_sec ) * 1000000ull + static_cast<UInt64>( t.tv_usec );\n        }\n#endif\n    }\n\n    void Timer::start() {\n        m_ticks = getCurrentTicks();\n    }\n    unsigned int Timer::getElapsedMicroseconds() const {\n        return static_cast<unsigned int>(getCurrentTicks() - m_ticks);\n    }\n    unsigned int Timer::getElapsedMilliseconds() const {\n        return static_cast<unsigned int>(getElapsedMicroseconds()/1000);\n    }\n    double Timer::getElapsedSeconds() const {\n        return getElapsedMicroseconds()/1000000.0;\n    }\n\n} // namespace Catch\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// #included from: catch_common.hpp\n#define TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED\n\n#include <cstring>\n#include <cctype>\n\nnamespace Catch {\n\n    bool startsWith( std::string const& s, std::string const& prefix ) {\n        return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());\n    }\n    bool startsWith( std::string const& s, char prefix ) {\n        return !s.empty() && s[0] == prefix;\n    }\n    bool endsWith( std::string const& s, std::string const& suffix ) {\n        return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());\n    }\n    bool endsWith( std::string const& s, char suffix ) {\n        return !s.empty() && s[s.size()-1] == suffix;\n    }\n    bool contains( std::string const& s, std::string const& infix ) {\n        return s.find( infix ) != std::string::npos;\n    }\n    char toLowerCh(char c) {\n        return static_cast<char>( std::tolower( c ) );\n    }\n    void toLowerInPlace( std::string& s ) {\n        std::transform( s.begin(), s.end(), s.begin(), toLowerCh );\n    }\n    std::string toLower( std::string const& s ) {\n        std::string lc = s;\n        toLowerInPlace( lc );\n        return lc;\n    }\n    std::string trim( std::string const& str ) {\n        static char const* whitespaceChars = \"\\n\\r\\t \";\n        std::string::size_type start = str.find_first_not_of( whitespaceChars );\n        std::string::size_type end = str.find_last_not_of( whitespaceChars );\n\n        return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();\n    }\n\n    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {\n        bool replaced = false;\n        std::size_t i = str.find( replaceThis );\n        while( i != std::string::npos ) {\n            replaced = true;\n            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );\n            if( i < str.size()-withThis.size() )\n                i = str.find( replaceThis, i+withThis.size() );\n            else\n                i = std::string::npos;\n        }\n        return replaced;\n    }\n\n    pluralise::pluralise( std::size_t count, std::string const& label )\n    :   m_count( count ),\n        m_label( label )\n    {}\n\n    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {\n        os << pluraliser.m_count << ' ' << pluraliser.m_label;\n        if( pluraliser.m_count != 1 )\n            os << 's';\n        return os;\n    }\n\n    SourceLineInfo::SourceLineInfo() : file(\"\"), line( 0 ){}\n    SourceLineInfo::SourceLineInfo( char const* _file, std::size_t _line )\n    :   file( _file ),\n        line( _line )\n    {}\n    bool SourceLineInfo::empty() const {\n        return file[0] == '\\0';\n    }\n    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const {\n        return line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);\n    }\n    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const {\n        return line < other.line || ( line == other.line && (std::strcmp(file, other.file) < 0));\n    }\n\n    void seedRng( IConfig const& config ) {\n        if( config.rngSeed() != 0 )\n            std::srand( config.rngSeed() );\n    }\n    unsigned int rngSeed() {\n        return getCurrentContext().getConfig()->rngSeed();\n    }\n\n    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {\n#ifndef __GNUG__\n        os << info.file << '(' << info.line << ')';\n#else\n        os << info.file << ':' << info.line;\n#endif\n        return os;\n    }\n\n    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo ) {\n        std::ostringstream oss;\n        oss << locationInfo << \": Internal Catch error: '\" << message << '\\'';\n        if( alwaysTrue() )\n            throw std::logic_error( oss.str() );\n    }\n}\n\n// #included from: catch_section.hpp\n#define TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED\n\nnamespace Catch {\n\n    SectionInfo::SectionInfo\n        (   SourceLineInfo const& _lineInfo,\n            std::string const& _name,\n            std::string const& _description )\n    :   name( _name ),\n        description( _description ),\n        lineInfo( _lineInfo )\n    {}\n\n    Section::Section( SectionInfo const& info )\n    :   m_info( info ),\n        m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )\n    {\n        m_timer.start();\n    }\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable:4996) // std::uncaught_exception is deprecated in C++17\n#endif\n    Section::~Section() {\n        if( m_sectionIncluded ) {\n            SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );\n            if( std::uncaught_exception() )\n                getResultCapture().sectionEndedEarly( endInfo );\n            else\n                getResultCapture().sectionEnded( endInfo );\n        }\n    }\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n    // This indicates whether the section should be executed or not\n    Section::operator bool() const {\n        return m_sectionIncluded;\n    }\n\n} // end namespace Catch\n\n// #included from: catch_debugger.hpp\n#define TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED\n\n#ifdef CATCH_PLATFORM_MAC\n\n    #include <assert.h>\n    #include <stdbool.h>\n    #include <sys/types.h>\n    #include <unistd.h>\n    #include <sys/sysctl.h>\n\n    namespace Catch{\n\n        // The following function is taken directly from the following technical note:\n        // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html\n\n        // Returns true if the current process is being debugged (either\n        // running under the debugger or has a debugger attached post facto).\n        bool isDebuggerActive(){\n\n            int                 mib[4];\n            struct kinfo_proc   info;\n            size_t              size;\n\n            // Initialize the flags so that, if sysctl fails for some bizarre\n            // reason, we get a predictable result.\n\n            info.kp_proc.p_flag = 0;\n\n            // Initialize mib, which tells sysctl the info we want, in this case\n            // we're looking for information about a specific process ID.\n\n            mib[0] = CTL_KERN;\n            mib[1] = KERN_PROC;\n            mib[2] = KERN_PROC_PID;\n            mib[3] = getpid();\n\n            // Call sysctl.\n\n            size = sizeof(info);\n            if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, CATCH_NULL, 0) != 0 ) {\n                Catch::cerr() << \"\\n** Call to sysctl failed - unable to determine if debugger is active **\\n\" << std::endl;\n                return false;\n            }\n\n            // We're being debugged if the P_TRACED flag is set.\n\n            return ( (info.kp_proc.p_flag & P_TRACED) != 0 );\n        }\n    } // namespace Catch\n\n#elif defined(CATCH_PLATFORM_LINUX)\n    #include <fstream>\n    #include <string>\n\n    namespace Catch{\n        // The standard POSIX way of detecting a debugger is to attempt to\n        // ptrace() the process, but this needs to be done from a child and not\n        // this process itself to still allow attaching to this process later\n        // if wanted, so is rather heavy. Under Linux we have the PID of the\n        // \"debugger\" (which doesn't need to be gdb, of course, it could also\n        // be strace, for example) in /proc/$PID/status, so just get it from\n        // there instead.\n        bool isDebuggerActive(){\n            // Libstdc++ has a bug, where std::ifstream sets errno to 0\n            // This way our users can properly assert over errno values\n            ErrnoGuard guard;\n            std::ifstream in(\"/proc/self/status\");\n            for( std::string line; std::getline(in, line); ) {\n                static const int PREFIX_LEN = 11;\n                if( line.compare(0, PREFIX_LEN, \"TracerPid:\\t\") == 0 ) {\n                    // We're traced if the PID is not 0 and no other PID starts\n                    // with 0 digit, so it's enough to check for just a single\n                    // character.\n                    return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';\n                }\n            }\n\n            return false;\n        }\n    } // namespace Catch\n#elif defined(_MSC_VER)\n    extern \"C\" __declspec(dllimport) int __stdcall IsDebuggerPresent();\n    namespace Catch {\n        bool isDebuggerActive() {\n            return IsDebuggerPresent() != 0;\n        }\n    }\n#elif defined(__MINGW32__)\n    extern \"C\" __declspec(dllimport) int __stdcall IsDebuggerPresent();\n    namespace Catch {\n        bool isDebuggerActive() {\n            return IsDebuggerPresent() != 0;\n        }\n    }\n#else\n    namespace Catch {\n       inline bool isDebuggerActive() { return false; }\n    }\n#endif // Platform\n\n#ifdef CATCH_PLATFORM_WINDOWS\n\n    namespace Catch {\n        void writeToDebugConsole( std::string const& text ) {\n            ::OutputDebugStringA( text.c_str() );\n        }\n    }\n#else\n    namespace Catch {\n        void writeToDebugConsole( std::string const& text ) {\n            // !TBD: Need a version for Mac/ XCode and other IDEs\n            Catch::cout() << text;\n        }\n    }\n#endif // Platform\n\n// #included from: catch_tostring.hpp\n#define TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED\n\nnamespace Catch {\n\nnamespace Detail {\n\n    const std::string unprintableString = \"{?}\";\n\n    namespace {\n        const int hexThreshold = 255;\n\n        struct Endianness {\n            enum Arch { Big, Little };\n\n            static Arch which() {\n                union _{\n                    int asInt;\n                    char asChar[sizeof (int)];\n                } u;\n\n                u.asInt = 1;\n                return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;\n            }\n        };\n    }\n\n    std::string rawMemoryToString( const void *object, std::size_t size )\n    {\n        // Reverse order for little endian architectures\n        int i = 0, end = static_cast<int>( size ), inc = 1;\n        if( Endianness::which() == Endianness::Little ) {\n            i = end-1;\n            end = inc = -1;\n        }\n\n        unsigned char const *bytes = static_cast<unsigned char const *>(object);\n        std::ostringstream os;\n        os << \"0x\" << std::setfill('0') << std::hex;\n        for( ; i != end; i += inc )\n             os << std::setw(2) << static_cast<unsigned>(bytes[i]);\n       return os.str();\n    }\n}\n\nstd::string toString( std::string const& value ) {\n    std::string s = value;\n    if( getCurrentContext().getConfig()->showInvisibles() ) {\n        for(size_t i = 0; i < s.size(); ++i ) {\n            std::string subs;\n            switch( s[i] ) {\n            case '\\n': subs = \"\\\\n\"; break;\n            case '\\t': subs = \"\\\\t\"; break;\n            default: break;\n            }\n            if( !subs.empty() ) {\n                s = s.substr( 0, i ) + subs + s.substr( i+1 );\n                ++i;\n            }\n        }\n    }\n    return '\"' + s + '\"';\n}\nstd::string toString( std::wstring const& value ) {\n\n    std::string s;\n    s.reserve( value.size() );\n    for(size_t i = 0; i < value.size(); ++i )\n        s += value[i] <= 0xff ? static_cast<char>( value[i] ) : '?';\n    return Catch::toString( s );\n}\n\nstd::string toString( const char* const value ) {\n    return value ? Catch::toString( std::string( value ) ) : std::string( \"{null string}\" );\n}\n\nstd::string toString( char* const value ) {\n    return Catch::toString( static_cast<const char*>( value ) );\n}\n\nstd::string toString( const wchar_t* const value )\n{\n    return value ? Catch::toString( std::wstring(value) ) : std::string( \"{null string}\" );\n}\n\nstd::string toString( wchar_t* const value )\n{\n    return Catch::toString( static_cast<const wchar_t*>( value ) );\n}\n\nstd::string toString( int value ) {\n    std::ostringstream oss;\n    oss << value;\n    if( value > Detail::hexThreshold )\n        oss << \" (0x\" << std::hex << value << ')';\n    return oss.str();\n}\n\nstd::string toString( unsigned long value ) {\n    std::ostringstream oss;\n    oss << value;\n    if( value > Detail::hexThreshold )\n        oss << \" (0x\" << std::hex << value << ')';\n    return oss.str();\n}\n\nstd::string toString( unsigned int value ) {\n    return Catch::toString( static_cast<unsigned long>( value ) );\n}\n\ntemplate<typename T>\nstd::string fpToString( T value, int precision ) {\n    std::ostringstream oss;\n    oss << std::setprecision( precision )\n        << std::fixed\n        << value;\n    std::string d = oss.str();\n    std::size_t i = d.find_last_not_of( '0' );\n    if( i != std::string::npos && i != d.size()-1 ) {\n        if( d[i] == '.' )\n            i++;\n        d = d.substr( 0, i+1 );\n    }\n    return d;\n}\n\nstd::string toString( const double value ) {\n    return fpToString( value, 10 );\n}\nstd::string toString( const float value ) {\n    return fpToString( value, 5 ) + 'f';\n}\n\nstd::string toString( bool value ) {\n    return value ? \"true\" : \"false\";\n}\n\nstd::string toString( char value ) {\n    if ( value == '\\r' )\n        return \"'\\\\r'\";\n    if ( value == '\\f' )\n        return \"'\\\\f'\";\n    if ( value == '\\n' )\n        return \"'\\\\n'\";\n    if ( value == '\\t' )\n        return \"'\\\\t'\";\n    if ( '\\0' <= value && value < ' ' )\n        return toString( static_cast<unsigned int>( value ) );\n    char chstr[] = \"' '\";\n    chstr[1] = value;\n    return chstr;\n}\n\nstd::string toString( signed char value ) {\n    return toString( static_cast<char>( value ) );\n}\n\nstd::string toString( unsigned char value ) {\n    return toString( static_cast<char>( value ) );\n}\n\n#ifdef CATCH_CONFIG_CPP11_LONG_LONG\nstd::string toString( long long value ) {\n    std::ostringstream oss;\n    oss << value;\n    if( value > Detail::hexThreshold )\n        oss << \" (0x\" << std::hex << value << ')';\n    return oss.str();\n}\nstd::string toString( unsigned long long value ) {\n    std::ostringstream oss;\n    oss << value;\n    if( value > Detail::hexThreshold )\n        oss << \" (0x\" << std::hex << value << ')';\n    return oss.str();\n}\n#endif\n\n#ifdef CATCH_CONFIG_CPP11_NULLPTR\nstd::string toString( std::nullptr_t ) {\n    return \"nullptr\";\n}\n#endif\n\n#ifdef __OBJC__\n    std::string toString( NSString const * const& nsstring ) {\n        if( !nsstring )\n            return \"nil\";\n        return \"@\" + toString([nsstring UTF8String]);\n    }\n    std::string toString( NSString * CATCH_ARC_STRONG & nsstring ) {\n        if( !nsstring )\n            return \"nil\";\n        return \"@\" + toString([nsstring UTF8String]);\n    }\n    std::string toString( NSObject* const& nsObject ) {\n        return toString( [nsObject description] );\n    }\n#endif\n\n} // end namespace Catch\n\n// #included from: catch_result_builder.hpp\n#define TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED\n\nnamespace Catch {\n\n    ResultBuilder::ResultBuilder(   char const* macroName,\n                                    SourceLineInfo const& lineInfo,\n                                    char const* capturedExpression,\n                                    ResultDisposition::Flags resultDisposition,\n                                    char const* secondArg )\n    :   m_assertionInfo( macroName, lineInfo, capturedExpression, resultDisposition, secondArg ),\n        m_shouldDebugBreak( false ),\n        m_shouldThrow( false ),\n        m_guardException( false )\n    {\n        m_stream().oss.str(\"\");\n    }\n\n    ResultBuilder::~ResultBuilder() {\n#if defined(CATCH_CONFIG_FAST_COMPILE)\n        if ( m_guardException ) {\n            m_stream().oss << \"Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\";\n            captureResult( ResultWas::ThrewException );\n            getCurrentContext().getResultCapture()->exceptionEarlyReported();\n        }\n#endif\n    }\n\n    ResultBuilder& ResultBuilder::setResultType( ResultWas::OfType result ) {\n        m_data.resultType = result;\n        return *this;\n    }\n    ResultBuilder& ResultBuilder::setResultType( bool result ) {\n        m_data.resultType = result ? ResultWas::Ok : ResultWas::ExpressionFailed;\n        return *this;\n    }\n\n    void ResultBuilder::endExpression( DecomposedExpression const& expr ) {\n        AssertionResult result = build( expr );\n        handleResult( result );\n    }\n\n    void ResultBuilder::useActiveException( ResultDisposition::Flags resultDisposition ) {\n        m_assertionInfo.resultDisposition = resultDisposition;\n        m_stream().oss << Catch::translateActiveException();\n        captureResult( ResultWas::ThrewException );\n    }\n\n    void ResultBuilder::captureResult( ResultWas::OfType resultType ) {\n        setResultType( resultType );\n        captureExpression();\n    }\n\n    void ResultBuilder::captureExpectedException( std::string const& expectedMessage ) {\n        if( expectedMessage.empty() )\n            captureExpectedException( Matchers::Impl::MatchAllOf<std::string>() );\n        else\n            captureExpectedException( Matchers::Equals( expectedMessage ) );\n    }\n\n    void ResultBuilder::captureExpectedException( Matchers::Impl::MatcherBase<std::string> const& matcher ) {\n\n        assert( !isFalseTest( m_assertionInfo.resultDisposition ) );\n        AssertionResultData data = m_data;\n        data.resultType = ResultWas::Ok;\n        data.reconstructedExpression = capturedExpressionWithSecondArgument(m_assertionInfo.capturedExpression, m_assertionInfo.secondArg);\n\n        std::string actualMessage = Catch::translateActiveException();\n        if( !matcher.match( actualMessage ) ) {\n            data.resultType = ResultWas::ExpressionFailed;\n            data.reconstructedExpression = actualMessage;\n        }\n        AssertionResult result( m_assertionInfo, data );\n        handleResult( result );\n    }\n\n    void ResultBuilder::captureExpression() {\n        AssertionResult result = build();\n        handleResult( result );\n    }\n\n    void ResultBuilder::handleResult( AssertionResult const& result )\n    {\n        getResultCapture().assertionEnded( result );\n\n        if( !result.isOk() ) {\n            if( getCurrentContext().getConfig()->shouldDebugBreak() )\n                m_shouldDebugBreak = true;\n            if( getCurrentContext().getRunner()->aborting() || (m_assertionInfo.resultDisposition & ResultDisposition::Normal) )\n                m_shouldThrow = true;\n        }\n    }\n\n    void ResultBuilder::react() {\n#if defined(CATCH_CONFIG_FAST_COMPILE)\n        if (m_shouldDebugBreak) {\n            ///////////////////////////////////////////////////////////////////\n            // To inspect the state during test, you need to go one level up the callstack\n            // To go back to the test and change execution, jump over the throw statement\n            ///////////////////////////////////////////////////////////////////\n            CATCH_BREAK_INTO_DEBUGGER();\n        }\n#endif\n        if( m_shouldThrow )\n            throw Catch::TestFailureException();\n    }\n\n    bool ResultBuilder::shouldDebugBreak() const { return m_shouldDebugBreak; }\n    bool ResultBuilder::allowThrows() const { return getCurrentContext().getConfig()->allowThrows(); }\n\n    AssertionResult ResultBuilder::build() const\n    {\n        return build( *this );\n    }\n\n    // CAVEAT: The returned AssertionResult stores a pointer to the argument expr,\n    //         a temporary DecomposedExpression, which in turn holds references to\n    //         operands, possibly temporary as well.\n    //         It should immediately be passed to handleResult; if the expression\n    //         needs to be reported, its string expansion must be composed before\n    //         the temporaries are destroyed.\n    AssertionResult ResultBuilder::build( DecomposedExpression const& expr ) const\n    {\n        assert( m_data.resultType != ResultWas::Unknown );\n        AssertionResultData data = m_data;\n\n        // Flip bool results if FalseTest flag is set\n        if( isFalseTest( m_assertionInfo.resultDisposition ) ) {\n            data.negate( expr.isBinaryExpression() );\n        }\n\n        data.message = m_stream().oss.str();\n        data.decomposedExpression = &expr; // for lazy reconstruction\n        return AssertionResult( m_assertionInfo, data );\n    }\n\n    void ResultBuilder::reconstructExpression( std::string& dest ) const {\n        dest = capturedExpressionWithSecondArgument(m_assertionInfo.capturedExpression, m_assertionInfo.secondArg);\n    }\n\n    void ResultBuilder::setExceptionGuard() {\n        m_guardException = true;\n    }\n    void ResultBuilder::unsetExceptionGuard() {\n        m_guardException = false;\n    }\n\n} // end namespace Catch\n\n// #included from: catch_tag_alias_registry.hpp\n#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED\n\nnamespace Catch {\n\n    TagAliasRegistry::~TagAliasRegistry() {}\n\n    Option<TagAlias> TagAliasRegistry::find( std::string const& alias ) const {\n        std::map<std::string, TagAlias>::const_iterator it = m_registry.find( alias );\n        if( it != m_registry.end() )\n            return it->second;\n        else\n            return Option<TagAlias>();\n    }\n\n    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {\n        std::string expandedTestSpec = unexpandedTestSpec;\n        for( std::map<std::string, TagAlias>::const_iterator it = m_registry.begin(), itEnd = m_registry.end();\n                it != itEnd;\n                ++it ) {\n            std::size_t pos = expandedTestSpec.find( it->first );\n            if( pos != std::string::npos ) {\n                expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +\n                                    it->second.tag +\n                                    expandedTestSpec.substr( pos + it->first.size() );\n            }\n        }\n        return expandedTestSpec;\n    }\n\n    void TagAliasRegistry::add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) {\n\n        if( !startsWith( alias, \"[@\" ) || !endsWith( alias, ']' ) ) {\n            std::ostringstream oss;\n            oss << Colour( Colour::Red )\n                << \"error: tag alias, \\\"\" << alias << \"\\\" is not of the form [@alias name].\\n\"\n                << Colour( Colour::FileName )\n                << lineInfo << '\\n';\n            throw std::domain_error( oss.str().c_str() );\n        }\n        if( !m_registry.insert( std::make_pair( alias, TagAlias( tag, lineInfo ) ) ).second ) {\n            std::ostringstream oss;\n            oss << Colour( Colour::Red )\n                << \"error: tag alias, \\\"\" << alias << \"\\\" already registered.\\n\"\n                << \"\\tFirst seen at \"\n                << Colour( Colour::Red ) << find(alias)->lineInfo << '\\n'\n                << Colour( Colour::Red ) << \"\\tRedefined at \"\n                << Colour( Colour::FileName) << lineInfo << '\\n';\n            throw std::domain_error( oss.str().c_str() );\n        }\n    }\n\n    ITagAliasRegistry::~ITagAliasRegistry() {}\n\n    ITagAliasRegistry const& ITagAliasRegistry::get() {\n        return getRegistryHub().getTagAliasRegistry();\n    }\n\n    RegistrarForTagAliases::RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo ) {\n        getMutableRegistryHub().registerTagAlias( alias, tag, lineInfo );\n    }\n\n} // end namespace Catch\n\n// #included from: catch_matchers_string.hpp\n\nnamespace Catch {\nnamespace Matchers {\n\n    namespace StdString {\n\n        CasedString::CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )\n        :   m_caseSensitivity( caseSensitivity ),\n            m_str( adjustString( str ) )\n        {}\n        std::string CasedString::adjustString( std::string const& str ) const {\n            return m_caseSensitivity == CaseSensitive::No\n                   ? toLower( str )\n                   : str;\n        }\n        std::string CasedString::caseSensitivitySuffix() const {\n            return m_caseSensitivity == CaseSensitive::No\n                   ? \" (case insensitive)\"\n                   : std::string();\n        }\n\n        StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )\n        : m_comparator( comparator ),\n          m_operation( operation ) {\n        }\n\n        std::string StringMatcherBase::describe() const {\n            std::string description;\n            description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +\n                                        m_comparator.caseSensitivitySuffix().size());\n            description += m_operation;\n            description += \": \\\"\";\n            description += m_comparator.m_str;\n            description += \"\\\"\";\n            description += m_comparator.caseSensitivitySuffix();\n            return description;\n        }\n\n        EqualsMatcher::EqualsMatcher( CasedString const& comparator ) : StringMatcherBase( \"equals\", comparator ) {}\n\n        bool EqualsMatcher::match( std::string const& source ) const {\n            return m_comparator.adjustString( source ) == m_comparator.m_str;\n        }\n\n        ContainsMatcher::ContainsMatcher( CasedString const& comparator ) : StringMatcherBase( \"contains\", comparator ) {}\n\n        bool ContainsMatcher::match( std::string const& source ) const {\n            return contains( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( \"starts with\", comparator ) {}\n\n        bool StartsWithMatcher::match( std::string const& source ) const {\n            return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n        EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( \"ends with\", comparator ) {}\n\n        bool EndsWithMatcher::match( std::string const& source ) const {\n            return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );\n        }\n\n    } // namespace StdString\n\n    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {\n        return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );\n    }\n\n} // namespace Matchers\n} // namespace Catch\n// #included from: ../reporters/catch_reporter_multi.hpp\n#define TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED\n\nnamespace Catch {\n\nclass MultipleReporters : public SharedImpl<IStreamingReporter> {\n    typedef std::vector<Ptr<IStreamingReporter> > Reporters;\n    Reporters m_reporters;\n\npublic:\n    void add( Ptr<IStreamingReporter> const& reporter ) {\n        m_reporters.push_back( reporter );\n    }\n\npublic: // IStreamingReporter\n\n    virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {\n        return m_reporters[0]->getPreferences();\n    }\n\n    virtual void noMatchingTestCases( std::string const& spec ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->noMatchingTestCases( spec );\n    }\n\n    virtual void testRunStarting( TestRunInfo const& testRunInfo ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->testRunStarting( testRunInfo );\n    }\n\n    virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->testGroupStarting( groupInfo );\n    }\n\n    virtual void testCaseStarting( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->testCaseStarting( testInfo );\n    }\n\n    virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->sectionStarting( sectionInfo );\n    }\n\n    virtual void assertionStarting( AssertionInfo const& assertionInfo ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->assertionStarting( assertionInfo );\n    }\n\n    // The return value indicates if the messages buffer should be cleared:\n    virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {\n        bool clearBuffer = false;\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            clearBuffer |= (*it)->assertionEnded( assertionStats );\n        return clearBuffer;\n    }\n\n    virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->sectionEnded( sectionStats );\n    }\n\n    virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->testCaseEnded( testCaseStats );\n    }\n\n    virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->testGroupEnded( testGroupStats );\n    }\n\n    virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->testRunEnded( testRunStats );\n    }\n\n    virtual void skipTest( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {\n        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();\n                it != itEnd;\n                ++it )\n            (*it)->skipTest( testInfo );\n    }\n\n    virtual MultipleReporters* tryAsMulti() CATCH_OVERRIDE {\n        return this;\n    }\n\n};\n\nPtr<IStreamingReporter> addReporter( Ptr<IStreamingReporter> const& existingReporter, Ptr<IStreamingReporter> const& additionalReporter ) {\n    Ptr<IStreamingReporter> resultingReporter;\n\n    if( existingReporter ) {\n        MultipleReporters* multi = existingReporter->tryAsMulti();\n        if( !multi ) {\n            multi = new MultipleReporters;\n            resultingReporter = Ptr<IStreamingReporter>( multi );\n            if( existingReporter )\n                multi->add( existingReporter );\n        }\n        else\n            resultingReporter = existingReporter;\n        multi->add( additionalReporter );\n    }\n    else\n        resultingReporter = additionalReporter;\n\n    return resultingReporter;\n}\n\n} // end namespace Catch\n\n// #included from: ../reporters/catch_reporter_xml.hpp\n#define TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED\n\n// #included from: catch_reporter_bases.hpp\n#define TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED\n\n#include <cstring>\n#include <cfloat>\n#include <cstdio>\n#include <assert.h>\n\nnamespace Catch {\n\n    namespace {\n        // Because formatting using c++ streams is stateful, drop down to C is required\n        // Alternatively we could use stringstream, but its performance is... not good.\n        std::string getFormattedDuration( double duration ) {\n            // Max exponent + 1 is required to represent the whole part\n            // + 1 for decimal point\n            // + 3 for the 3 decimal places\n            // + 1 for null terminator\n            const size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;\n            char buffer[maxDoubleSize];\n\n            // Save previous errno, to prevent sprintf from overwriting it\n            ErrnoGuard guard;\n#ifdef _MSC_VER\n            sprintf_s(buffer, \"%.3f\", duration);\n#else\n            sprintf(buffer, \"%.3f\", duration);\n#endif\n            return std::string(buffer);\n        }\n    }\n\n    struct StreamingReporterBase : SharedImpl<IStreamingReporter> {\n\n        StreamingReporterBase( ReporterConfig const& _config )\n        :   m_config( _config.fullConfig() ),\n            stream( _config.stream() )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = false;\n        }\n\n        virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {\n            return m_reporterPrefs;\n        }\n\n        virtual ~StreamingReporterBase() CATCH_OVERRIDE;\n\n        virtual void noMatchingTestCases( std::string const& ) CATCH_OVERRIDE {}\n\n        virtual void testRunStarting( TestRunInfo const& _testRunInfo ) CATCH_OVERRIDE {\n            currentTestRunInfo = _testRunInfo;\n        }\n        virtual void testGroupStarting( GroupInfo const& _groupInfo ) CATCH_OVERRIDE {\n            currentGroupInfo = _groupInfo;\n        }\n\n        virtual void testCaseStarting( TestCaseInfo const& _testInfo ) CATCH_OVERRIDE {\n            currentTestCaseInfo = _testInfo;\n        }\n        virtual void sectionStarting( SectionInfo const& _sectionInfo ) CATCH_OVERRIDE {\n            m_sectionStack.push_back( _sectionInfo );\n        }\n\n        virtual void sectionEnded( SectionStats const& /* _sectionStats */ ) CATCH_OVERRIDE {\n            m_sectionStack.pop_back();\n        }\n        virtual void testCaseEnded( TestCaseStats const& /* _testCaseStats */ ) CATCH_OVERRIDE {\n            currentTestCaseInfo.reset();\n        }\n        virtual void testGroupEnded( TestGroupStats const& /* _testGroupStats */ ) CATCH_OVERRIDE {\n            currentGroupInfo.reset();\n        }\n        virtual void testRunEnded( TestRunStats const& /* _testRunStats */ ) CATCH_OVERRIDE {\n            currentTestCaseInfo.reset();\n            currentGroupInfo.reset();\n            currentTestRunInfo.reset();\n        }\n\n        virtual void skipTest( TestCaseInfo const& ) CATCH_OVERRIDE {\n            // Don't do anything with this by default.\n            // It can optionally be overridden in the derived class.\n        }\n\n        Ptr<IConfig const> m_config;\n        std::ostream& stream;\n\n        LazyStat<TestRunInfo> currentTestRunInfo;\n        LazyStat<GroupInfo> currentGroupInfo;\n        LazyStat<TestCaseInfo> currentTestCaseInfo;\n\n        std::vector<SectionInfo> m_sectionStack;\n        ReporterPreferences m_reporterPrefs;\n    };\n\n    struct CumulativeReporterBase : SharedImpl<IStreamingReporter> {\n        template<typename T, typename ChildNodeT>\n        struct Node : SharedImpl<> {\n            explicit Node( T const& _value ) : value( _value ) {}\n            virtual ~Node() {}\n\n            typedef std::vector<Ptr<ChildNodeT> > ChildNodes;\n            T value;\n            ChildNodes children;\n        };\n        struct SectionNode : SharedImpl<> {\n            explicit SectionNode( SectionStats const& _stats ) : stats( _stats ) {}\n            virtual ~SectionNode();\n\n            bool operator == ( SectionNode const& other ) const {\n                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;\n            }\n            bool operator == ( Ptr<SectionNode> const& other ) const {\n                return operator==( *other );\n            }\n\n            SectionStats stats;\n            typedef std::vector<Ptr<SectionNode> > ChildSections;\n            typedef std::vector<AssertionStats> Assertions;\n            ChildSections childSections;\n            Assertions assertions;\n            std::string stdOut;\n            std::string stdErr;\n        };\n\n        struct BySectionInfo {\n            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}\n            BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}\n            bool operator() ( Ptr<SectionNode> const& node ) const {\n                return node->stats.sectionInfo.lineInfo == m_other.lineInfo;\n            }\n        private:\n            void operator=( BySectionInfo const& );\n            SectionInfo const& m_other;\n        };\n\n        typedef Node<TestCaseStats, SectionNode> TestCaseNode;\n        typedef Node<TestGroupStats, TestCaseNode> TestGroupNode;\n        typedef Node<TestRunStats, TestGroupNode> TestRunNode;\n\n        CumulativeReporterBase( ReporterConfig const& _config )\n        :   m_config( _config.fullConfig() ),\n            stream( _config.stream() )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = false;\n        }\n        ~CumulativeReporterBase();\n\n        virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {\n            return m_reporterPrefs;\n        }\n\n        virtual void testRunStarting( TestRunInfo const& ) CATCH_OVERRIDE {}\n        virtual void testGroupStarting( GroupInfo const& ) CATCH_OVERRIDE {}\n\n        virtual void testCaseStarting( TestCaseInfo const& ) CATCH_OVERRIDE {}\n\n        virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {\n            SectionStats incompleteStats( sectionInfo, Counts(), 0, false );\n            Ptr<SectionNode> node;\n            if( m_sectionStack.empty() ) {\n                if( !m_rootSection )\n                    m_rootSection = new SectionNode( incompleteStats );\n                node = m_rootSection;\n            }\n            else {\n                SectionNode& parentNode = *m_sectionStack.back();\n                SectionNode::ChildSections::const_iterator it =\n                    std::find_if(   parentNode.childSections.begin(),\n                                    parentNode.childSections.end(),\n                                    BySectionInfo( sectionInfo ) );\n                if( it == parentNode.childSections.end() ) {\n                    node = new SectionNode( incompleteStats );\n                    parentNode.childSections.push_back( node );\n                }\n                else\n                    node = *it;\n            }\n            m_sectionStack.push_back( node );\n            m_deepestSection = node;\n        }\n\n        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {}\n\n        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {\n            assert( !m_sectionStack.empty() );\n            SectionNode& sectionNode = *m_sectionStack.back();\n            sectionNode.assertions.push_back( assertionStats );\n            // AssertionResult holds a pointer to a temporary DecomposedExpression,\n            // which getExpandedExpression() calls to build the expression string.\n            // Our section stack copy of the assertionResult will likely outlive the\n            // temporary, so it must be expanded or discarded now to avoid calling\n            // a destroyed object later.\n            prepareExpandedExpression( sectionNode.assertions.back().assertionResult );\n            return true;\n        }\n        virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {\n            assert( !m_sectionStack.empty() );\n            SectionNode& node = *m_sectionStack.back();\n            node.stats = sectionStats;\n            m_sectionStack.pop_back();\n        }\n        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {\n            Ptr<TestCaseNode> node = new TestCaseNode( testCaseStats );\n            assert( m_sectionStack.size() == 0 );\n            node->children.push_back( m_rootSection );\n            m_testCases.push_back( node );\n            m_rootSection.reset();\n\n            assert( m_deepestSection );\n            m_deepestSection->stdOut = testCaseStats.stdOut;\n            m_deepestSection->stdErr = testCaseStats.stdErr;\n        }\n        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {\n            Ptr<TestGroupNode> node = new TestGroupNode( testGroupStats );\n            node->children.swap( m_testCases );\n            m_testGroups.push_back( node );\n        }\n        virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {\n            Ptr<TestRunNode> node = new TestRunNode( testRunStats );\n            node->children.swap( m_testGroups );\n            m_testRuns.push_back( node );\n            testRunEndedCumulative();\n        }\n        virtual void testRunEndedCumulative() = 0;\n\n        virtual void skipTest( TestCaseInfo const& ) CATCH_OVERRIDE {}\n\n        virtual void prepareExpandedExpression( AssertionResult& result ) const {\n            if( result.isOk() )\n                result.discardDecomposedExpression();\n            else\n                result.expandDecomposedExpression();\n        }\n\n        Ptr<IConfig const> m_config;\n        std::ostream& stream;\n        std::vector<AssertionStats> m_assertions;\n        std::vector<std::vector<Ptr<SectionNode> > > m_sections;\n        std::vector<Ptr<TestCaseNode> > m_testCases;\n        std::vector<Ptr<TestGroupNode> > m_testGroups;\n\n        std::vector<Ptr<TestRunNode> > m_testRuns;\n\n        Ptr<SectionNode> m_rootSection;\n        Ptr<SectionNode> m_deepestSection;\n        std::vector<Ptr<SectionNode> > m_sectionStack;\n        ReporterPreferences m_reporterPrefs;\n\n    };\n\n    template<char C>\n    char const* getLineOfChars() {\n        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};\n        if( !*line ) {\n            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );\n            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;\n        }\n        return line;\n    }\n\n    struct TestEventListenerBase : StreamingReporterBase {\n        TestEventListenerBase( ReporterConfig const& _config )\n        :   StreamingReporterBase( _config )\n        {}\n\n        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {}\n        virtual bool assertionEnded( AssertionStats const& ) CATCH_OVERRIDE {\n            return false;\n        }\n    };\n\n} // end namespace Catch\n\n// #included from: ../internal/catch_reporter_registrars.hpp\n#define TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED\n\nnamespace Catch {\n\n    template<typename T>\n    class LegacyReporterRegistrar {\n\n        class ReporterFactory : public IReporterFactory {\n            virtual IStreamingReporter* create( ReporterConfig const& config ) const {\n                return new LegacyReporterAdapter( new T( config ) );\n            }\n\n            virtual std::string getDescription() const {\n                return T::getDescription();\n            }\n        };\n\n    public:\n\n        LegacyReporterRegistrar( std::string const& name ) {\n            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );\n        }\n    };\n\n    template<typename T>\n    class ReporterRegistrar {\n\n        class ReporterFactory : public SharedImpl<IReporterFactory> {\n\n            // *** Please Note ***:\n            // - If you end up here looking at a compiler error because it's trying to register\n            // your custom reporter class be aware that the native reporter interface has changed\n            // to IStreamingReporter. The \"legacy\" interface, IReporter, is still supported via\n            // an adapter. Just use REGISTER_LEGACY_REPORTER to take advantage of the adapter.\n            // However please consider updating to the new interface as the old one is now\n            // deprecated and will probably be removed quite soon!\n            // Please contact me via github if you have any questions at all about this.\n            // In fact, ideally, please contact me anyway to let me know you've hit this - as I have\n            // no idea who is actually using custom reporters at all (possibly no-one!).\n            // The new interface is designed to minimise exposure to interface changes in the future.\n            virtual IStreamingReporter* create( ReporterConfig const& config ) const {\n                return new T( config );\n            }\n\n            virtual std::string getDescription() const {\n                return T::getDescription();\n            }\n        };\n\n    public:\n\n        ReporterRegistrar( std::string const& name ) {\n            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );\n        }\n    };\n\n    template<typename T>\n    class ListenerRegistrar {\n\n        class ListenerFactory : public SharedImpl<IReporterFactory> {\n\n            virtual IStreamingReporter* create( ReporterConfig const& config ) const {\n                return new T( config );\n            }\n            virtual std::string getDescription() const {\n                return std::string();\n            }\n        };\n\n    public:\n\n        ListenerRegistrar() {\n            getMutableRegistryHub().registerListener( new ListenerFactory() );\n        }\n    };\n}\n\n#define INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) \\\n    namespace{ Catch::LegacyReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }\n\n#define INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType ) \\\n    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }\n\n// Deprecated - use the form without INTERNAL_\n#define INTERNAL_CATCH_REGISTER_LISTENER( listenerType ) \\\n    namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; }\n\n#define CATCH_REGISTER_LISTENER( listenerType ) \\\n    namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; }\n\n// #included from: ../internal/catch_xmlwriter.hpp\n#define TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED\n\n#include <sstream>\n#include <string>\n#include <vector>\n#include <iomanip>\n\nnamespace Catch {\n\n    class XmlEncode {\n    public:\n        enum ForWhat { ForTextNodes, ForAttributes };\n\n        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes )\n        :   m_str( str ),\n            m_forWhat( forWhat )\n        {}\n\n        void encodeTo( std::ostream& os ) const {\n\n            // Apostrophe escaping not necessary if we always use \" to write attributes\n            // (see: http://www.w3.org/TR/xml/#syntax)\n\n            for( std::size_t i = 0; i < m_str.size(); ++ i ) {\n                char c = m_str[i];\n                switch( c ) {\n                    case '<':   os << \"&lt;\"; break;\n                    case '&':   os << \"&amp;\"; break;\n\n                    case '>':\n                        // See: http://www.w3.org/TR/xml/#syntax\n                        if( i > 2 && m_str[i-1] == ']' && m_str[i-2] == ']' )\n                            os << \"&gt;\";\n                        else\n                            os << c;\n                        break;\n\n                    case '\\\"':\n                        if( m_forWhat == ForAttributes )\n                            os << \"&quot;\";\n                        else\n                            os << c;\n                        break;\n\n                    default:\n                        // Escape control chars - based on contribution by @espenalb in PR #465 and\n                        // by @mrpi PR #588\n                        if ( ( c >= 0 && c < '\\x09' ) || ( c > '\\x0D' && c < '\\x20') || c=='\\x7F' ) {\n                            // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0\n                            os << \"\\\\x\" << std::uppercase << std::hex << std::setfill('0') << std::setw(2)\n                               << static_cast<int>( c );\n                        }\n                        else\n                            os << c;\n                }\n            }\n        }\n\n        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {\n            xmlEncode.encodeTo( os );\n            return os;\n        }\n\n    private:\n        std::string m_str;\n        ForWhat m_forWhat;\n    };\n\n    class XmlWriter {\n    public:\n\n        class ScopedElement {\n        public:\n            ScopedElement( XmlWriter* writer )\n            :   m_writer( writer )\n            {}\n\n            ScopedElement( ScopedElement const& other )\n            :   m_writer( other.m_writer ){\n                other.m_writer = CATCH_NULL;\n            }\n\n            ~ScopedElement() {\n                if( m_writer )\n                    m_writer->endElement();\n            }\n\n            ScopedElement& writeText( std::string const& text, bool indent = true ) {\n                m_writer->writeText( text, indent );\n                return *this;\n            }\n\n            template<typename T>\n            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {\n                m_writer->writeAttribute( name, attribute );\n                return *this;\n            }\n\n        private:\n            mutable XmlWriter* m_writer;\n        };\n\n        XmlWriter()\n        :   m_tagIsOpen( false ),\n            m_needsNewline( false ),\n            m_os( Catch::cout() )\n        {\n            writeDeclaration();\n        }\n\n        XmlWriter( std::ostream& os )\n        :   m_tagIsOpen( false ),\n            m_needsNewline( false ),\n            m_os( os )\n        {\n            writeDeclaration();\n        }\n\n        ~XmlWriter() {\n            while( !m_tags.empty() )\n                endElement();\n        }\n\n        XmlWriter& startElement( std::string const& name ) {\n            ensureTagClosed();\n            newlineIfNecessary();\n            m_os << m_indent << '<' << name;\n            m_tags.push_back( name );\n            m_indent += \"  \";\n            m_tagIsOpen = true;\n            return *this;\n        }\n\n        ScopedElement scopedElement( std::string const& name ) {\n            ScopedElement scoped( this );\n            startElement( name );\n            return scoped;\n        }\n\n        XmlWriter& endElement() {\n            newlineIfNecessary();\n            m_indent = m_indent.substr( 0, m_indent.size()-2 );\n            if( m_tagIsOpen ) {\n                m_os << \"/>\";\n                m_tagIsOpen = false;\n            }\n            else {\n                m_os << m_indent << \"</\" << m_tags.back() << \">\";\n            }\n            m_os << std::endl;\n            m_tags.pop_back();\n            return *this;\n        }\n\n        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute ) {\n            if( !name.empty() && !attribute.empty() )\n                m_os << ' ' << name << \"=\\\"\" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '\"';\n            return *this;\n        }\n\n        XmlWriter& writeAttribute( std::string const& name, bool attribute ) {\n            m_os << ' ' << name << \"=\\\"\" << ( attribute ? \"true\" : \"false\" ) << '\"';\n            return *this;\n        }\n\n        template<typename T>\n        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {\n            std::ostringstream oss;\n            oss << attribute;\n            return writeAttribute( name, oss.str() );\n        }\n\n        XmlWriter& writeText( std::string const& text, bool indent = true ) {\n            if( !text.empty() ){\n                bool tagWasOpen = m_tagIsOpen;\n                ensureTagClosed();\n                if( tagWasOpen && indent )\n                    m_os << m_indent;\n                m_os << XmlEncode( text );\n                m_needsNewline = true;\n            }\n            return *this;\n        }\n\n        XmlWriter& writeComment( std::string const& text ) {\n            ensureTagClosed();\n            m_os << m_indent << \"<!--\" << text << \"-->\";\n            m_needsNewline = true;\n            return *this;\n        }\n\n        void writeStylesheetRef( std::string const& url ) {\n            m_os << \"<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"\" << url << \"\\\"?>\\n\";\n        }\n\n        XmlWriter& writeBlankLine() {\n            ensureTagClosed();\n            m_os << '\\n';\n            return *this;\n        }\n\n        void ensureTagClosed() {\n            if( m_tagIsOpen ) {\n                m_os << \">\" << std::endl;\n                m_tagIsOpen = false;\n            }\n        }\n\n    private:\n        XmlWriter( XmlWriter const& );\n        void operator=( XmlWriter const& );\n\n        void writeDeclaration() {\n            m_os << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n        }\n\n        void newlineIfNecessary() {\n            if( m_needsNewline ) {\n                m_os << std::endl;\n                m_needsNewline = false;\n            }\n        }\n\n        bool m_tagIsOpen;\n        bool m_needsNewline;\n        std::vector<std::string> m_tags;\n        std::string m_indent;\n        std::ostream& m_os;\n    };\n\n}\n\nnamespace Catch {\n    class XmlReporter : public StreamingReporterBase {\n    public:\n        XmlReporter( ReporterConfig const& _config )\n        :   StreamingReporterBase( _config ),\n            m_xml(_config.stream()),\n            m_sectionDepth( 0 )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = true;\n        }\n\n        virtual ~XmlReporter() CATCH_OVERRIDE;\n\n        static std::string getDescription() {\n            return \"Reports test results as an XML document\";\n        }\n\n        virtual std::string getStylesheetRef() const {\n            return std::string();\n        }\n\n        void writeSourceInfo( SourceLineInfo const& sourceInfo ) {\n            m_xml\n                .writeAttribute( \"filename\", sourceInfo.file )\n                .writeAttribute( \"line\", sourceInfo.line );\n        }\n\n    public: // StreamingReporterBase\n\n        virtual void noMatchingTestCases( std::string const& s ) CATCH_OVERRIDE {\n            StreamingReporterBase::noMatchingTestCases( s );\n        }\n\n        virtual void testRunStarting( TestRunInfo const& testInfo ) CATCH_OVERRIDE {\n            StreamingReporterBase::testRunStarting( testInfo );\n            std::string stylesheetRef = getStylesheetRef();\n            if( !stylesheetRef.empty() )\n                m_xml.writeStylesheetRef( stylesheetRef );\n            m_xml.startElement( \"Catch\" );\n            if( !m_config->name().empty() )\n                m_xml.writeAttribute( \"name\", m_config->name() );\n        }\n\n        virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {\n            StreamingReporterBase::testGroupStarting( groupInfo );\n            m_xml.startElement( \"Group\" )\n                .writeAttribute( \"name\", groupInfo.name );\n        }\n\n        virtual void testCaseStarting( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {\n            StreamingReporterBase::testCaseStarting(testInfo);\n            m_xml.startElement( \"TestCase\" )\n                .writeAttribute( \"name\", trim( testInfo.name ) )\n                .writeAttribute( \"description\", testInfo.description )\n                .writeAttribute( \"tags\", testInfo.tagsAsString );\n\n            writeSourceInfo( testInfo.lineInfo );\n\n            if ( m_config->showDurations() == ShowDurations::Always )\n                m_testCaseTimer.start();\n            m_xml.ensureTagClosed();\n        }\n\n        virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {\n            StreamingReporterBase::sectionStarting( sectionInfo );\n            if( m_sectionDepth++ > 0 ) {\n                m_xml.startElement( \"Section\" )\n                    .writeAttribute( \"name\", trim( sectionInfo.name ) )\n                    .writeAttribute( \"description\", sectionInfo.description );\n                writeSourceInfo( sectionInfo.lineInfo );\n                m_xml.ensureTagClosed();\n            }\n        }\n\n        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE { }\n\n        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {\n\n            AssertionResult const& result = assertionStats.assertionResult;\n\n            bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();\n\n            if( includeResults ) {\n                // Print any info messages in <Info> tags.\n                for( std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();\n                     it != itEnd;\n                     ++it ) {\n                    if( it->type == ResultWas::Info ) {\n                        m_xml.scopedElement( \"Info\" )\n                                .writeText( it->message );\n                    } else if ( it->type == ResultWas::Warning ) {\n                        m_xml.scopedElement( \"Warning\" )\n                                .writeText( it->message );\n                    }\n                }\n            }\n\n            // Drop out if result was successful but we're not printing them.\n            if( !includeResults && result.getResultType() != ResultWas::Warning )\n                return true;\n\n            // Print the expression if there is one.\n            if( result.hasExpression() ) {\n                m_xml.startElement( \"Expression\" )\n                    .writeAttribute( \"success\", result.succeeded() )\n                    .writeAttribute( \"type\", result.getTestMacroName() );\n\n                writeSourceInfo( result.getSourceInfo() );\n\n                m_xml.scopedElement( \"Original\" )\n                    .writeText( result.getExpression() );\n                m_xml.scopedElement( \"Expanded\" )\n                    .writeText( result.getExpandedExpression() );\n            }\n\n            // And... Print a result applicable to each result type.\n            switch( result.getResultType() ) {\n                case ResultWas::ThrewException:\n                    m_xml.startElement( \"Exception\" );\n                    writeSourceInfo( result.getSourceInfo() );\n                    m_xml.writeText( result.getMessage() );\n                    m_xml.endElement();\n                    break;\n                case ResultWas::FatalErrorCondition:\n                    m_xml.startElement( \"FatalErrorCondition\" );\n                    writeSourceInfo( result.getSourceInfo() );\n                    m_xml.writeText( result.getMessage() );\n                    m_xml.endElement();\n                    break;\n                case ResultWas::Info:\n                    m_xml.scopedElement( \"Info\" )\n                        .writeText( result.getMessage() );\n                    break;\n                case ResultWas::Warning:\n                    // Warning will already have been written\n                    break;\n                case ResultWas::ExplicitFailure:\n                    m_xml.startElement( \"Failure\" );\n                    writeSourceInfo( result.getSourceInfo() );\n                    m_xml.writeText( result.getMessage() );\n                    m_xml.endElement();\n                    break;\n                default:\n                    break;\n            }\n\n            if( result.hasExpression() )\n                m_xml.endElement();\n\n            return true;\n        }\n\n        virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {\n            StreamingReporterBase::sectionEnded( sectionStats );\n            if( --m_sectionDepth > 0 ) {\n                XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResults\" );\n                e.writeAttribute( \"successes\", sectionStats.assertions.passed );\n                e.writeAttribute( \"failures\", sectionStats.assertions.failed );\n                e.writeAttribute( \"expectedFailures\", sectionStats.assertions.failedButOk );\n\n                if ( m_config->showDurations() == ShowDurations::Always )\n                    e.writeAttribute( \"durationInSeconds\", sectionStats.durationInSeconds );\n\n                m_xml.endElement();\n            }\n        }\n\n        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {\n            StreamingReporterBase::testCaseEnded( testCaseStats );\n            XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResult\" );\n            e.writeAttribute( \"success\", testCaseStats.totals.assertions.allOk() );\n\n            if ( m_config->showDurations() == ShowDurations::Always )\n                e.writeAttribute( \"durationInSeconds\", m_testCaseTimer.getElapsedSeconds() );\n\n            if( !testCaseStats.stdOut.empty() )\n                m_xml.scopedElement( \"StdOut\" ).writeText( trim( testCaseStats.stdOut ), false );\n            if( !testCaseStats.stdErr.empty() )\n                m_xml.scopedElement( \"StdErr\" ).writeText( trim( testCaseStats.stdErr ), false );\n\n            m_xml.endElement();\n        }\n\n        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {\n            StreamingReporterBase::testGroupEnded( testGroupStats );\n            // TODO: Check testGroupStats.aborting and act accordingly.\n            m_xml.scopedElement( \"OverallResults\" )\n                .writeAttribute( \"successes\", testGroupStats.totals.assertions.passed )\n                .writeAttribute( \"failures\", testGroupStats.totals.assertions.failed )\n                .writeAttribute( \"expectedFailures\", testGroupStats.totals.assertions.failedButOk );\n            m_xml.endElement();\n        }\n\n        virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {\n            StreamingReporterBase::testRunEnded( testRunStats );\n            m_xml.scopedElement( \"OverallResults\" )\n                .writeAttribute( \"successes\", testRunStats.totals.assertions.passed )\n                .writeAttribute( \"failures\", testRunStats.totals.assertions.failed )\n                .writeAttribute( \"expectedFailures\", testRunStats.totals.assertions.failedButOk );\n            m_xml.endElement();\n        }\n\n    private:\n        Timer m_testCaseTimer;\n        XmlWriter m_xml;\n        int m_sectionDepth;\n    };\n\n     INTERNAL_CATCH_REGISTER_REPORTER( \"xml\", XmlReporter )\n\n} // end namespace Catch\n\n// #included from: ../reporters/catch_reporter_junit.hpp\n#define TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED\n\n#include <assert.h>\n\nnamespace Catch {\n\n    namespace {\n        std::string getCurrentTimestamp() {\n            // Beware, this is not reentrant because of backward compatibility issues\n            // Also, UTC only, again because of backward compatibility (%z is C++11)\n            time_t rawtime;\n            std::time(&rawtime);\n            const size_t timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n\n#ifdef _MSC_VER\n            std::tm timeInfo = {};\n            gmtime_s(&timeInfo, &rawtime);\n#else\n            std::tm* timeInfo;\n            timeInfo = std::gmtime(&rawtime);\n#endif\n\n            char timeStamp[timeStampSize];\n            const char * const fmt = \"%Y-%m-%dT%H:%M:%SZ\";\n\n#ifdef _MSC_VER\n            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\n#else\n            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\n#endif\n            return std::string(timeStamp);\n        }\n\n    }\n\n    class JunitReporter : public CumulativeReporterBase {\n    public:\n        JunitReporter( ReporterConfig const& _config )\n        :   CumulativeReporterBase( _config ),\n            xml( _config.stream() ),\n            m_okToFail( false )\n        {\n            m_reporterPrefs.shouldRedirectStdOut = true;\n        }\n\n        virtual ~JunitReporter() CATCH_OVERRIDE;\n\n        static std::string getDescription() {\n            return \"Reports test results in an XML format that looks like Ant's junitreport target\";\n        }\n\n        virtual void noMatchingTestCases( std::string const& /*spec*/ ) CATCH_OVERRIDE {}\n\n        virtual void testRunStarting( TestRunInfo const& runInfo ) CATCH_OVERRIDE {\n            CumulativeReporterBase::testRunStarting( runInfo );\n            xml.startElement( \"testsuites\" );\n        }\n\n        virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {\n            suiteTimer.start();\n            stdOutForSuite.str(\"\");\n            stdErrForSuite.str(\"\");\n            unexpectedExceptions = 0;\n            CumulativeReporterBase::testGroupStarting( groupInfo );\n        }\n\n        virtual void testCaseStarting( TestCaseInfo const& testCaseInfo ) CATCH_OVERRIDE {\n            m_okToFail = testCaseInfo.okToFail();\n        }\n        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {\n            if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )\n                unexpectedExceptions++;\n            return CumulativeReporterBase::assertionEnded( assertionStats );\n        }\n\n        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {\n            stdOutForSuite << testCaseStats.stdOut;\n            stdErrForSuite << testCaseStats.stdErr;\n            CumulativeReporterBase::testCaseEnded( testCaseStats );\n        }\n\n        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {\n            double suiteTime = suiteTimer.getElapsedSeconds();\n            CumulativeReporterBase::testGroupEnded( testGroupStats );\n            writeGroup( *m_testGroups.back(), suiteTime );\n        }\n\n        virtual void testRunEndedCumulative() CATCH_OVERRIDE {\n            xml.endElement();\n        }\n\n        void writeGroup( TestGroupNode const& groupNode, double suiteTime ) {\n            XmlWriter::ScopedElement e = xml.scopedElement( \"testsuite\" );\n            TestGroupStats const& stats = groupNode.value;\n            xml.writeAttribute( \"name\", stats.groupInfo.name );\n            xml.writeAttribute( \"errors\", unexpectedExceptions );\n            xml.writeAttribute( \"failures\", stats.totals.assertions.failed-unexpectedExceptions );\n            xml.writeAttribute( \"tests\", stats.totals.assertions.total() );\n            xml.writeAttribute( \"hostname\", \"tbd\" ); // !TBD\n            if( m_config->showDurations() == ShowDurations::Never )\n                xml.writeAttribute( \"time\", \"\" );\n            else\n                xml.writeAttribute( \"time\", suiteTime );\n            xml.writeAttribute( \"timestamp\", getCurrentTimestamp() );\n\n            // Write test cases\n            for( TestGroupNode::ChildNodes::const_iterator\n                    it = groupNode.children.begin(), itEnd = groupNode.children.end();\n                    it != itEnd;\n                    ++it )\n                writeTestCase( **it );\n\n            xml.scopedElement( \"system-out\" ).writeText( trim( stdOutForSuite.str() ), false );\n            xml.scopedElement( \"system-err\" ).writeText( trim( stdErrForSuite.str() ), false );\n        }\n\n        void writeTestCase( TestCaseNode const& testCaseNode ) {\n            TestCaseStats const& stats = testCaseNode.value;\n\n            // All test cases have exactly one section - which represents the\n            // test case itself. That section may have 0-n nested sections\n            assert( testCaseNode.children.size() == 1 );\n            SectionNode const& rootSection = *testCaseNode.children.front();\n\n            std::string className = stats.testInfo.className;\n\n            if( className.empty() ) {\n                if( rootSection.childSections.empty() )\n                    className = \"global\";\n            }\n            writeSection( className, \"\", rootSection );\n        }\n\n        void writeSection(  std::string const& className,\n                            std::string const& rootName,\n                            SectionNode const& sectionNode ) {\n            std::string name = trim( sectionNode.stats.sectionInfo.name );\n            if( !rootName.empty() )\n                name = rootName + '/' + name;\n\n            if( !sectionNode.assertions.empty() ||\n                !sectionNode.stdOut.empty() ||\n                !sectionNode.stdErr.empty() ) {\n                XmlWriter::ScopedElement e = xml.scopedElement( \"testcase\" );\n                if( className.empty() ) {\n                    xml.writeAttribute( \"classname\", name );\n                    xml.writeAttribute( \"name\", \"root\" );\n                }\n                else {\n                    xml.writeAttribute( \"classname\", className );\n                    xml.writeAttribute( \"name\", name );\n                }\n                xml.writeAttribute( \"time\", Catch::toString( sectionNode.stats.durationInSeconds ) );\n\n                writeAssertions( sectionNode );\n\n                if( !sectionNode.stdOut.empty() )\n                    xml.scopedElement( \"system-out\" ).writeText( trim( sectionNode.stdOut ), false );\n                if( !sectionNode.stdErr.empty() )\n                    xml.scopedElement( \"system-err\" ).writeText( trim( sectionNode.stdErr ), false );\n            }\n            for( SectionNode::ChildSections::const_iterator\n                    it = sectionNode.childSections.begin(),\n                    itEnd = sectionNode.childSections.end();\n                    it != itEnd;\n                    ++it )\n                if( className.empty() )\n                    writeSection( name, \"\", **it );\n                else\n                    writeSection( className, name, **it );\n        }\n\n        void writeAssertions( SectionNode const& sectionNode ) {\n            for( SectionNode::Assertions::const_iterator\n                    it = sectionNode.assertions.begin(), itEnd = sectionNode.assertions.end();\n                    it != itEnd;\n                    ++it )\n                writeAssertion( *it );\n        }\n        void writeAssertion( AssertionStats const& stats ) {\n            AssertionResult const& result = stats.assertionResult;\n            if( !result.isOk() ) {\n                std::string elementName;\n                switch( result.getResultType() ) {\n                    case ResultWas::ThrewException:\n                    case ResultWas::FatalErrorCondition:\n                        elementName = \"error\";\n                        break;\n                    case ResultWas::ExplicitFailure:\n                        elementName = \"failure\";\n                        break;\n                    case ResultWas::ExpressionFailed:\n                        elementName = \"failure\";\n                        break;\n                    case ResultWas::DidntThrowException:\n                        elementName = \"failure\";\n                        break;\n\n                    // We should never see these here:\n                    case ResultWas::Info:\n                    case ResultWas::Warning:\n                    case ResultWas::Ok:\n                    case ResultWas::Unknown:\n                    case ResultWas::FailureBit:\n                    case ResultWas::Exception:\n                        elementName = \"internalError\";\n                        break;\n                }\n\n                XmlWriter::ScopedElement e = xml.scopedElement( elementName );\n\n                xml.writeAttribute( \"message\", result.getExpandedExpression() );\n                xml.writeAttribute( \"type\", result.getTestMacroName() );\n\n                std::ostringstream oss;\n                if( !result.getMessage().empty() )\n                    oss << result.getMessage() << '\\n';\n                for( std::vector<MessageInfo>::const_iterator\n                        it = stats.infoMessages.begin(),\n                        itEnd = stats.infoMessages.end();\n                            it != itEnd;\n                            ++it )\n                    if( it->type == ResultWas::Info )\n                        oss << it->message << '\\n';\n\n                oss << \"at \" << result.getSourceInfo();\n                xml.writeText( oss.str(), false );\n            }\n        }\n\n        XmlWriter xml;\n        Timer suiteTimer;\n        std::ostringstream stdOutForSuite;\n        std::ostringstream stdErrForSuite;\n        unsigned int unexpectedExceptions;\n        bool m_okToFail;\n    };\n\n    INTERNAL_CATCH_REGISTER_REPORTER( \"junit\", JunitReporter )\n\n} // end namespace Catch\n\n// #included from: ../reporters/catch_reporter_console.hpp\n#define TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED\n\n#include <cfloat>\n#include <cstdio>\n\nnamespace Catch {\n\n    struct ConsoleReporter : StreamingReporterBase {\n        ConsoleReporter( ReporterConfig const& _config )\n        :   StreamingReporterBase( _config ),\n            m_headerPrinted( false )\n        {}\n\n        virtual ~ConsoleReporter() CATCH_OVERRIDE;\n        static std::string getDescription() {\n            return \"Reports test results as plain lines of text\";\n        }\n\n        virtual void noMatchingTestCases( std::string const& spec ) CATCH_OVERRIDE {\n            stream << \"No test cases matched '\" << spec << '\\'' << std::endl;\n        }\n\n        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {\n        }\n\n        virtual bool assertionEnded( AssertionStats const& _assertionStats ) CATCH_OVERRIDE {\n            AssertionResult const& result = _assertionStats.assertionResult;\n\n            bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();\n\n            // Drop out if result was successful but we're not printing them.\n            if( !includeResults && result.getResultType() != ResultWas::Warning )\n                return false;\n\n            lazyPrint();\n\n            AssertionPrinter printer( stream, _assertionStats, includeResults );\n            printer.print();\n            stream << std::endl;\n            return true;\n        }\n\n        virtual void sectionStarting( SectionInfo const& _sectionInfo ) CATCH_OVERRIDE {\n            m_headerPrinted = false;\n            StreamingReporterBase::sectionStarting( _sectionInfo );\n        }\n        virtual void sectionEnded( SectionStats const& _sectionStats ) CATCH_OVERRIDE {\n            if( _sectionStats.missingAssertions ) {\n                lazyPrint();\n                Colour colour( Colour::ResultError );\n                if( m_sectionStack.size() > 1 )\n                    stream << \"\\nNo assertions in section\";\n                else\n                    stream << \"\\nNo assertions in test case\";\n                stream << \" '\" << _sectionStats.sectionInfo.name << \"'\\n\" << std::endl;\n            }\n            if( m_config->showDurations() == ShowDurations::Always ) {\n                stream << getFormattedDuration(_sectionStats.durationInSeconds) << \" s: \" << _sectionStats.sectionInfo.name << std::endl;\n            }\n            if( m_headerPrinted ) {\n                m_headerPrinted = false;\n            }\n            StreamingReporterBase::sectionEnded( _sectionStats );\n        }\n\n        virtual void testCaseEnded( TestCaseStats const& _testCaseStats ) CATCH_OVERRIDE {\n            StreamingReporterBase::testCaseEnded( _testCaseStats );\n            m_headerPrinted = false;\n        }\n        virtual void testGroupEnded( TestGroupStats const& _testGroupStats ) CATCH_OVERRIDE {\n            if( currentGroupInfo.used ) {\n                printSummaryDivider();\n                stream << \"Summary for group '\" << _testGroupStats.groupInfo.name << \"':\\n\";\n                printTotals( _testGroupStats.totals );\n                stream << '\\n' << std::endl;\n            }\n            StreamingReporterBase::testGroupEnded( _testGroupStats );\n        }\n        virtual void testRunEnded( TestRunStats const& _testRunStats ) CATCH_OVERRIDE {\n            printTotalsDivider( _testRunStats.totals );\n            printTotals( _testRunStats.totals );\n            stream << std::endl;\n            StreamingReporterBase::testRunEnded( _testRunStats );\n        }\n\n    private:\n\n        class AssertionPrinter {\n            void operator= ( AssertionPrinter const& );\n        public:\n            AssertionPrinter( std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages )\n            :   stream( _stream ),\n                stats( _stats ),\n                result( _stats.assertionResult ),\n                colour( Colour::None ),\n                message( result.getMessage() ),\n                messages( _stats.infoMessages ),\n                printInfoMessages( _printInfoMessages )\n            {\n                switch( result.getResultType() ) {\n                    case ResultWas::Ok:\n                        colour = Colour::Success;\n                        passOrFail = \"PASSED\";\n                        //if( result.hasMessage() )\n                        if( _stats.infoMessages.size() == 1 )\n                            messageLabel = \"with message\";\n                        if( _stats.infoMessages.size() > 1 )\n                            messageLabel = \"with messages\";\n                        break;\n                    case ResultWas::ExpressionFailed:\n                        if( result.isOk() ) {\n                            colour = Colour::Success;\n                            passOrFail = \"FAILED - but was ok\";\n                        }\n                        else {\n                            colour = Colour::Error;\n                            passOrFail = \"FAILED\";\n                        }\n                        if( _stats.infoMessages.size() == 1 )\n                            messageLabel = \"with message\";\n                        if( _stats.infoMessages.size() > 1 )\n                            messageLabel = \"with messages\";\n                        break;\n                    case ResultWas::ThrewException:\n                        colour = Colour::Error;\n                        passOrFail = \"FAILED\";\n                        messageLabel = \"due to unexpected exception with \";\n                        if (_stats.infoMessages.size() == 1)\n                            messageLabel += \"message\";\n                        if (_stats.infoMessages.size() > 1)\n                            messageLabel += \"messages\";\n                        break;\n                    case ResultWas::FatalErrorCondition:\n                        colour = Colour::Error;\n                        passOrFail = \"FAILED\";\n                        messageLabel = \"due to a fatal error condition\";\n                        break;\n                    case ResultWas::DidntThrowException:\n                        colour = Colour::Error;\n                        passOrFail = \"FAILED\";\n                        messageLabel = \"because no exception was thrown where one was expected\";\n                        break;\n                    case ResultWas::Info:\n                        messageLabel = \"info\";\n                        break;\n                    case ResultWas::Warning:\n                        messageLabel = \"warning\";\n                        break;\n                    case ResultWas::ExplicitFailure:\n                        passOrFail = \"FAILED\";\n                        colour = Colour::Error;\n                        if( _stats.infoMessages.size() == 1 )\n                            messageLabel = \"explicitly with message\";\n                        if( _stats.infoMessages.size() > 1 )\n                            messageLabel = \"explicitly with messages\";\n                        break;\n                    // These cases are here to prevent compiler warnings\n                    case ResultWas::Unknown:\n                    case ResultWas::FailureBit:\n                    case ResultWas::Exception:\n                        passOrFail = \"** internal error **\";\n                        colour = Colour::Error;\n                        break;\n                }\n            }\n\n            void print() const {\n                printSourceInfo();\n                if( stats.totals.assertions.total() > 0 ) {\n                    if( result.isOk() )\n                        stream << '\\n';\n                    printResultType();\n                    printOriginalExpression();\n                    printReconstructedExpression();\n                }\n                else {\n                    stream << '\\n';\n                }\n                printMessage();\n            }\n\n        private:\n            void printResultType() const {\n                if( !passOrFail.empty() ) {\n                    Colour colourGuard( colour );\n                    stream << passOrFail << \":\\n\";\n                }\n            }\n            void printOriginalExpression() const {\n                if( result.hasExpression() ) {\n                    Colour colourGuard( Colour::OriginalExpression );\n                    stream  << \"  \";\n                    stream << result.getExpressionInMacro();\n                    stream << '\\n';\n                }\n            }\n            void printReconstructedExpression() const {\n                if( result.hasExpandedExpression() ) {\n                    stream << \"with expansion:\\n\";\n                    Colour colourGuard( Colour::ReconstructedExpression );\n                    stream << Text( result.getExpandedExpression(), TextAttributes().setIndent(2) ) << '\\n';\n                }\n            }\n            void printMessage() const {\n                if( !messageLabel.empty() )\n                    stream << messageLabel << ':' << '\\n';\n                for( std::vector<MessageInfo>::const_iterator it = messages.begin(), itEnd = messages.end();\n                        it != itEnd;\n                        ++it ) {\n                    // If this assertion is a warning ignore any INFO messages\n                    if( printInfoMessages || it->type != ResultWas::Info )\n                        stream << Text( it->message, TextAttributes().setIndent(2) ) << '\\n';\n                }\n            }\n            void printSourceInfo() const {\n                Colour colourGuard( Colour::FileName );\n                stream << result.getSourceInfo() << \": \";\n            }\n\n            std::ostream& stream;\n            AssertionStats const& stats;\n            AssertionResult const& result;\n            Colour::Code colour;\n            std::string passOrFail;\n            std::string messageLabel;\n            std::string message;\n            std::vector<MessageInfo> messages;\n            bool printInfoMessages;\n        };\n\n        void lazyPrint() {\n\n            if( !currentTestRunInfo.used )\n                lazyPrintRunInfo();\n            if( !currentGroupInfo.used )\n                lazyPrintGroupInfo();\n\n            if( !m_headerPrinted ) {\n                printTestCaseAndSectionHeader();\n                m_headerPrinted = true;\n            }\n        }\n        void lazyPrintRunInfo() {\n            stream  << '\\n' << getLineOfChars<'~'>() << '\\n';\n            Colour colour( Colour::SecondaryText );\n            stream  << currentTestRunInfo->name\n                    << \" is a Catch v\"  << libraryVersion() << \" host application.\\n\"\n                    << \"Run with -? for options\\n\\n\";\n\n            if( m_config->rngSeed() != 0 )\n                stream << \"Randomness seeded to: \" << m_config->rngSeed() << \"\\n\\n\";\n\n            currentTestRunInfo.used = true;\n        }\n        void lazyPrintGroupInfo() {\n            if( !currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1 ) {\n                printClosedHeader( \"Group: \" + currentGroupInfo->name );\n                currentGroupInfo.used = true;\n            }\n        }\n        void printTestCaseAndSectionHeader() {\n            assert( !m_sectionStack.empty() );\n            printOpenHeader( currentTestCaseInfo->name );\n\n            if( m_sectionStack.size() > 1 ) {\n                Colour colourGuard( Colour::Headers );\n\n                std::vector<SectionInfo>::const_iterator\n                    it = m_sectionStack.begin()+1, // Skip first section (test case)\n                    itEnd = m_sectionStack.end();\n                for( ; it != itEnd; ++it )\n                    printHeaderString( it->name, 2 );\n            }\n\n            SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;\n\n            if( !lineInfo.empty() ){\n                stream << getLineOfChars<'-'>() << '\\n';\n                Colour colourGuard( Colour::FileName );\n                stream << lineInfo << '\\n';\n            }\n            stream << getLineOfChars<'.'>() << '\\n' << std::endl;\n        }\n\n        void printClosedHeader( std::string const& _name ) {\n            printOpenHeader( _name );\n            stream << getLineOfChars<'.'>() << '\\n';\n        }\n        void printOpenHeader( std::string const& _name ) {\n            stream  << getLineOfChars<'-'>() << '\\n';\n            {\n                Colour colourGuard( Colour::Headers );\n                printHeaderString( _name );\n            }\n        }\n\n        // if string has a : in first line will set indent to follow it on\n        // subsequent lines\n        void printHeaderString( std::string const& _string, std::size_t indent = 0 ) {\n            std::size_t i = _string.find( \": \" );\n            if( i != std::string::npos )\n                i+=2;\n            else\n                i = 0;\n            stream << Text( _string, TextAttributes()\n                                        .setIndent( indent+i)\n                                        .setInitialIndent( indent ) ) << '\\n';\n        }\n\n        struct SummaryColumn {\n\n            SummaryColumn( std::string const& _label, Colour::Code _colour )\n            :   label( _label ),\n                colour( _colour )\n            {}\n            SummaryColumn addRow( std::size_t count ) {\n                std::ostringstream oss;\n                oss << count;\n                std::string row = oss.str();\n                for( std::vector<std::string>::iterator it = rows.begin(); it != rows.end(); ++it ) {\n                    while( it->size() < row.size() )\n                        *it = ' ' + *it;\n                    while( it->size() > row.size() )\n                        row = ' ' + row;\n                }\n                rows.push_back( row );\n                return *this;\n            }\n\n            std::string label;\n            Colour::Code colour;\n            std::vector<std::string> rows;\n\n        };\n\n        void printTotals( Totals const& totals ) {\n            if( totals.testCases.total() == 0 ) {\n                stream << Colour( Colour::Warning ) << \"No tests ran\\n\";\n            }\n            else if( totals.assertions.total() > 0 && totals.testCases.allPassed() ) {\n                stream << Colour( Colour::ResultSuccess ) << \"All tests passed\";\n                stream << \" (\"\n                        << pluralise( totals.assertions.passed, \"assertion\" ) << \" in \"\n                        << pluralise( totals.testCases.passed, \"test case\" ) << ')'\n                        << '\\n';\n            }\n            else {\n\n                std::vector<SummaryColumn> columns;\n                columns.push_back( SummaryColumn( \"\", Colour::None )\n                                        .addRow( totals.testCases.total() )\n                                        .addRow( totals.assertions.total() ) );\n                columns.push_back( SummaryColumn( \"passed\", Colour::Success )\n                                        .addRow( totals.testCases.passed )\n                                        .addRow( totals.assertions.passed ) );\n                columns.push_back( SummaryColumn( \"failed\", Colour::ResultError )\n                                        .addRow( totals.testCases.failed )\n                                        .addRow( totals.assertions.failed ) );\n                columns.push_back( SummaryColumn( \"failed as expected\", Colour::ResultExpectedFailure )\n                                        .addRow( totals.testCases.failedButOk )\n                                        .addRow( totals.assertions.failedButOk ) );\n\n                printSummaryRow( \"test cases\", columns, 0 );\n                printSummaryRow( \"assertions\", columns, 1 );\n            }\n        }\n        void printSummaryRow( std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row ) {\n            for( std::vector<SummaryColumn>::const_iterator it = cols.begin(); it != cols.end(); ++it ) {\n                std::string value = it->rows[row];\n                if( it->label.empty() ) {\n                    stream << label << \": \";\n                    if( value != \"0\" )\n                        stream << value;\n                    else\n                        stream << Colour( Colour::Warning ) << \"- none -\";\n                }\n                else if( value != \"0\" ) {\n                    stream  << Colour( Colour::LightGrey ) << \" | \";\n                    stream  << Colour( it->colour )\n                            << value << ' ' << it->label;\n                }\n            }\n            stream << '\\n';\n        }\n\n        static std::size_t makeRatio( std::size_t number, std::size_t total ) {\n            std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number/ total : 0;\n            return ( ratio == 0 && number > 0 ) ? 1 : ratio;\n        }\n        static std::size_t& findMax( std::size_t& i, std::size_t& j, std::size_t& k ) {\n            if( i > j && i > k )\n                return i;\n            else if( j > k )\n                return j;\n            else\n                return k;\n        }\n\n        void printTotalsDivider( Totals const& totals ) {\n            if( totals.testCases.total() > 0 ) {\n                std::size_t failedRatio = makeRatio( totals.testCases.failed, totals.testCases.total() );\n                std::size_t failedButOkRatio = makeRatio( totals.testCases.failedButOk, totals.testCases.total() );\n                std::size_t passedRatio = makeRatio( totals.testCases.passed, totals.testCases.total() );\n                while( failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH-1 )\n                    findMax( failedRatio, failedButOkRatio, passedRatio )++;\n                while( failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH-1 )\n                    findMax( failedRatio, failedButOkRatio, passedRatio )--;\n\n                stream << Colour( Colour::Error ) << std::string( failedRatio, '=' );\n                stream << Colour( Colour::ResultExpectedFailure ) << std::string( failedButOkRatio, '=' );\n                if( totals.testCases.allPassed() )\n                    stream << Colour( Colour::ResultSuccess ) << std::string( passedRatio, '=' );\n                else\n                    stream << Colour( Colour::Success ) << std::string( passedRatio, '=' );\n            }\n            else {\n                stream << Colour( Colour::Warning ) << std::string( CATCH_CONFIG_CONSOLE_WIDTH-1, '=' );\n            }\n            stream << '\\n';\n        }\n        void printSummaryDivider() {\n            stream << getLineOfChars<'-'>() << '\\n';\n        }\n\n    private:\n        bool m_headerPrinted;\n    };\n\n    INTERNAL_CATCH_REGISTER_REPORTER( \"console\", ConsoleReporter )\n\n} // end namespace Catch\n\n// #included from: ../reporters/catch_reporter_compact.hpp\n#define TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED\n\nnamespace Catch {\n\n    struct CompactReporter : StreamingReporterBase {\n\n        CompactReporter( ReporterConfig const& _config )\n        : StreamingReporterBase( _config )\n        {}\n\n        virtual ~CompactReporter();\n\n        static std::string getDescription() {\n            return \"Reports test results on a single line, suitable for IDEs\";\n        }\n\n        virtual ReporterPreferences getPreferences() const {\n            ReporterPreferences prefs;\n            prefs.shouldRedirectStdOut = false;\n            return prefs;\n        }\n\n        virtual void noMatchingTestCases( std::string const& spec ) {\n            stream << \"No test cases matched '\" << spec << '\\'' << std::endl;\n        }\n\n        virtual void assertionStarting( AssertionInfo const& ) {}\n\n        virtual bool assertionEnded( AssertionStats const& _assertionStats ) {\n            AssertionResult const& result = _assertionStats.assertionResult;\n\n            bool printInfoMessages = true;\n\n            // Drop out if result was successful and we're not printing those\n            if( !m_config->includeSuccessfulResults() && result.isOk() ) {\n                if( result.getResultType() != ResultWas::Warning )\n                    return false;\n                printInfoMessages = false;\n            }\n\n            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );\n            printer.print();\n\n            stream << std::endl;\n            return true;\n        }\n\n        virtual void sectionEnded(SectionStats const& _sectionStats) CATCH_OVERRIDE {\n            if (m_config->showDurations() == ShowDurations::Always) {\n                stream << getFormattedDuration(_sectionStats.durationInSeconds) << \" s: \" << _sectionStats.sectionInfo.name << std::endl;\n            }\n        }\n\n        virtual void testRunEnded( TestRunStats const& _testRunStats ) {\n            printTotals( _testRunStats.totals );\n            stream << '\\n' << std::endl;\n            StreamingReporterBase::testRunEnded( _testRunStats );\n        }\n\n    private:\n        class AssertionPrinter {\n            void operator= ( AssertionPrinter const& );\n        public:\n            AssertionPrinter( std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages )\n            : stream( _stream )\n            , stats( _stats )\n            , result( _stats.assertionResult )\n            , messages( _stats.infoMessages )\n            , itMessage( _stats.infoMessages.begin() )\n            , printInfoMessages( _printInfoMessages )\n            {}\n\n            void print() {\n                printSourceInfo();\n\n                itMessage = messages.begin();\n\n                switch( result.getResultType() ) {\n                    case ResultWas::Ok:\n                        printResultType( Colour::ResultSuccess, passedString() );\n                        printOriginalExpression();\n                        printReconstructedExpression();\n                        if ( ! result.hasExpression() )\n                            printRemainingMessages( Colour::None );\n                        else\n                            printRemainingMessages();\n                        break;\n                    case ResultWas::ExpressionFailed:\n                        if( result.isOk() )\n                            printResultType( Colour::ResultSuccess, failedString() + std::string( \" - but was ok\" ) );\n                        else\n                            printResultType( Colour::Error, failedString() );\n                        printOriginalExpression();\n                        printReconstructedExpression();\n                        printRemainingMessages();\n                        break;\n                    case ResultWas::ThrewException:\n                        printResultType( Colour::Error, failedString() );\n                        printIssue( \"unexpected exception with message:\" );\n                        printMessage();\n                        printExpressionWas();\n                        printRemainingMessages();\n                        break;\n                    case ResultWas::FatalErrorCondition:\n                        printResultType( Colour::Error, failedString() );\n                        printIssue( \"fatal error condition with message:\" );\n                        printMessage();\n                        printExpressionWas();\n                        printRemainingMessages();\n                        break;\n                    case ResultWas::DidntThrowException:\n                        printResultType( Colour::Error, failedString() );\n                        printIssue( \"expected exception, got none\" );\n                        printExpressionWas();\n                        printRemainingMessages();\n                        break;\n                    case ResultWas::Info:\n                        printResultType( Colour::None, \"info\" );\n                        printMessage();\n                        printRemainingMessages();\n                        break;\n                    case ResultWas::Warning:\n                        printResultType( Colour::None, \"warning\" );\n                        printMessage();\n                        printRemainingMessages();\n                        break;\n                    case ResultWas::ExplicitFailure:\n                        printResultType( Colour::Error, failedString() );\n                        printIssue( \"explicitly\" );\n                        printRemainingMessages( Colour::None );\n                        break;\n                    // These cases are here to prevent compiler warnings\n                    case ResultWas::Unknown:\n                    case ResultWas::FailureBit:\n                    case ResultWas::Exception:\n                        printResultType( Colour::Error, \"** internal error **\" );\n                        break;\n                }\n            }\n\n        private:\n            // Colour::LightGrey\n\n            static Colour::Code dimColour() { return Colour::FileName; }\n\n#ifdef CATCH_PLATFORM_MAC\n            static const char* failedString() { return \"FAILED\"; }\n            static const char* passedString() { return \"PASSED\"; }\n#else\n            static const char* failedString() { return \"failed\"; }\n            static const char* passedString() { return \"passed\"; }\n#endif\n\n            void printSourceInfo() const {\n                Colour colourGuard( Colour::FileName );\n                stream << result.getSourceInfo() << ':';\n            }\n\n            void printResultType( Colour::Code colour, std::string const& passOrFail ) const {\n                if( !passOrFail.empty() ) {\n                    {\n                        Colour colourGuard( colour );\n                        stream << ' ' << passOrFail;\n                    }\n                    stream << ':';\n                }\n            }\n\n            void printIssue( std::string const& issue ) const {\n                stream << ' ' << issue;\n            }\n\n            void printExpressionWas() {\n                if( result.hasExpression() ) {\n                    stream << ';';\n                    {\n                        Colour colour( dimColour() );\n                        stream << \" expression was:\";\n                    }\n                    printOriginalExpression();\n                }\n            }\n\n            void printOriginalExpression() const {\n                if( result.hasExpression() ) {\n                    stream << ' ' << result.getExpression();\n                }\n            }\n\n            void printReconstructedExpression() const {\n                if( result.hasExpandedExpression() ) {\n                    {\n                        Colour colour( dimColour() );\n                        stream << \" for: \";\n                    }\n                    stream << result.getExpandedExpression();\n                }\n            }\n\n            void printMessage() {\n                if ( itMessage != messages.end() ) {\n                    stream << \" '\" << itMessage->message << '\\'';\n                    ++itMessage;\n                }\n            }\n\n            void printRemainingMessages( Colour::Code colour = dimColour() ) {\n                if ( itMessage == messages.end() )\n                    return;\n\n                // using messages.end() directly yields compilation error:\n                std::vector<MessageInfo>::const_iterator itEnd = messages.end();\n                const std::size_t N = static_cast<std::size_t>( std::distance( itMessage, itEnd ) );\n\n                {\n                    Colour colourGuard( colour );\n                    stream << \" with \" << pluralise( N, \"message\" ) << ':';\n                }\n\n                for(; itMessage != itEnd; ) {\n                    // If this assertion is a warning ignore any INFO messages\n                    if( printInfoMessages || itMessage->type != ResultWas::Info ) {\n                        stream << \" '\" << itMessage->message << '\\'';\n                        if ( ++itMessage != itEnd ) {\n                            Colour colourGuard( dimColour() );\n                            stream << \" and\";\n                        }\n                    }\n                }\n            }\n\n        private:\n            std::ostream& stream;\n            AssertionStats const& stats;\n            AssertionResult const& result;\n            std::vector<MessageInfo> messages;\n            std::vector<MessageInfo>::const_iterator itMessage;\n            bool printInfoMessages;\n        };\n\n        // Colour, message variants:\n        // - white: No tests ran.\n        // -   red: Failed [both/all] N test cases, failed [both/all] M assertions.\n        // - white: Passed [both/all] N test cases (no assertions).\n        // -   red: Failed N tests cases, failed M assertions.\n        // - green: Passed [both/all] N tests cases with M assertions.\n\n        std::string bothOrAll( std::size_t count ) const {\n            return count == 1 ? std::string() : count == 2 ? \"both \" : \"all \" ;\n        }\n\n        void printTotals( const Totals& totals ) const {\n            if( totals.testCases.total() == 0 ) {\n                stream << \"No tests ran.\";\n            }\n            else if( totals.testCases.failed == totals.testCases.total() ) {\n                Colour colour( Colour::ResultError );\n                const std::string qualify_assertions_failed =\n                    totals.assertions.failed == totals.assertions.total() ?\n                        bothOrAll( totals.assertions.failed ) : std::string();\n                stream <<\n                    \"Failed \" << bothOrAll( totals.testCases.failed )\n                              << pluralise( totals.testCases.failed, \"test case\"  ) << \", \"\n                    \"failed \" << qualify_assertions_failed <<\n                                 pluralise( totals.assertions.failed, \"assertion\" ) << '.';\n            }\n            else if( totals.assertions.total() == 0 ) {\n                stream <<\n                    \"Passed \" << bothOrAll( totals.testCases.total() )\n                              << pluralise( totals.testCases.total(), \"test case\" )\n                              << \" (no assertions).\";\n            }\n            else if( totals.assertions.failed ) {\n                Colour colour( Colour::ResultError );\n                stream <<\n                    \"Failed \" << pluralise( totals.testCases.failed, \"test case\"  ) << \", \"\n                    \"failed \" << pluralise( totals.assertions.failed, \"assertion\" ) << '.';\n            }\n            else {\n                Colour colour( Colour::ResultSuccess );\n                stream <<\n                    \"Passed \" << bothOrAll( totals.testCases.passed )\n                              << pluralise( totals.testCases.passed, \"test case\"  ) <<\n                    \" with \"  << pluralise( totals.assertions.passed, \"assertion\" ) << '.';\n            }\n        }\n    };\n\n    INTERNAL_CATCH_REGISTER_REPORTER( \"compact\", CompactReporter )\n\n} // end namespace Catch\n\nnamespace Catch {\n    // These are all here to avoid warnings about not having any out of line\n    // virtual methods\n    NonCopyable::~NonCopyable() {}\n    IShared::~IShared() {}\n    IStream::~IStream() CATCH_NOEXCEPT {}\n    FileStream::~FileStream() CATCH_NOEXCEPT {}\n    CoutStream::~CoutStream() CATCH_NOEXCEPT {}\n    DebugOutStream::~DebugOutStream() CATCH_NOEXCEPT {}\n    StreamBufBase::~StreamBufBase() CATCH_NOEXCEPT {}\n    IContext::~IContext() {}\n    IResultCapture::~IResultCapture() {}\n    ITestCase::~ITestCase() {}\n    ITestCaseRegistry::~ITestCaseRegistry() {}\n    IRegistryHub::~IRegistryHub() {}\n    IMutableRegistryHub::~IMutableRegistryHub() {}\n    IExceptionTranslator::~IExceptionTranslator() {}\n    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() {}\n    IReporter::~IReporter() {}\n    IReporterFactory::~IReporterFactory() {}\n    IReporterRegistry::~IReporterRegistry() {}\n    IStreamingReporter::~IStreamingReporter() {}\n    AssertionStats::~AssertionStats() {}\n    SectionStats::~SectionStats() {}\n    TestCaseStats::~TestCaseStats() {}\n    TestGroupStats::~TestGroupStats() {}\n    TestRunStats::~TestRunStats() {}\n    CumulativeReporterBase::SectionNode::~SectionNode() {}\n    CumulativeReporterBase::~CumulativeReporterBase() {}\n\n    StreamingReporterBase::~StreamingReporterBase() {}\n    ConsoleReporter::~ConsoleReporter() {}\n    CompactReporter::~CompactReporter() {}\n    IRunner::~IRunner() {}\n    IMutableContext::~IMutableContext() {}\n    IConfig::~IConfig() {}\n    XmlReporter::~XmlReporter() {}\n    JunitReporter::~JunitReporter() {}\n    TestRegistry::~TestRegistry() {}\n    FreeFunctionTestCase::~FreeFunctionTestCase() {}\n    IGeneratorInfo::~IGeneratorInfo() {}\n    IGeneratorsForTest::~IGeneratorsForTest() {}\n    WildcardPattern::~WildcardPattern() {}\n    TestSpec::Pattern::~Pattern() {}\n    TestSpec::NamePattern::~NamePattern() {}\n    TestSpec::TagPattern::~TagPattern() {}\n    TestSpec::ExcludedPattern::~ExcludedPattern() {}\n    Matchers::Impl::MatcherUntypedBase::~MatcherUntypedBase() {}\n\n    void Config::dummy() {}\n\n    namespace TestCaseTracking {\n        ITracker::~ITracker() {}\n        TrackerBase::~TrackerBase() {}\n        SectionTracker::~SectionTracker() {}\n        IndexTracker::~IndexTracker() {}\n    }\n}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#endif\n\n#ifdef CATCH_CONFIG_MAIN\n// #included from: internal/catch_default_main.hpp\n#define TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED\n\n#ifndef __OBJC__\n\n#if defined(WIN32) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)\n// Standard C/C++ Win32 Unicode wmain entry point\nextern \"C\" int wmain (int argc, wchar_t * argv[], wchar_t * []) {\n#else\n// Standard C/C++ main entry point\nint main (int argc, char * argv[]) {\n#endif\n\n    int result = Catch::Session().run( argc, argv );\n    return ( result < 0xff ? result : 0xff );\n}\n\n#else // __OBJC__\n\n// Objective-C entry point\nint main (int argc, char * const argv[]) {\n#if !CATCH_ARC_ENABLED\n    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\n#endif\n\n    Catch::registerTestMethods();\n    int result = Catch::Session().run( argc, (char* const*)argv );\n\n#if !CATCH_ARC_ENABLED\n    [pool drain];\n#endif\n\n    return ( result < 0xff ? result : 0xff );\n}\n\n#endif // __OBJC__\n\n#endif\n\n#ifdef CLARA_CONFIG_MAIN_NOT_DEFINED\n#  undef CLARA_CONFIG_MAIN\n#endif\n\n//////\n\n// If this config identifier is defined then all CATCH macros are prefixed with CATCH_\n#ifdef CATCH_CONFIG_PREFIX_ALL\n\n#if defined(CATCH_CONFIG_FAST_COMPILE)\n#define CATCH_REQUIRE( expr ) INTERNAL_CATCH_TEST_NO_TRY( \"CATCH_REQUIRE\", Catch::ResultDisposition::Normal, expr )\n#define CATCH_REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST_NO_TRY( \"CATCH_REQUIRE_FALSE\", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr )\n#else\n#define CATCH_REQUIRE( expr ) INTERNAL_CATCH_TEST( \"CATCH_REQUIRE\", Catch::ResultDisposition::Normal, expr )\n#define CATCH_REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( \"CATCH_REQUIRE_FALSE\", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr  )\n#endif\n\n#define CATCH_REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( \"CATCH_REQUIRE_THROWS\", Catch::ResultDisposition::Normal, \"\", expr )\n#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( \"CATCH_REQUIRE_THROWS_AS\", exceptionType, Catch::ResultDisposition::Normal, expr )\n#define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( \"CATCH_REQUIRE_THROWS_WITH\", Catch::ResultDisposition::Normal, matcher, expr )\n#define CATCH_REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( \"CATCH_REQUIRE_NOTHROW\", Catch::ResultDisposition::Normal, expr )\n\n#define CATCH_CHECK( expr ) INTERNAL_CATCH_TEST( \"CATCH_CHECK\", Catch::ResultDisposition::ContinueOnFailure, expr )\n#define CATCH_CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( \"CATCH_CHECK_FALSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, expr )\n#define CATCH_CHECKED_IF( expr ) INTERNAL_CATCH_IF( \"CATCH_CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure, expr )\n#define CATCH_CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( \"CATCH_CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure, expr )\n#define CATCH_CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( \"CATCH_CHECK_NOFAIL\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, expr )\n\n#define CATCH_CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( \"CATCH_CHECK_THROWS\", Catch::ResultDisposition::ContinueOnFailure, \"\", expr )\n#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( \"CATCH_CHECK_THROWS_AS\", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )\n#define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( \"CATCH_CHECK_THROWS_WITH\", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )\n#define CATCH_CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( \"CATCH_CHECK_NOTHROW\", Catch::ResultDisposition::ContinueOnFailure, expr )\n\n#define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( \"CATCH_CHECK_THAT\", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )\n\n#if defined(CATCH_CONFIG_FAST_COMPILE)\n#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT_NO_TRY( \"CATCH_REQUIRE_THAT\", matcher, Catch::ResultDisposition::Normal, arg )\n#else\n#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( \"CATCH_REQUIRE_THAT\", matcher, Catch::ResultDisposition::Normal, arg )\n#endif\n\n#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( \"CATCH_INFO\", msg )\n#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( \"CATCH_WARN\", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )\n#define CATCH_SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( \"CATCH_INFO\", msg )\n#define CATCH_CAPTURE( msg ) INTERNAL_CATCH_INFO( \"CATCH_CAPTURE\", #msg \" := \" << Catch::toString(msg) )\n#define CATCH_SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( \"CATCH_CAPTURE\", #msg \" := \" << Catch::toString(msg) )\n\n#ifdef CATCH_CONFIG_VARIADIC_MACROS\n    #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )\n    #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )\n    #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )\n    #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )\n    #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )\n    #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( \"CATCH_FAIL\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n    #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( \"CATCH_FAIL_CHECK\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n    #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( \"CATCH_SUCCEED\", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n#else\n    #define CATCH_TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )\n    #define CATCH_TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )\n    #define CATCH_METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )\n    #define CATCH_REGISTER_TEST_CASE( function, name, description ) INTERNAL_CATCH_REGISTER_TESTCASE( function, name, description )\n    #define CATCH_SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )\n    #define CATCH_FAIL( msg ) INTERNAL_CATCH_MSG( \"CATCH_FAIL\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, msg )\n    #define CATCH_FAIL_CHECK( msg ) INTERNAL_CATCH_MSG( \"CATCH_FAIL_CHECK\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, msg )\n    #define CATCH_SUCCEED( msg ) INTERNAL_CATCH_MSG( \"CATCH_SUCCEED\", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, msg )\n#endif\n#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( \"\", \"\" )\n\n#define CATCH_REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )\n#define CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )\n\n#define CATCH_GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )\n\n// \"BDD-style\" convenience wrappers\n#ifdef CATCH_CONFIG_VARIADIC_MACROS\n#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" __VA_ARGS__ )\n#else\n#define CATCH_SCENARIO( name, tags ) CATCH_TEST_CASE( \"Scenario: \" name, tags )\n#define CATCH_SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" name, tags )\n#endif\n#define CATCH_GIVEN( desc )    CATCH_SECTION( std::string( \"Given: \") + desc, \"\" )\n#define CATCH_WHEN( desc )     CATCH_SECTION( std::string( \" When: \") + desc, \"\" )\n#define CATCH_AND_WHEN( desc ) CATCH_SECTION( std::string( \"  And: \") + desc, \"\" )\n#define CATCH_THEN( desc )     CATCH_SECTION( std::string( \" Then: \") + desc, \"\" )\n#define CATCH_AND_THEN( desc ) CATCH_SECTION( std::string( \"  And: \") + desc, \"\" )\n\n// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required\n#else\n\n#if defined(CATCH_CONFIG_FAST_COMPILE)\n#define REQUIRE( expr ) INTERNAL_CATCH_TEST_NO_TRY( \"REQUIRE\", Catch::ResultDisposition::Normal, expr )\n#define REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST_NO_TRY( \"REQUIRE_FALSE\", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr )\n\n#else\n#define REQUIRE( expr ) INTERNAL_CATCH_TEST( \"REQUIRE\", Catch::ResultDisposition::Normal, expr  )\n#define REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( \"REQUIRE_FALSE\", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr )\n#endif\n\n#define REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( \"REQUIRE_THROWS\", Catch::ResultDisposition::Normal, \"\", expr )\n#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( \"REQUIRE_THROWS_AS\", exceptionType, Catch::ResultDisposition::Normal, expr )\n#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( \"REQUIRE_THROWS_WITH\", Catch::ResultDisposition::Normal, matcher, expr )\n#define REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( \"REQUIRE_NOTHROW\", Catch::ResultDisposition::Normal, expr )\n\n#define CHECK( expr ) INTERNAL_CATCH_TEST( \"CHECK\", Catch::ResultDisposition::ContinueOnFailure, expr )\n#define CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( \"CHECK_FALSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, expr )\n#define CHECKED_IF( expr ) INTERNAL_CATCH_IF( \"CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure, expr )\n#define CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( \"CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure, expr )\n#define CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( \"CHECK_NOFAIL\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, expr )\n\n#define CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( \"CHECK_THROWS\", Catch::ResultDisposition::ContinueOnFailure, \"\", expr )\n#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( \"CHECK_THROWS_AS\", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )\n#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( \"CHECK_THROWS_WITH\", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )\n#define CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( \"CHECK_NOTHROW\", Catch::ResultDisposition::ContinueOnFailure, expr )\n\n#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( \"CHECK_THAT\", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )\n\n#if defined(CATCH_CONFIG_FAST_COMPILE)\n#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT_NO_TRY( \"REQUIRE_THAT\", matcher, Catch::ResultDisposition::Normal, arg )\n#else\n#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( \"REQUIRE_THAT\", matcher, Catch::ResultDisposition::Normal, arg )\n#endif\n\n#define INFO( msg ) INTERNAL_CATCH_INFO( \"INFO\", msg )\n#define WARN( msg ) INTERNAL_CATCH_MSG( \"WARN\", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )\n#define SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( \"INFO\", msg )\n#define CAPTURE( msg ) INTERNAL_CATCH_INFO( \"CAPTURE\", #msg \" := \" << Catch::toString(msg) )\n#define SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( \"CAPTURE\", #msg \" := \" << Catch::toString(msg) )\n\n#ifdef CATCH_CONFIG_VARIADIC_MACROS\n#define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )\n#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )\n#define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )\n#define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )\n#define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )\n#define FAIL( ... ) INTERNAL_CATCH_MSG( \"FAIL\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n#define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( \"FAIL_CHECK\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n#define SUCCEED( ... ) INTERNAL_CATCH_MSG( \"SUCCEED\", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n#else\n#define TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )\n    #define TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )\n    #define METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )\n    #define REGISTER_TEST_CASE( method, name, description ) INTERNAL_CATCH_REGISTER_TESTCASE( method, name, description )\n    #define SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )\n    #define FAIL( msg ) INTERNAL_CATCH_MSG( \"FAIL\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, msg )\n    #define FAIL_CHECK( msg ) INTERNAL_CATCH_MSG( \"FAIL_CHECK\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, msg )\n    #define SUCCEED( msg ) INTERNAL_CATCH_MSG( \"SUCCEED\", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, msg )\n#endif\n#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( \"\", \"\" )\n\n#define REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )\n#define REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )\n\n#define GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )\n\n#endif\n\n#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )\n\n// \"BDD-style\" convenience wrappers\n#ifdef CATCH_CONFIG_VARIADIC_MACROS\n#define SCENARIO( ... ) TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" __VA_ARGS__ )\n#else\n#define SCENARIO( name, tags ) TEST_CASE( \"Scenario: \" name, tags )\n#define SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" name, tags )\n#endif\n#define GIVEN( desc )    SECTION( std::string(\"   Given: \") + desc, \"\" )\n#define WHEN( desc )     SECTION( std::string(\"    When: \") + desc, \"\" )\n#define AND_WHEN( desc ) SECTION( std::string(\"And when: \") + desc, \"\" )\n#define THEN( desc )     SECTION( std::string(\"    Then: \") + desc, \"\" )\n#define AND_THEN( desc ) SECTION( std::string(\"     And: \") + desc, \"\" )\n\nusing Catch::Detail::Approx;\n\n// #included from: internal/catch_reenable_warnings.h\n\n#define TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED\n\n#ifdef __clang__\n#    ifdef __ICC // icpc defines the __clang__ macro\n#        pragma warning(pop)\n#    else\n#        pragma clang diagnostic pop\n#    endif\n#elif defined __GNUC__\n#    pragma GCC diagnostic pop\n#endif\n\n#endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED\n",
			"file": "src/catch.h",
			"file_size": 420569,
			"file_write_time": 131440657815283995,
			"settings":
			{
				"buffer_size": 420569,
				"encoding": "UTF-8",
				"line_ending": "Unix",
				"name": "/*"
			}
		},
		{
			"file": "src/catch.cc",
			"settings":
			{
				"buffer_size": 229,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/BUILD",
			"settings":
			{
				"buffer_size": 633,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/binner.cc",
			"settings":
			{
				"buffer_size": 793,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/binner_test.cc",
			"settings":
			{
				"buffer_size": 273,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "cc_library(\n\tname = \"binner\",\n\tsrcs = [\"binner.cc\"],\n\thdrs = [\"binner.h\"],\n)\n",
			"file": "BUILD",
			"file_size": 77,
			"file_write_time": 131440623898780934,
			"settings":
			{
				"buffer_size": 77,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 152.0,
		"last_filter": "INSTA",
		"selected_items":
		[
			[
				"INSTA",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"insall",
				"Install Package Control"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/jchiu/projects/mpsft",
		"/home/jchiu/projects/mpsft/src"
	],
	"file_history":
	[
		"/home/jchiu/projects/mpsft/src/rand.cc",
		"/home/jchiu/projects/mpsft/src/rand.h",
		"/home/jchiu/.config/sublime-text-3/Packages/Clang Format/Default (Linux).sublime-keymap",
		"/home/jchiu/Dropbox/mpfft-singlefile/mpfft3.cpp~",
		"/home/jchiu/seastar/tests/lowres_clock_test.cc"
	],
	"find":
	{
		"height": 23.0
	},
	"find_in_files":
	{
		"height": 90.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"double",
			"int32_t",
			"int64_t",
			"int32_t",
			"int64_t",
			"int32_t",
			"FreqID",
			"bufr",
			"bufR",
			"p2",
			"even",
			"sleep_duration"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "README.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 461,
						"regions":
						{
						},
						"selection":
						[
							[
								342,
								342
							]
						],
						"settings":
						{
							"syntax": "Packages/Markdown/Markdown.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/binner.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 352,
						"regions":
						{
						},
						"selection":
						[
							[
								352,
								352
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 2,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 36032,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										150,
										156
									],
									[
										383,
										389
									],
									[
										652,
										658
									],
									[
										961,
										967
									],
									[
										1254,
										1260
									],
									[
										1493,
										1499
									],
									[
										1660,
										1666
									],
									[
										1786,
										1792
									],
									[
										2071,
										2077
									],
									[
										2172,
										2178
									],
									[
										2401,
										2407
									],
									[
										2482,
										2488
									],
									[
										2633,
										2639
									],
									[
										2824,
										2830
									],
									[
										3052,
										3058
									],
									[
										3323,
										3329
									],
									[
										3588,
										3594
									],
									[
										3853,
										3859
									],
									[
										3957,
										3963
									],
									[
										4141,
										4147
									],
									[
										4259,
										4265
									],
									[
										4429,
										4435
									],
									[
										4533,
										4539
									],
									[
										4717,
										4723
									],
									[
										4835,
										4841
									],
									[
										5005,
										5011
									],
									[
										5095,
										5101
									],
									[
										5283,
										5289
									],
									[
										5370,
										5376
									],
									[
										5557,
										5563
									],
									[
										5641,
										5647
									],
									[
										5749,
										5755
									],
									[
										5893,
										5899
									],
									[
										6105,
										6111
									],
									[
										6210,
										6216
									],
									[
										6354,
										6360
									],
									[
										6460,
										6466
									],
									[
										6614,
										6620
									],
									[
										6730,
										6736
									],
									[
										6884,
										6890
									],
									[
										6993,
										6999
									],
									[
										7117,
										7123
									],
									[
										7237,
										7243
									],
									[
										7351,
										7357
									],
									[
										7378,
										7384
									],
									[
										7404,
										7410
									],
									[
										7429,
										7435
									],
									[
										7558,
										7564
									],
									[
										7618,
										7624
									],
									[
										7868,
										7874
									],
									[
										7952,
										7958
									],
									[
										8166,
										8172
									],
									[
										8416,
										8422
									],
									[
										8615,
										8621
									],
									[
										8795,
										8801
									],
									[
										8957,
										8963
									],
									[
										9319,
										9325
									],
									[
										9543,
										9549
									],
									[
										9612,
										9618
									],
									[
										9826,
										9832
									],
									[
										10161,
										10167
									],
									[
										10440,
										10446
									],
									[
										10683,
										10689
									],
									[
										10952,
										10958
									],
									[
										11261,
										11267
									],
									[
										11554,
										11560
									],
									[
										11793,
										11799
									],
									[
										11960,
										11966
									],
									[
										12086,
										12092
									],
									[
										12371,
										12377
									],
									[
										12472,
										12478
									],
									[
										12701,
										12707
									],
									[
										12782,
										12788
									],
									[
										12933,
										12939
									],
									[
										13124,
										13130
									],
									[
										13352,
										13358
									],
									[
										13623,
										13629
									],
									[
										13888,
										13894
									],
									[
										14153,
										14159
									],
									[
										14257,
										14263
									],
									[
										14441,
										14447
									],
									[
										14559,
										14565
									],
									[
										14729,
										14735
									],
									[
										14833,
										14839
									],
									[
										15017,
										15023
									],
									[
										15135,
										15141
									],
									[
										15305,
										15311
									],
									[
										15395,
										15401
									],
									[
										15583,
										15589
									],
									[
										15670,
										15676
									],
									[
										15857,
										15863
									],
									[
										15941,
										15947
									],
									[
										16049,
										16055
									],
									[
										16193,
										16199
									],
									[
										16405,
										16411
									],
									[
										16510,
										16516
									],
									[
										16654,
										16660
									],
									[
										16760,
										16766
									],
									[
										16914,
										16920
									],
									[
										17030,
										17036
									],
									[
										17184,
										17190
									],
									[
										17293,
										17299
									],
									[
										17417,
										17423
									],
									[
										17537,
										17543
									],
									[
										17651,
										17657
									],
									[
										17678,
										17684
									],
									[
										17704,
										17710
									],
									[
										17729,
										17735
									],
									[
										17858,
										17864
									],
									[
										17918,
										17924
									],
									[
										18168,
										18174
									],
									[
										18252,
										18258
									],
									[
										18466,
										18472
									],
									[
										18716,
										18722
									],
									[
										18915,
										18921
									],
									[
										19095,
										19101
									],
									[
										19257,
										19263
									],
									[
										19619,
										19625
									],
									[
										19843,
										19849
									],
									[
										19912,
										19918
									],
									[
										20126,
										20132
									],
									[
										20461,
										20467
									],
									[
										20847,
										20853
									],
									[
										20902,
										20908
									],
									[
										21122,
										21128
									],
									[
										21165,
										21171
									],
									[
										21457,
										21463
									],
									[
										21677,
										21683
									],
									[
										21722,
										21728
									],
									[
										22013,
										22019
									],
									[
										22396,
										22402
									],
									[
										22617,
										22623
									],
									[
										22660,
										22666
									],
									[
										22952,
										22958
									],
									[
										23172,
										23178
									],
									[
										23217,
										23223
									],
									[
										23506,
										23512
									],
									[
										23920,
										23926
									],
									[
										24042,
										24048
									],
									[
										24177,
										24183
									],
									[
										24311,
										24317
									],
									[
										24601,
										24607
									],
									[
										24913,
										24919
									],
									[
										25263,
										25269
									],
									[
										25732,
										25738
									],
									[
										26097,
										26103
									],
									[
										26363,
										26369
									],
									[
										26552,
										26558
									],
									[
										26698,
										26704
									],
									[
										26983,
										26989
									],
									[
										27101,
										27107
									],
									[
										27338,
										27344
									],
									[
										27426,
										27432
									],
									[
										27562,
										27568
									],
									[
										27779,
										27785
									],
									[
										28110,
										28116
									],
									[
										28382,
										28388
									],
									[
										28648,
										28654
									],
									[
										28914,
										28920
									],
									[
										29036,
										29042
									],
									[
										29196,
										29202
									],
									[
										29332,
										29338
									],
									[
										29478,
										29484
									],
									[
										29600,
										29606
									],
									[
										29760,
										29766
									],
									[
										29896,
										29902
									],
									[
										30042,
										30048
									],
									[
										30148,
										30154
									],
									[
										30320,
										30326
									],
									[
										30423,
										30429
									],
									[
										30594,
										30600
									],
									[
										30694,
										30700
									],
									[
										30823,
										30829
									],
									[
										31003,
										31009
									],
									[
										31367,
										31373
									],
									[
										31498,
										31504
									],
									[
										31668,
										31674
									],
									[
										31800,
										31806
									],
									[
										31978,
										31984
									],
									[
										32118,
										32124
									],
									[
										32296,
										32302
									],
									[
										32427,
										32433
									],
									[
										32581,
										32587
									],
									[
										32731,
										32737
									],
									[
										32872,
										32878
									],
									[
										32905,
										32911
									],
									[
										32937,
										32943
									],
									[
										32968,
										32974
									],
									[
										33117,
										33123
									],
									[
										33193,
										33199
									],
									[
										33445,
										33451
									],
									[
										33537,
										33543
									],
									[
										33789,
										33795
									],
									[
										34016,
										34022
									],
									[
										34251,
										34257
									],
									[
										34459,
										34465
									],
									[
										34630,
										34636
									],
									[
										34944,
										34950
									],
									[
										35219,
										35225
									],
									[
										35298,
										35304
									],
									[
										35537,
										35543
									],
									[
										35832,
										35838
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								492,
								492
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 1,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/base.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 323,
						"regions":
						{
						},
						"selection":
						[
							[
								266,
								266
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "src/base.cc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 185,
						"regions":
						{
						},
						"selection":
						[
							[
								185,
								185
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "src/perm.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 723,
						"regions":
						{
						},
						"selection":
						[
							[
								612,
								612
							]
						],
						"settings":
						{
							"auto_name": "p",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "src/perm.cc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 657,
						"regions":
						{
						},
						"selection":
						[
							[
								52,
								52
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "src/perm_test.cc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 433,
						"regions":
						{
						},
						"selection":
						[
							[
								433,
								433
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "src/catch.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 420569,
						"regions":
						{
						},
						"selection":
						[
							[
								414314,
								414314
							]
						],
						"settings":
						{
							"auto_name": "/*",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 171449.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "src/catch.cc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 229,
						"regions":
						{
						},
						"selection":
						[
							[
								229,
								229
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "src/BUILD",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 633,
						"regions":
						{
						},
						"selection":
						[
							[
								598,
								598
							]
						],
						"settings":
						{
							"syntax": "Packages/C#/Build.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "src/binner.cc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 793,
						"regions":
						{
						},
						"selection":
						[
							[
								767,
								767
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "src/binner_test.cc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 273,
						"regions":
						{
						},
						"selection":
						[
							[
								253,
								253
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "BUILD",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 77,
						"regions":
						{
						},
						"selection":
						[
							[
								76,
								76
							]
						],
						"settings":
						{
							"syntax": "Packages/C#/Build.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "mpsft.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 274.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
